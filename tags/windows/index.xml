<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows on MLAcookie</title><link>https://mlacookie.github.io/tags/windows/</link><description>Recent content in Windows on MLAcookie</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 22 Aug 2024 22:04:25 +0800</lastBuildDate><atom:link href="https://mlacookie.github.io/tags/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>如何Windows+Manjaro双系统</title><link>https://mlacookie.github.io/article/posts/%E5%A6%82%E4%BD%95windows+manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 22 Aug 2024 22:04:25 +0800</pubDate><guid>https://mlacookie.github.io/article/posts/%E5%A6%82%E4%BD%95windows+manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F/</guid><description>&lt;p>emmmm&lt;br>
之前在笔记本上安装了Manjaro&lt;br>
基本上所有需要的软件都有了解决方案&lt;br>
甚至打游戏都不是很大的问题&lt;br>
结果没想到败在了游戏加速器上&lt;br>
Linux没有现成的游戏加速器，而且我不会配网卡类型的代理&lt;br>
（就算配起来我也没有游戏优化的代理服务器）&lt;/p>
&lt;p>所以没办法，又要用Windows了&lt;br>
不过我又不想放弃Linux的轻量精简&lt;br>
于是我就给笔记本做了个双系统&lt;/p>
&lt;p>（因为在物理机上安装，所以目前没什么图，有机会再补吧）&lt;/p>
&lt;h2 id="0x00-前置准备">&amp;lt;0x00&amp;gt; 前置准备
&lt;/h2>&lt;p>首先需要一个U盘，做系统安装盘&lt;br>
这次仍然使用Ventoy做系统引导&lt;br>
Ventoy的使用就不说了，基本上就是软件打开选择U盘安装即可 &lt;br>
然后需要准备需要的Windows镜像和Manjaro镜像&lt;br>
还需要一个WinPE的镜像，我的建议是用微PE工具生成一个&lt;br>
我们需要使用这个PE来提前给硬盘分区&lt;/p>
&lt;h2 id="0x01-pe中的操作">&amp;lt;0x01&amp;gt; PE中的操作
&lt;/h2>&lt;p>PE中，我们主要是给系统进行分盘&lt;br>
如果你会在Windows安装器中分盘的话可以跳过&lt;/p>
&lt;p>Ventoy引导进PE的iso&lt;br>
一般PE中会带一个分区工具，有啥用啥，我使用的是DG&lt;br>
里面有个快速分区工具，使用这个分两个盘，大小随意&lt;br>
分出来都是NTFS格式的，删除希望安装Manjaro的分区，等之后用Manjaro安装工具分区&lt;br>
分好区后，保存更改，就可以退出PE系统了&lt;/p>
&lt;h3 id="为什么要提前分盘">为什么要提前分盘
&lt;/h3>&lt;p>现在我们安装系统都是将硬盘做成GPT分区格式&lt;br>
里面有一个EFI分区，里面会放系统的引导&lt;br>
如果用Windows安装器在没有任何分区的硬盘上安装&lt;br>
它会自动创建一个100MB的EFI分区&lt;br>
但对Linux来说，这100MB的EFI分区太小了，Linux建议大于300MB&lt;br>
而DG的快速分区可以在分出两个大小的分区的同时，自动创建300MB的EFI分区&lt;br>
正好满足我们的需求&lt;/p>
&lt;h2 id="0x02-安装windows">&amp;lt;0x02&amp;gt; 安装Windows
&lt;/h2>&lt;p>Ventoy引导进Windows的iso&lt;br>
Windows安装在之前分的你希望的位置&lt;br>
基本上就按照安装器指引即可&lt;/p>
&lt;h2 id="0x03-安装manjaro">&amp;lt;0x03&amp;gt; 安装Manjaro
&lt;/h2>&lt;p>Ventoy引导进Manjaro的iso&lt;br>
在安装中，需要选择最下面的手动分区&lt;br>
对于300MB的EFI分区，我们需要编辑，设置挂载点为&lt;code>/boot/efi&lt;/code>，下面的标记别动&lt;br>
这个很关键，将影响我们能否引导进系统&lt;br>
对于希望安装Manjaro的位置，首先新建分区，我选择的是&lt;code>ext4&lt;/code>&lt;br>
然后编辑分区，设置挂载点为&lt;code>/&lt;/code>，选择标记为&lt;code>boot&lt;/code> &lt;br>
剩下的挂载点我看别人是有配置的，不过这样配置两个挂载点就够了&lt;br>
剩下就让安装器折腾就可以了&lt;/p>
&lt;p>安装后进入&lt;code>BIOS&lt;/code>，设置硬盘的启动项，这时候里面会有一个Manjaro的选项&lt;br>
（注意不是启动项，是硬盘的启动项，管理一个硬盘里面的启动项）&lt;/p>
&lt;p>这样之后，理论上启动后默认进入Manjaro的grub界面&lt;/p></description></item><item><title>相对优雅得C#调用Win32API</title><link>https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/</link><pubDate>Sun, 21 Jul 2024 21:08:14 +0800</pubDate><guid>https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/</guid><description>&lt;p>今天有人找我解决一些软件相关的问题，然后发现会牵扯到一些Win32的API&lt;br>
一般调用Win32API都是用C++方便的，而且微软给的文档也是C++的&lt;br>
我虽然对C++不是很熟，但对C#熟啊&lt;/p>
&lt;p>在C#中，我们可以通过&lt;code>P/Invoke&lt;/code>去做动态库的互操作&lt;br>
但对于Win32API，如果自己写&lt;code>P/Invoke&lt;/code>，里面就有很多不确定的东西&lt;br>
光是那个DllImport特性里面的参数就不是很好填&lt;/p>
&lt;p>那C#开发者是不是很难做Win32开发呢，那也不是&lt;br>
在Nuget上有很多别的大佬包装好的Win32库，安装完可以直接调用&lt;br>
但Win32中有超级多的API，这会导致代码提示里面会多出非常多东西，确实是有点干扰了&lt;/p>
&lt;p>但好在微软也提供了一个解决方案，&lt;a class="link" href="https://github.com/microsoft/CsWin32" target="_blank" rel="noopener"
>CsWin32&lt;/a>&lt;br>
这个是基于C#&lt;code>源生成器&lt;/code>的Win32API封装器&lt;br>
就是需要什么API，它就去生成那些API的&lt;code>P/Invoke&lt;/code>代码&lt;br>
并且生成的质量还挺高的，保留原本的调用风格的同时，尽可能去迎合C#的开发体验&lt;/p>
&lt;h2 id="0x00-安装cswin32">&amp;lt;0x00&amp;gt; 安装CsWin32
&lt;/h2>&lt;p>因为会用到C#的源生成器，所以最好使用VS2022并且相对新的版本，不然代码提示之类的会出问题&lt;br>
VSCode的源生成器体验也是不错的，这个直接装&lt;code>C# kit&lt;/code>插件就可以了&lt;/p>
&lt;p>直接在Nuget中搜索CsWin32，包名是Microsoft.Windows.CsWin32&lt;br>
这个包最低支持到&lt;code>.net framework 4.5&lt;/code>也即&lt;code>.NET Standard 2.0&lt;/code>&lt;br>
对于这个版本，还需要安装&lt;code>System.Memory&lt;/code>&lt;br>
如果是&lt;code>.NET Standard 2.1&lt;/code>及以上，也即&lt;code>.net 5.0&lt;/code>及以上的版本，那么就不需要安装&lt;br>
（如果是新项目的话应该会用新版本的框架吧）&lt;/p>
&lt;h2 id="0x01-如何使用">&amp;lt;0x01&amp;gt; 如何使用
&lt;/h2>&lt;h3 id="添加需要的api">添加需要的API
&lt;/h3>&lt;p>首先是要告诉源生成器要生成哪些API的封装&lt;br>
在项目根目录新建叫&lt;code>NativeMethods.txt&lt;/code>的文件&lt;br>
&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1.png"
width="240"
height="95"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1_hu3330581896057511162.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1_hu13047833802146296135.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="252"
data-flex-basis="606px"
>&lt;br>
在里面可以添加你需要添加的Win32函数或者结构的名字&lt;/p>
&lt;pre tabindex="0">&lt;code>PssCaptureSnapshot
PssQuerySnapshot
PSS_PROCESS_INFORMATION
PSS_HANDLE_INFORMATION
PSS_VA_CLONE_INFORMATION
&lt;/code>&lt;/pre>&lt;p>这里的示例是Windows&lt;a class="link" href="https://learn.microsoft.com/zh-cn/windows/win32/api/_proc_snap/" target="_blank" rel="noopener"
>进程快照&lt;/a>相关的API，使用的API也不多，仅做演示作用&lt;/p>
&lt;h3 id="简单解释下使用的api">简单解释下使用的API
&lt;/h3>&lt;h4 id="psscapturesnapshot">PssCaptureSnapshot
&lt;/h4>&lt;p>捕获目标进程的快照&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>DWORD &lt;span style="color:#a6e22e">PssCaptureSnapshot&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] HANDLE ProcessHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] PSS_CAPTURE_FLAGS CaptureFlags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in, optional] DWORD ThreadContextFlags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [out] HPSS &lt;span style="color:#f92672">*&lt;/span>SnapshotHandle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ProcessHandle&lt;/code>目标进程的句柄&lt;br>
&lt;code>CaptureFlags&lt;/code>指定要捕获的标志&lt;br>
&lt;code>ThreadContextFlags&lt;/code>如果 CaptureFlags 指定线程上下文，则要捕获的 CONTEXT 记录标志&lt;br>
&lt;code>SnapshotHandle&lt;/code>返回此函数捕获的快照的句柄&lt;/p>
&lt;p>函数返回的是&lt;code>winerror.h&lt;/code>中定义的错误代码，无错误是&lt;code>ERROR_SUCCESS&lt;/code>&lt;/p>
&lt;h4 id="pssquerysnapshot">PssQuerySnapshot
&lt;/h4>&lt;p>查询捕获的快照的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>DWORD &lt;span style="color:#a6e22e">PssQuerySnapshot&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] HPSS SnapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] PSS_QUERY_INFORMATION_CLASS InformationClass,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [out] &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Buffer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] DWORD BufferLength
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>SnapshotHandle&lt;/code>要查询的快照的句柄&lt;br>
&lt;code>InformationClass&lt;/code>用于选择要查询的信息&lt;br>
&lt;code>Buffer&lt;/code>此函数提供的信息，类型由&lt;code>InformationClass&lt;/code>决定&lt;br>
&lt;code>BufferLength&lt;/code>缓冲区的大小（以字节为单位）&lt;/p>
&lt;p>函数返回的是&lt;code>winerror.h&lt;/code>中定义的错误代码，无错误是&lt;code>ERROR_SUCCESS&lt;/code>&lt;/p>
&lt;p>剩下的是一些结构，东西多就不细讲了，跟本文关系不大，具体就看文档吧&lt;/p>
&lt;h3 id="在代码中使用win32api">在代码中使用Win32API
&lt;/h3>&lt;p>这里做一个使用Win32API查询进程PID的示例&lt;br>
（虽然C#的Process类对象本身就可以直接查询）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Diagnostics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.System.Diagnostics.ProcessSnapshotting;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用C#自带的Process类型获取记事本进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Process test = Process.GetProcessesByName(&lt;span style="color:#e6db74">&amp;#34;notepad&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明一个查询flags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用Win32API来捕获进程快照&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssCaptureSnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.SafeHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">out&lt;/span> HPSS snapshotHandle);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明查询进程基本信息的变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_PROCESS_INFORMATION info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 涉及到指针操作，所以要用unsafe块包装&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用Win32API来查询进程快照信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssQuerySnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;amp;info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">uint&lt;/span>)&lt;span style="color:#66d9ef">sizeof&lt;/span>(PSS_PROCESS_INFORMATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(info.ProcessId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3.png"
width="829"
height="166"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3_hu4089936009756936439.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3_hu9622210321053220712.png 1024w"
loading="lazy"
alt="运行结果"
class="gallery-image"
data-flex-grow="499"
data-flex-basis="1198px"
>&lt;/p>
&lt;p>确实是获取到了记事本的PID&lt;/p>
&lt;p>而且观察代码，不难发现，CsWin32会非常智能地使用C#自带的类型&lt;br>
比如说Process类型里面的SafeHandle属性，这个返回的是&lt;code>SafeProcessHandle&lt;/code>&lt;br>
这个虽然它的命名空间是&lt;code>Microsoft.Win32.SafeHandles&lt;/code>，但确实是C#本身就有的&lt;br>
对于C#不带的类型，只有使用的API需要这些类型传参，CsWin32才会去生成对应的代码&lt;/p>
&lt;h2 id="0x02-一些不知道类型的枚举">&amp;lt;0x02&amp;gt; 一些不知道类型的枚举
&lt;/h2>&lt;p>如果你需要使用某个枚举，但不知道是什么类型，CsWin32可以自动指出具体类型&lt;br>
比如前面提到那两个API的返回值是&lt;code>winerror.h&lt;/code>中定义的错误代码，但我们不知道这是什么类&lt;br>
这时候可以在&lt;code>NativeMethods.txt&lt;/code>里面直接加上&lt;code>ERROR_SUCCESS&lt;/code>&lt;br>
CsWin32会抛出警告：应该使用正确的声明&lt;br>
&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2.png"
width="615"
height="24"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2_hu3942554170736800697.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2_hu12287234937168092029.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="2562"
data-flex-basis="6150px"
>&lt;br>
最后也指出正确的声明是&lt;code>WIN32_ERROR&lt;/code>，文件里改好就行&lt;br>
这里对上面的代码稍作修改作为示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Diagnostics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.Foundation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.System.Diagnostics.ProcessSnapshotting;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Process test = Process.GetProcessesByName(&lt;span style="color:#e6db74">&amp;#34;notepad&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssCaptureSnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.SafeHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">out&lt;/span> HPSS snapshotHandle);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_PROCESS_INFORMATION info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 添加错误码的声明&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> errorCode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取错误码返回值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errorCode = PInvoke.PssQuerySnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;amp;info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">uint&lt;/span>)&lt;span style="color:#66d9ef">sizeof&lt;/span>(PSS_PROCESS_INFORMATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(info.ProcessId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 跟WIN32_ERROR.ERROR_SUCCESS做比较，返回True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine((WIN32_ERROR)errorCode == WIN32_ERROR.ERROR_SUCCESS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然头铁不改正确的声明也没关系，也是这样使用&lt;/p>
&lt;p>对于其他不知道怎么声明的枚举也可以这样让CsWin32去找&lt;/p></description></item><item><title>在Win10LTSC上安装截图与草图</title><link>https://mlacookie.github.io/article/posts/%E5%9C%A8win10ltsc%E4%B8%8A%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE%E4%B8%8E%E8%8D%89%E5%9B%BE/</link><pubDate>Sun, 03 Mar 2024 01:57:13 +0000</pubDate><guid>https://mlacookie.github.io/article/posts/%E5%9C%A8win10ltsc%E4%B8%8A%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE%E4%B8%8E%E8%8D%89%E5%9B%BE/</guid><description>&lt;p>众所周知，Win10的LTSC非常精简&lt;br>
精简到原本的&lt;code>截图与草图&lt;/code>的工具都没了&lt;br>
系统里只能截图，然后自动保存在剪贴板中&lt;/p>
&lt;p>但这不是很方便，比方说要保存到某个目录中，或者做些标记&lt;br>
所以还是挺需要原本的截图与草图工具的&lt;/p>
&lt;p>&lt;code>截图与草图&lt;/code>工具可以在微软的软件商店中下载到&lt;br>
但问题是，Win10LTSC也没有软件商店&lt;br>
这个可以靠配置&lt;code>winget&lt;/code>来解决&lt;br>
（这个的配置这里暂时不讲，网上的教程很多）&lt;/p>
&lt;p>如果需要安装&lt;code>截图与草图&lt;/code>，需要在命令行中输入下面的指令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>winget install &lt;span style="color:#e6db74">&amp;#34;Snipping Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回车等待就好了，安装完就能用了&lt;/p></description></item></channel></rss>