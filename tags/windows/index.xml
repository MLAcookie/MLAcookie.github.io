<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows on MLAcookie</title><link>https://mlacookie.github.io/tags/windows/</link><description>Recent content in Windows on MLAcookie</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 21 Jul 2024 21:08:14 +0800</lastBuildDate><atom:link href="https://mlacookie.github.io/tags/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>相对优雅得C#调用Win32API</title><link>https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/</link><pubDate>Sun, 21 Jul 2024 21:08:14 +0800</pubDate><guid>https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/</guid><description>&lt;p>今天有人找我解决一些软件相关的问题，然后发现会牵扯到一些Win32的API&lt;br>
一般调用Win32API都是用C++方便的，而且微软给的文档也是C++的&lt;br>
我虽然对C++不是很熟，但对C#熟啊&lt;/p>
&lt;p>在C#中，我们可以通过&lt;code>P/Invoke&lt;/code>去做动态库的互操作&lt;br>
但对于Win32API，如果自己写&lt;code>P/Invoke&lt;/code>，里面就有很多不确定的东西&lt;br>
光是那个DllImport特性里面的参数就不是很好填&lt;/p>
&lt;p>那C#开发者是不是很难做Win32开发呢，那也不是&lt;br>
在Nuget上有很多别的大佬包装好的Win32库，安装完可以直接调用&lt;br>
但Win32中有超级多的API，这会导致代码提示里面会多出非常多东西，确实是有点干扰了&lt;/p>
&lt;p>但好在微软也提供了一个解决方案，&lt;a class="link" href="https://github.com/microsoft/CsWin32" target="_blank" rel="noopener"
>CsWin32&lt;/a>&lt;br>
这个是基于C#&lt;code>源生成器&lt;/code>的Win32API封装器&lt;br>
就是需要什么API，它就去生成那些API的&lt;code>P/Invoke&lt;/code>代码&lt;br>
并且生成的质量还挺高的，保留原本的调用风格的同时，尽可能去迎合C#的开发体验&lt;/p>
&lt;h2 id="0x00-安装cswin32">&amp;lt;0x00&amp;gt; 安装CsWin32
&lt;/h2>&lt;p>因为会用到C#的源生成器，所以最好使用VS2022并且相对新的版本，不然代码提示之类的会出问题&lt;br>
VSCode的源生成器体验也是不错的，这个直接装&lt;code>C# kit&lt;/code>插件就可以了&lt;/p>
&lt;p>直接在Nuget中搜索CsWin32，包名是Microsoft.Windows.CsWin32&lt;br>
这个包最低支持到&lt;code>.net framework 4.5&lt;/code>也即&lt;code>.NET Standard 2.0&lt;/code>&lt;br>
对于这个版本，还需要安装&lt;code>System.Memory&lt;/code>&lt;br>
如果是&lt;code>.NET Standard 2.1&lt;/code>及以上，也即&lt;code>.net 5.0&lt;/code>及以上的版本，那么就不需要安装&lt;br>
（如果是新项目的话应该会用新版本的框架吧）&lt;/p>
&lt;h2 id="0x01-如何使用">&amp;lt;0x01&amp;gt; 如何使用
&lt;/h2>&lt;h3 id="添加需要的api">添加需要的API
&lt;/h3>&lt;p>首先是要告诉源生成器要生成哪些API的封装&lt;br>
在项目跟目录新建叫&lt;code>NativeMethods.txt&lt;/code>的文件&lt;br>
&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1.png"
width="240"
height="95"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1_hu6a09a0ddf8f93eb58b706e0f32bfc667_4003_480x0_resize_box_3.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/1_hu6a09a0ddf8f93eb58b706e0f32bfc667_4003_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="252"
data-flex-basis="606px"
>&lt;br>
在里面可以添加你需要添加的Win32函数或者结构的名字&lt;/p>
&lt;pre tabindex="0">&lt;code>PssCaptureSnapshot
PssQuerySnapshot
PSS_PROCESS_INFORMATION
PSS_HANDLE_INFORMATION
PSS_VA_CLONE_INFORMATION
&lt;/code>&lt;/pre>&lt;p>这里的示例是Windows&lt;a class="link" href="https://learn.microsoft.com/zh-cn/windows/win32/api/_proc_snap/" target="_blank" rel="noopener"
>进程快照&lt;/a>相关的API，使用的API也不多，仅做演示作用&lt;/p>
&lt;h3 id="简单解释下使用的api">简单解释下使用的API
&lt;/h3>&lt;h4 id="psscapturesnapshot">PssCaptureSnapshot
&lt;/h4>&lt;p>捕获目标进程的快照&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>DWORD &lt;span style="color:#a6e22e">PssCaptureSnapshot&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] HANDLE ProcessHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] PSS_CAPTURE_FLAGS CaptureFlags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in, optional] DWORD ThreadContextFlags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [out] HPSS &lt;span style="color:#f92672">*&lt;/span>SnapshotHandle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ProcessHandle&lt;/code>目标进程的句柄&lt;br>
&lt;code>CaptureFlags&lt;/code>指定要捕获的标志&lt;br>
&lt;code>ThreadContextFlags&lt;/code>如果 CaptureFlags 指定线程上下文，则要捕获的 CONTEXT 记录标志&lt;br>
&lt;code>SnapshotHandle&lt;/code>返回此函数捕获的快照的句柄&lt;/p>
&lt;p>函数返回的是&lt;code>winerror.h&lt;/code>中定义的错误代码，无错误是&lt;code>ERROR_SUCCESS&lt;/code>&lt;/p>
&lt;h4 id="pssquerysnapshot">PssQuerySnapshot
&lt;/h4>&lt;p>查询捕获的快照的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>DWORD &lt;span style="color:#a6e22e">PssQuerySnapshot&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] HPSS SnapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] PSS_QUERY_INFORMATION_CLASS InformationClass,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [out] &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Buffer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [in] DWORD BufferLength
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>SnapshotHandle&lt;/code>要查询的快照的句柄&lt;br>
&lt;code>InformationClass&lt;/code>用于选择要查询的信息&lt;br>
&lt;code>Buffer&lt;/code>此函数提供的信息，类型由&lt;code>InformationClass&lt;/code>决定&lt;br>
&lt;code>BufferLength&lt;/code>缓冲区的大小（以字节为单位）&lt;/p>
&lt;p>函数返回的是&lt;code>winerror.h&lt;/code>中定义的错误代码，无错误是&lt;code>ERROR_SUCCESS&lt;/code>&lt;/p>
&lt;p>剩下的是一些结构，东西多就不细讲了，跟本文关系不大，具体就看文档吧&lt;/p>
&lt;h3 id="在代码中使用win32api">在代码中使用Win32API
&lt;/h3>&lt;p>这里做一个使用Win32API查询进程PID的示例&lt;br>
（虽然C#的Process类对象本身就可以直接查询）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Diagnostics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.System.Diagnostics.ProcessSnapshotting;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用C#自带的Process类型获取记事本进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Process test = Process.GetProcessesByName(&lt;span style="color:#e6db74">&amp;#34;notepad&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明一个查询flags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用Win32API来捕获进程快照&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssCaptureSnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.SafeHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">out&lt;/span> HPSS snapshotHandle);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 声明查询进程基本信息的变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_PROCESS_INFORMATION info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 涉及到指针操作，所以要用unsafe块包装&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用Win32API来查询进程快照信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssQuerySnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;amp;info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">uint&lt;/span>)&lt;span style="color:#66d9ef">sizeof&lt;/span>(PSS_PROCESS_INFORMATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(info.ProcessId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3.png"
width="829"
height="166"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3_hu5150e39f0ad4eac2ea149b7e9a8aa569_26787_480x0_resize_box_3.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/3_hu5150e39f0ad4eac2ea149b7e9a8aa569_26787_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="运行结果"
class="gallery-image"
data-flex-grow="499"
data-flex-basis="1198px"
>&lt;/p>
&lt;p>确实是获取到了记事本的PID&lt;/p>
&lt;p>而且观察代码，不难发现，CsWin32会非常智能地使用C#自带的类型&lt;br>
比如说Process类型里面的SafeHandle属性，这个返回的是&lt;code>SafeProcessHandle&lt;/code>&lt;br>
这个虽然它的命名空间是&lt;code>Microsoft.Win32.SafeHandles&lt;/code>，但确实是C#本身就有的&lt;br>
对于C#不带的类型，只有使用的API需要这些类型传参，CsWin32才会去生成对应的代码&lt;/p>
&lt;h2 id="0x02-一些不知道类型的枚举">&amp;lt;0x02&amp;gt; 一些不知道类型的枚举
&lt;/h2>&lt;p>如果你需要使用某个枚举，但不知道是什么类型，CsWin32可以自动指出具体类型&lt;br>
比如前面提到那两个API的返回值是&lt;code>winerror.h&lt;/code>中定义的错误代码，但我们不知道这是什么类&lt;br>
这时候可以在&lt;code>NativeMethods.txt&lt;/code>里面直接加上&lt;code>ERROR_SUCCESS&lt;/code>&lt;br>
CsWin32会抛出警告：应该使用正确的声明&lt;br>
&lt;img src="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2.png"
width="615"
height="24"
srcset="https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2_hu6e55902184b3a719cc4b872a240dead6_2562_480x0_resize_box_3.png 480w, https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/picture/2_hu6e55902184b3a719cc4b872a240dead6_2562_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="2562"
data-flex-basis="6150px"
>&lt;br>
最后也指出正确的声明是&lt;code>WIN32_ERROR&lt;/code>，文件里改好就行&lt;br>
这里对上面的代码稍作修改作为示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Diagnostics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.Foundation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Windows.Win32.System.Diagnostics.ProcessSnapshotting;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Process test = Process.GetProcessesByName(&lt;span style="color:#e6db74">&amp;#34;notepad&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PInvoke.PssCaptureSnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.SafeHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">out&lt;/span> HPSS snapshotHandle);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_PROCESS_INFORMATION info;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 添加错误码的声明&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint&lt;/span> errorCode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取错误码返回值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errorCode = PInvoke.PssQuerySnapshot(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> snapshotHandle,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;amp;info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">uint&lt;/span>)&lt;span style="color:#66d9ef">sizeof&lt;/span>(PSS_PROCESS_INFORMATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(info.ProcessId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 跟WIN32_ERROR.ERROR_SUCCESS做比较，返回True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine((WIN32_ERROR)errorCode == WIN32_ERROR.ERROR_SUCCESS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然头铁不改正确的声明也没关系，也是这样使用&lt;/p>
&lt;p>对于其他不知道怎么声明的枚举也可以这样让CsWin32去找&lt;/p></description></item><item><title>在Win10LTSC上安装截图与草图</title><link>https://mlacookie.github.io/article/posts/%E5%9C%A8win10ltsc%E4%B8%8A%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE%E4%B8%8E%E8%8D%89%E5%9B%BE/</link><pubDate>Sun, 03 Mar 2024 01:57:13 +0000</pubDate><guid>https://mlacookie.github.io/article/posts/%E5%9C%A8win10ltsc%E4%B8%8A%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE%E4%B8%8E%E8%8D%89%E5%9B%BE/</guid><description>&lt;p>众所周知，Win10的LTSC非常精简&lt;br>
精简到原本的&lt;code>截图与草图&lt;/code>的工具都没了&lt;br>
系统里只能截图，然后自动保存在剪贴板中&lt;/p>
&lt;p>但这不是很方便，比方说要保存到某个目录中，或者做些标记&lt;br>
所以还是挺需要原本的截图与草图工具的&lt;/p>
&lt;p>&lt;code>截图与草图&lt;/code>工具可以在微软的软件商店中下载到&lt;br>
但问题是，Win10LTSC也没有软件商店&lt;br>
这个可以靠配置&lt;code>winget&lt;/code>来解决&lt;br>
（这个的配置这里暂时不讲，网上的教程很多）&lt;/p>
&lt;p>如果需要安装&lt;code>截图与草图&lt;/code>，需要在命令行中输入下面的指令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>winget install &lt;span style="color:#e6db74">&amp;#34;Snipping Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回车等待就好了，安装完就能用了&lt;/p></description></item></channel></rss>