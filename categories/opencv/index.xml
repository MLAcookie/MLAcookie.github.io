<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OpenCV on MLAcookie</title><link>https://mlacookie.github.io/categories/opencv/</link><description>Recent content in OpenCV on MLAcookie</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 23 Jul 2024 12:23:45 +0800</lastBuildDate><atom:link href="https://mlacookie.github.io/categories/opencv/index.xml" rel="self" type="application/rss+xml"/><item><title>浙工大数字图像处理课设记录</title><link>https://mlacookie.github.io/article/categories/opencv/%E6%B5%99%E5%B7%A5%E5%A4%A7%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/</link><pubDate>Tue, 23 Jul 2024 12:23:45 +0800</pubDate><guid>https://mlacookie.github.io/article/categories/opencv/%E6%B5%99%E5%B7%A5%E5%A4%A7%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>数字图像处理我们主要是讲&lt;code>OpenCV&lt;/code>的（虽然实际上代码讲的不多）&lt;br>
然后作为期末的课程设计，要求我们写一个OpenCV的程序&lt;br>
主要就是用OpenCV去解决一些现实中的问题，然后要带图形界面&lt;br>
允许组队，而且在学期初就要定课设的题目&lt;/p>
&lt;h2 id="0x00-我们做了什么">&amp;lt;0x00&amp;gt; 我们做了什么
&lt;/h2>&lt;p>本来打算做一个用OpenCV做相机反求，Godot做渲染的AR项目&lt;br>
（所以前面有几篇研究怎么用C#做OpenCV开发）&lt;br>
引擎这块基本都搭完完了，然后估计了下感觉写不完了&lt;br>
（C#写OpenCV的代码参考太少了，很多代码都是试出来的，开发效率太低了）&lt;/p>
&lt;p>好在我们还有一个&lt;code>Plan B&lt;/code>，就是参考MIT的运动放大的论文去写一个应用&lt;br>
（主要是看了Steve Mould的&lt;a class="link" href="https://www.bilibili.com/video/BV1au411c7YJ/?spm_id_from=333.999.0.0" target="_blank" rel="noopener"
>视频&lt;/a>）&lt;br>
这样的话，语言也干脆换成了参考够多的Python，效率高了不少&lt;br>
问题也有，就是我们Python都不熟，但比起没代码参考好太多了&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/MLAcookie/EvmPlayground" target="_blank" rel="noopener"
>项目地址&lt;/a>&lt;/p>
&lt;h2 id="0x0-整体架构">&amp;lt;0x0&amp;gt; 整体架构
&lt;/h2>&lt;p>我们采用dearpygui来构建整个图形界面&lt;br>
使用numpy和scipy来做一些数据的处理&lt;/p>
&lt;h2 id="0x0-evm原理">&amp;lt;0x0&amp;gt; EVM原理
&lt;/h2>&lt;p>具体看&lt;a class="link" href="https://people.csail.mit.edu/mrub/evm/" target="_blank" rel="noopener"
>MIT EVM&lt;/a>的介绍，这里就只做大致的讲解&lt;/p>
&lt;h2 id="0x0-一些感想">&amp;lt;0x0&amp;gt; 一些感想
&lt;/h2>&lt;h3 id="关于知识">关于知识
&lt;/h3>&lt;p>首先就是确实感觉知道的东西多反而是一种诅咒&lt;br>
为什么这么说呢，知道的东西多了之后，遇到新的问题总是会用自己知道的知识解决&lt;br>
这道是正常的，毕竟这也是学习的目的&lt;br>
但问题是，当知道的东西多了之后，我总是觉得这个问题用已知知识是能解决的&lt;br>
然后就这样去开发，走一半，会发现这个项目按原计划开发会遇到非常多的问题&lt;br>
两个选择，要么花很多时间去解决，要么项目推倒重来重新设计架构&lt;br>
这两个选择都是痛苦的&lt;/p>
&lt;p>像这个课设，我就犯这样的错误&lt;br>
一开始我是打算用C#做Opencv开发，然后WPF做前端&lt;br>
因为Opencv在C#的实现我还是熟的，WPF我也是熟的&lt;br>
开发到后来发现，EVM需要用到傅里叶变换，Opencv中肯定是不带这种东西的&lt;br>
这时候其实可以考虑切换到python开发，但我并没有这么做，我选择来了花时间解决&lt;br>
然而，在我头铁写完了傅里叶变换的流程后，我发现整个算法的运行效率低得很&lt;br>
（中间的类型转换太多了，我对Mat类型了解也不够）&lt;br>
这时候又遇到一个抉择，推到重来换python还是花时间研究C#操作Mat类型&lt;br>
好在这次我选择了推到重来换python，最后完成开发&lt;/p>
&lt;p>这个问题其实说到底，还是知道的不够多，毕竟这种开发中的问题懂的多了之后，是可以在开发前预知到的&lt;br>
但还是有一个矛盾，对一块知识，究竟了解到什么程度才能算懂得够多，我不知道&lt;br>
学的东西多了，确实是能比别人看到更远的东西，但也比别人看到更少的东西&lt;br>
如果我是新手，这个项目我肯定就用python开发了，哪还要折腾C#啊&lt;br>
就是因为我了解C#，我才一开始用C#开发&lt;/p>
&lt;h3 id="关于团队">关于团队
&lt;/h3>&lt;p>这个课设虽然可以组队，但这个项目基本是我一个人完成的&lt;br>
那我的队友在干什么呢？他们在做别的可以组队的项目，并且是一人一个项目&lt;/p>
&lt;p>我发现，对于计算机的学生来说，可能最好的合作方式就是一人一个项目&lt;br>
程序开发不是人越多越快的&lt;br>
如果说有n个人，那么单位时间内代码量是$O(n)$，但沟通成本是$O(n^2)$&lt;br>
因为程序员开发软件需要的是连贯的思路，脑中需要保存所有代码的逻辑结构&lt;br>
对于别人写的代码，自己看是很花时间的，只有说问原来的开发者代码功能才是最快的&lt;br>
更何况程序有BUG，命名规范等等之类的增加沟通成本的问题&lt;br>
这方面可以看下《人月神话》这本书&lt;/p>
&lt;p>一个人一个项目，整个项目都在一个人的掌握之中，这样的效率是更高的&lt;br>
当然，这样的合作方式不是适合所有队伍的&lt;br>
你需要确保你的队友没有摆子，并且队每个人都可以分到适合其水平的项目&lt;br>
最重要的，足够的信任，在队友没请求帮助前就尽量不插手队友的工作&lt;br>
否则还是正常合作吧，这样起码可以保证项目可以写完&lt;/p>
&lt;h3 id="关于python">关于python
&lt;/h3>&lt;p>最后这个课设用python完成的&lt;br>
我在这个课设之前，可以说我是看不起python的&lt;br>
总觉得这个语言效率低，语法过于抽象&lt;/p>
&lt;p>虽然我看习惯了传统的C系代码，看python这种靠tab分隔层次的语言确实需要时间适应&lt;br>
但挺过阵痛期后，我发现python还挺好用
整个语言的设计完全是为解决问题去的&lt;br>
通过丰富的包，让很多问题几行代码就搞定了&lt;/p>
&lt;p>不过还是有一些小问题的，但这也不是python的问题，应该说是弱类型语言的问题&lt;br>
因为弱类型，导致很多问题不能在编译期查出&lt;br>
虽然是可以给变量打注解，但问题也是编译期不检查这个&lt;br>
所有实际开发中经常出现传参类型出问题，排查好一会儿&lt;/p>
&lt;p>总之，python这门语言感觉就像是共享单车，解决的是程序最后怎么运行的问题&lt;br>
当脚本语言是非常合适的&lt;/p>
&lt;p>所以说，没有最好的语言，只有最适合的语言&lt;/p></description></item><item><title>关于我用C#写Opencv这件事-03</title><link>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-03/</link><pubDate>Mon, 18 Mar 2024 12:59:53 +0000</pubDate><guid>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-03/</guid><description>&lt;p>（说实话我有点后悔用C#写Opencv了）
今天我们神秘的数字图像处理做实验了&lt;br>
虽然东西是挺简单的，但因为我用的是C#，导致很多现成的代码都没法抄&lt;br>
再加上虽然&lt;code>Opencvsharp4&lt;/code>宣称是和C++的API是对应的&lt;br>
但实际上的开发体验差别真挺大的，很多API的调用方法是不一样的&lt;br>
（有些调用像C++，有些调用有自己的特色）&lt;br>
基本上所有的代码都要自己去试，写着挺痛苦的&lt;br>
所以还是讲讲我们做了啥吧&lt;/p>
&lt;h2 id="0x00读取图像">&amp;lt;0x00&amp;gt;读取图像
&lt;/h2>&lt;p>这个其实是简单的&lt;br>
假设需要读取一个图片，比方说是&lt;code>D:/Test/1.png&lt;/code>&lt;br>
通过Cv2.ImRead()方法就可以读取为内置的矩阵类型了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法可以读取一般常见的图片格式&lt;/p>
&lt;p>然后，这个方法还可以传入第二个参数，用来控制读取的行为&lt;br>
比方说我们希望获取的是图像的灰度图&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat grayImage = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>, ImreadModes.Grayscale);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ImreadModes&lt;/code>是一个枚举类型，有很多常用的读取行为&lt;br>
一般也就是这个&lt;code>ImreadModes.Grayscale&lt;/code>获取灰度图用的多&lt;br>
Cv2.ImRead()这个参数的默认值是&lt;code>ImreadModes.Color&lt;/code>，即默认读入带颜色的图像&lt;/p>
&lt;h2 id="0x01将有色图转换为灰度图">&amp;lt;0x01&amp;gt;将有色图转换为灰度图
&lt;/h2>&lt;p>前面提到，我们可以指定读取图片时保存为灰度图&lt;br>
那有没有别的在运行时从有色图转换为灰度图的方法呢？&lt;br>
肯定是有的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat grayImage = iamge.CvtColor(ColorConversionCodes.RGB2GRAY);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样也完成了转换&lt;/p>
&lt;p>还有一个等价的写法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat grayImage = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cv2.CvtColor(image, grayImage, ColorConversionCodes.RGB2GRAY);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样写也行&lt;/p>
&lt;p>&lt;code>CvtColor()&lt;/code>方法中，传入的&lt;code>ColorConversionCodes&lt;/code>也是个枚举类型&lt;br>
里面也有很多常用的转换方式，有什么&lt;code>RGB2BGR&lt;/code>之类的&lt;/p>
&lt;h2 id="0x02图像按位取反">&amp;lt;0x02&amp;gt;图像按位取反
&lt;/h2>&lt;p>这个在C#中的写法确实跟C++之类的挺像的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat inversedImage = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cv2.BitwiseNot(image, inversedImage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然也可以自己写对每个位的操作，但这样就太麻烦了&lt;/p>
&lt;h2 id="0x03图像对比度增强">&amp;lt;0x03&amp;gt;图像对比度增强
&lt;/h2>&lt;p>关于图像对比度增强的办法有很多，我这里用的是&lt;code>限制对比度自适应直方图均衡化&lt;/code>的办法&lt;br>
（原理我也说不出来，没细学，还是看别的大佬的文章吧）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat enhancedImage = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CLAHE clahe = Cv2.CreateCLAHE(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#66d9ef">new&lt;/span> OpenCvSharp.Size(&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clahe.Apply(image, enhancedImage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个参数表示像素出现的阈值，应该是百分比阈值，默认是40&lt;br>
第二个参数表示重新分配的大小&lt;/p>
&lt;p>&lt;code>限制对比度自适应直方图均衡化&lt;/code>的大体过程如下&lt;br>
首先会统计每种像素的出现次数&lt;br>
然后跟设置的阈值对比，如果超过阈值，会把多余的像素按设定的大小重新分配给别的类型的像素&lt;br>
总之确实是能增强对比度（真说不大明白）&lt;/p>
&lt;h2 id="0x04图像二值化">&amp;lt;0x04&amp;gt;图像二值化
&lt;/h2>&lt;p>所谓二值化算是极端化的灰度图，只有黑白两种颜色&lt;br>
代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat binarizedImage = image.Threshold(&lt;span style="color:#ae81ff">127&lt;/span>, &lt;span style="color:#ae81ff">255&lt;/span>, ThresholdTypes.Binary);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也有稍微麻烦点的写法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat binarizedImage = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cv2.Threshold(image, binarizedImage, &lt;span style="color:#ae81ff">127&lt;/span>, &lt;span style="color:#ae81ff">255&lt;/span>, ThresholdTypes.Binary);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Threshold()&lt;/code>第一个数字是阈值，第二个值算是默认值，具体行为看第三个参数&lt;br>
&lt;code>ThresholdTypes&lt;/code>是一个枚举类型，表示如何处理图像&lt;br>
二值化的时候这个值取&lt;code>ThresholdTypes.Binary&lt;/code>，表示像素值大于阈值时用默认值，否则赋值0&lt;br>
比方说在二值化的时候，某像素值为128&amp;gt;127，那么就会把它的值变为255&lt;br>
其他的行为这里就不展开了&lt;/p>
&lt;h2 id="0x05图片相加">&amp;lt;0x05&amp;gt;图片相加
&lt;/h2>&lt;h3 id="同大小图片相加">同大小图片相加
&lt;/h3>&lt;p>这个其实很简单，毕竟在Opencv眼里，所有的图片都是矩阵，相加不是很简单嘛&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat A = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat B = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/2.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat addedImage = A + B;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（就这样写就可以了）&lt;/p>
&lt;p>不嫌烦的话还有下面的写法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat addedImage = A.Add(B);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat addedImage = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cv2.Add(A, B, addedImage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="不同大小的图片相加">不同大小的图片相加
&lt;/h3>&lt;p>这些&lt;code>Add()&lt;/code>方法要求矩阵大小一致，相当于要求图片大小一致&lt;/p>
&lt;p>那如果我们就是要不同大小图片相加，就要多做些处理&lt;br>
我的处理方式是&lt;br>
先在比较大的图片中扣出跟小图片一样大小的部分&lt;br>
抠出的图和小图片相加，然后再替换掉大图片扣掉的部分&lt;/p>
&lt;h4 id="怎么抠出图像">怎么抠出图像
&lt;/h4>&lt;p>&lt;code>Opencvsharp4&lt;/code>中有个&lt;code>Rect&lt;/code>类型，可以用来划出需要的部分&lt;br>
类型声明示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Rect rect = &lt;span style="color:#66d9ef">new&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面表示起始位置，也即矩形的左上角的点坐标，后面两个参数表示矩形大小&lt;/p>
&lt;p>对于一个图像，假设我们需要在图像&lt;code>(100, 100)&lt;/code>的地方扣出&lt;code>200*200&lt;/code>大小的图片&lt;br>
代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat image = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat temp = image[&lt;span style="color:#66d9ef">new&lt;/span> Rect(&lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>)];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要注意的是，这里的&lt;code>temp&lt;/code>获取到的是&lt;code>image&lt;/code>对应区域的引用&lt;br>
对&lt;code>temp&lt;/code>的所有修改也会反应到&lt;code>image&lt;/code>上&lt;br>
如果需要新建一个矩阵，需要用&lt;code>CopyTo()&lt;/code>方法&lt;/p>
&lt;h4 id="完整的代码">完整的代码
&lt;/h4>&lt;p>有了上面的基础，现在给出完整的图片相加代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>Mat L = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/1.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat S = Cv2.ImRead(&lt;span style="color:#e6db74">&amp;#34;D:/Test/2.png&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//还需要注意框选的区域不能超过大图片的范围&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mat temp = image[&lt;span style="color:#66d9ef">new&lt;/span> Rect(&lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, S.Width, S.Height)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>temp = temp + s;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就可以了，至于图片相减也是差不多这样的代码&lt;/p></description></item><item><title>关于我用C#写Opencv这件事-02</title><link>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-02/</link><pubDate>Sun, 17 Mar 2024 02:19:35 +0000</pubDate><guid>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-02/</guid><description>&lt;p>这次来讲讲怎么在Godot中使用Opencv&lt;/p>
&lt;p>大体还是很简单的，因为Godot项目中是可以使用Nuget的
（Godot的C#后端比较新）
所以直接在项目中引用Opencvsharp4的包就好了
而且大体上的代码也是不变的
基本就是多一步转换成&lt;code>ImageTexture&lt;/code>就可以&lt;/p>
&lt;p>还是以捕获摄像头为例
首先需要一个&lt;code>Sprite2D&lt;/code>节点
创建一个脚本与之绑定
然后脚本代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Godot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> OpenCvSharp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">partial&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CameraBehavior&lt;/span> : Sprite2D
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">readonly&lt;/span> VideoCapture camera;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">readonly&lt;/span> Mat frame = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>   
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> _Ready()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>     camera = &lt;span style="color:#66d9ef">new&lt;/span> VideoCapture(index, captureAPI);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> _Process(&lt;span style="color:#66d9ef">double&lt;/span> delta)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>     &lt;span style="color:#75715e">//用_Process()代替了原来的while循环&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>     camera.Read(frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#66d9ef">if&lt;/span> (frame.Empty())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            Debug.WriteLine(&lt;span style="color:#e6db74">&amp;#34;No Image&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        &lt;span style="color:#66d9ef">var&lt;/span> bytes = frame.ToBytes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        Image img = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        img.LoadPngFromBuffer(bytes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        Texture = ImageTexture.CreateFromImage(img);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，与之绑定的&lt;code>Sprite2D&lt;/code>就可以显示摄像头捕获的画面了&lt;/p>
&lt;p>然后调整下摄像头捕获画面的大小和&lt;code>Sprite2D&lt;/code>的位置&lt;/p>
&lt;p>Opencv中别的处理也可以用类似的方式实现
这样就相当于Godot负责前端的显示渲染，C#代码部分负责后端的逻辑算法处理&lt;/p>
&lt;p>（这篇写得比较水，下一篇来个大的）&lt;/p></description></item><item><title>关于我用C#写Opencv这件事-01</title><link>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-01/</link><pubDate>Wed, 13 Mar 2024 21:51:11 +0000</pubDate><guid>https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-01/</guid><description>&lt;h2 id="怎么突然要用opencv了">怎么突然要用Opencv了
&lt;/h2>&lt;p>我们有一门神秘课程，课设要写一个Opencv的应用
我是不知道我们臭做游戏的学这个有啥用&lt;/p>
&lt;p>总之我要整这么一个Opencv的应用
最后我打算做一个基于Opencv的AR应用
（这样还算跟我的专业有点联系）&lt;/p>
&lt;h2 id="大致的架构">大致的架构
&lt;/h2>&lt;p>语言的话当然是我心爱的C#
然后配合Godot来渲染&lt;/p>
&lt;p>这样的好处就是语言是我熟悉的，大致的运行模型是有的
然后拜.net不断进化所赐，跨平台也好做
Godot本身也是跨平台的，到时候也能移植到安卓上
（虽然跨平台算是个添头）&lt;/p>
&lt;h2 id="怎么用c写opencv">怎么用C#写Opencv
&lt;/h2>&lt;p>现在大致的架构有了，怎么用C#做Opencv开发呢
这就要用到些Nuget包了&lt;/p>
&lt;p>在.net中做这种开发，需要用到&lt;code>opencvsharp4&lt;/code>这个包
（或者说用EmguCV包，这个我没用过）&lt;/p>
&lt;p>需要注意的是，opencvsharp4这个包貌似不同版本的api不一样
（怎么跟之前的SharpPcap一样）
所以这里包括之后的代码不一定能在之后和之前的版本运行，就当个参考吧
我这用的版本是&lt;code>4.9.0&lt;/code>&lt;/p>
&lt;p>这个包本质上就是原本的Opencv在C++的库做了封装
自己用在工程上还是要自己做一些封装的
虽然确实还是能照C++代码写出C#的代码
但会非常痛苦，会遇到包括但不限于名称对不上、神秘类型的问题&lt;/p>
&lt;h2 id="如何捕获摄像头画面">如何捕获摄像头画面
&lt;/h2>&lt;p>作为系列的第一篇博客，也讲讲我写的第一段关于Opencv的代码吧
Opencv中包含了一些捕获摄像头的功能，
这样就不需要别的库来做这个了&lt;/p>
&lt;p>先贴出代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> OpenCvSharp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> OpenCVTest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 视频捕获设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> VideoCapture camera = &lt;span style="color:#66d9ef">new&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 捕获的帧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> Mat frame = &lt;span style="color:#66d9ef">new&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置休眠时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sleepTime = (&lt;span style="color:#66d9ef">int&lt;/span>)Math.Round(&lt;span style="color:#ae81ff">1000&lt;/span> / capture.Fps);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> camera.Read(frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(frame.Empty())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 显示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cv2.imshow(&lt;span style="color:#e6db74">&amp;#34;Test&amp;#34;&lt;/span> , frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cv2.WaitKey(sleepTime);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就完成了摄像头画面的捕获，其实还是挺简单的&lt;/p>
&lt;p>下面稍微解释下代码
&lt;code>VideoCapture&lt;/code>类是Opencv库自带的视频捕获类型
它的构造函数里可以输入两个参数，第一个是捕获的设备标号，表示用哪个摄像头
第二个是捕获用的API，默认参数是Any，基本上不用动&lt;/p>
&lt;p>&lt;code>Mat&lt;/code>在Opencv中代表矩阵，具体的数据是交给C++的库处理的
Opencv中的几乎所有操作都是对矩阵的操作
关于&lt;code>Mat&lt;/code>还有很多能说的，但这里说就要展开太多了，之后讲到再提&lt;/p>
&lt;p>下面的&lt;code>Cv2.imshow()&lt;/code>就是一个通用的显示方法，可以显示图片之类的
&lt;code>Cv2.WaitKey()&lt;/code>表示等待的时间&lt;/p></description></item></channel></rss>