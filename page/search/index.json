[{"content":"\u0026lt;0x00\u0026gt; 今日题目：A-B 数对\r洛谷的P1102\n题目背景\r出题是一件痛苦的事情！ 相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！\n题目描述\r给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。\n输入格式\r输入共两行。 第一行，两个正整数 $N,C$。 第二行，$N$ 个正整数，作为要求处理的那串数。\n输出格式\r一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。\n样例 #1\r样例输入 #1\r4 1 1 1 2 3 样例输出 #1\r3 数据规模与约定\r对于 $75%$ 的数据，$1 \\leq N \\leq 2000$。 对于 $100%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i \u0026lt;2^{30}$，$1 \\leq C \u0026lt; 2^{30}$。 2017/4/29 新添数据两组\n\u0026lt;0x01\u0026gt; 分析\r我的思路有点抽象，这道题是在二分的题单里的\n因为对于已知B的情况，则A=B+C，这个A是固定的\n本来我是打算对输入数列排序，然后求连续的B有几个\n通过二分求出A的位置上下界，然后上下界相减求出A有几个\n两个数字相乘加入到总的结果中，如此反复，最后求出答案\n然后我就想，既然这样，为什么不在输入时维护一个数组，保存某数有几个\n这种数据结构更进一步不就是哈希表嘛\n于是这个题就很简单了\n通过哈希表，建立键值对(数, 数的个数)\n然后就是每个B计算A=B+C，两个数的个数相乘即可\n唯一的坏处是没练习怎么写二分\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; int main() { // 读入 int n; size_t c; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; std::map\u0026lt;size_t, int\u0026gt; numInfo; // 处理 for (int i = 0; i \u0026lt; n; i++) { int t; std::cin \u0026gt;\u0026gt; t; numInfo[t]++; } // 解题 size_t ans = 0; for (auto \u0026amp;it : numInfo) { size_t temp = c + it.first; if (numInfo.find(temp) != numInfo.end()) { // 强转保平安 ans += (size_t)numInfo[temp] * (size_t)it.second; } } std::cout \u0026lt;\u0026lt; ans; } \u0026lt;0x03\u0026gt; 遇到的坑\r又是经典答案爆int范围了，但这里是在最后的乘法\n两个int相乘返回的也是int，如果乘出来的值超过范围，也是会爆的\n所以int强转size_t解决\n","date":"2024-07-21T22:27:25+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%92-03/","title":"算法康复计划 03"},{"content":"今天有人找我解决一些软件相关的问题，然后发现会牵扯到一些Win32的API\n一般调用Win32API都是用C++方便的，而且微软给的文档也是C++的\n我虽然对C++不是很熟，但对C#熟啊\n在C#中，我们可以通过P/Invoke去做动态库的互操作\n但对于Win32API，如果自己写P/Invoke，里面就有很多不确定的东西\n光是那个DllImport特性里面的参数就不是很好填\n那C#开发者是不是很难做Win32开发呢，那也不是\n在Nuget上有很多别的大佬包装好的Win32库，安装完可以直接调用\n但Win32中有超级多的API，这会导致代码提示里面会多出非常多东西，确实是有点干扰了\n但好在微软也提供了一个解决方案，CsWin32\n这个是基于C#源生成器的Win32API封装器\n就是需要什么API，它就去生成那些API的P/Invoke代码\n并且生成的质量还挺高的，尽可能去迎合C#的开发体验\n\u0026lt;0x00\u0026gt; 安装CsWin32\r因为会用到C#的源生成器，所以最好使用VS2022并且相对新的版本，不然代码提示之类的会出问题\nVSCode的源生成器体验也是不错的，这个直接装C# kit插件就可以了\n直接在Nuget中搜索CsWin32，包名是Microsoft.Windows.CsWin32\n这个包最低支持到.net framework 4.5也即.NET Standard 2.0\n对于这个版本，还需要安装System.Memory\n如果是.NET Standard 2.1及以上，也即.net 5.0及以上的版本，那么就不需要安装\n（如果是新项目的话应该会用新版本的框架吧）\n\u0026lt;0x01\u0026gt; 如何使用\r添加需要的API\r首先是要告诉源生成器要生成哪些API的封装\n在项目跟目录新建叫NativeMethods.txt的文件\n在里面可以添加你需要添加的Win32函数或者结构的名字\nPssCaptureSnapshot PssQuerySnapshot PSS_PROCESS_INFORMATION PSS_HANDLE_INFORMATION PSS_VA_CLONE_INFORMATION 这里的示例是Windows进程快照相关的API，使用的API也不多，仅做演示作用\n简单解释下使用的API\rPssCaptureSnapshot\r捕获目标进程的快照\nDWORD PssCaptureSnapshot( [in] HANDLE ProcessHandle, [in] PSS_CAPTURE_FLAGS CaptureFlags, [in, optional] DWORD ThreadContextFlags, [out] HPSS *SnapshotHandle ); ProcessHandle目标进程的句柄\nCaptureFlags指定要捕获的标志\nThreadContextFlags如果 CaptureFlags 指定线程上下文，则要捕获的 CONTEXT 记录标志\nSnapshotHandle返回此函数捕获的快照的句柄\n函数返回的是winerror.h中定义的错误代码，无错误是ERROR_SUCCESS\nPssQuerySnapshot\r查询捕获的快照的信息\nDWORD PssQuerySnapshot( [in] HPSS SnapshotHandle, [in] PSS_QUERY_INFORMATION_CLASS InformationClass, [out] void *Buffer, [in] DWORD BufferLength ); SnapshotHandle要查询的快照的句柄 InformationClass用于选择要查询的信息 Buffer此函数提供的信息，类型由InformationClass决定 BufferLength缓冲区的大小（以字节为单位）\n函数返回的是winerror.h中定义的错误代码，无错误是ERROR_SUCCESS\n剩下的是一些结构，东西多就不细讲了，跟本文关系不大，具体就看文档吧\n在代码中使用Win32API\r这里做一个使用Win32API查询进程PID的示例\n（虽然C#的Process类对象本身就可以直接查询）\nusing System.Diagnostics; using Windows.Win32; using Windows.Win32.System.Diagnostics.ProcessSnapshotting; public class Program { public static void Main() { // 使用C#自带的Process类型获取记事本进程 Process test = Process.GetProcessesByName(\u0026#34;notepad\u0026#34;)[0]; // 声明一个查询flags PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS; // 使用Win32API来捕获进程快照 PInvoke.PssCaptureSnapshot( test.SafeHandle, flags, 0, out HPSS snapshotHandle); // 声明查询进程基本信息的变量 PSS_PROCESS_INFORMATION info; // 涉及到指针操作，所以要用unsafe块包装 unsafe { // 使用Win32API来查询进程快照信息 PInvoke.PssQuerySnapshot( snapshotHandle, PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION, \u0026amp;info, (uint)sizeof(PSS_PROCESS_INFORMATION)); } Console.WriteLine(info.ProcessId); } } 确实是获取到了记事本的PID\n而且观察代码，不难发现，CsWin32会非常智能地使用C#自带的类型\n比如说Process类型里面的SafeHandle属性，这个返回的是SafeProcessHandle\n这个虽然它的命名空间是Microsoft.Win32.SafeHandles，但确实是C#本身就有的\n对于C#不带的类型，并且使用的API需要这些类型，CsWin32才会去生成对应的代码\n\u0026lt;0x02\u0026gt; 一些不知道类型的枚举\r如果你需要使用某个枚举，但不知道是什么类型，CsWin32可以自动指出具体类型\n比如前面提到那两个API的返回值是winerror.h中定义的错误代码，但我们不知道这是什么类\n这时候可以在NativeMethods.txt里面直接加上ERROR_SUCCESS\nCsWin32会抛出警告：应该使用正确的声明\n最后也指出正确的声明是WIN32_ERROR，文件里改好就行\n这里对上面的代码稍作修改作为示例\nusing System.Diagnostics; using Windows.Win32; using Windows.Win32.Foundation; using Windows.Win32.System.Diagnostics.ProcessSnapshotting; public class Program { public static void Main() { Process test = Process.GetProcessesByName(\u0026#34;notepad\u0026#34;)[0]; PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS; PInvoke.PssCaptureSnapshot( test.SafeHandle, flags, 0, out HPSS snapshotHandle); PSS_PROCESS_INFORMATION info; // 添加错误码的声明 uint errorCode; unsafe { // 获取错误码返回值 errorCode = PInvoke.PssQuerySnapshot( snapshotHandle, PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION, \u0026amp;info, (uint)sizeof(PSS_PROCESS_INFORMATION)); } Console.WriteLine(info.ProcessId); // 跟WIN32_ERROR.ERROR_SUCCESS做比较，返回True Console.WriteLine((WIN32_ERROR)errorCode == WIN32_ERROR.ERROR_SUCCESS); } } 当然头铁不改正确的声明也没关系，也是这样使用\n对于其他不知道怎么声明的枚举也可以这样让CsWin32去找\n","date":"2024-07-21T21:08:14+08:00","permalink":"https://mlacookie.github.io/article/posts/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97c%23%E8%B0%83%E7%94%A8win32api/","title":"相对优雅得C#调用Win32API"},{"content":"刚开始几天打算先写点简单的\n\u0026lt;0x00\u0026gt; 今日题目：小A的糖果\r洛谷的P3817\n题目描述\r小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。 小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。\n输入格式\r输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。 第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。\n输出格式\r输出一行一个整数，代表最少要吃掉的糖果的数量。\n样例 #1\r样例输入 #1\r3 3 2 2 2 样例输出 #1\r1 样例 #2\r样例输入 #2\r6 1 1 6 1 2 0 4 样例输出 #2\r11 样例 #3\r样例输入 #3\r5 9 3 1 4 1 5 样例输出 #3\r0 提示\r样例输入输出 1 解释\r吃掉第 2 盒中的一个糖果即可。\n样例输入输出 2 解释\r第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。\n数据规模与约定\r对于 $30%$ 的数据，保证 $n \\leq 20$，$a_i, x \\leq 100$。 对于 $70%$ 的数据，保证 $n \\leq 10^3$，$a_i, x \\leq 10^5$。 对于 $100%$ 的数据，保证 $2 \\leq n \\leq 10^5$，$0 \\leq a_i, x \\leq 10^9$。 \u0026lt;0x01\u0026gt; 分析\r这是来着贪心题单的题，那么就是用贪心算法\n怎么贪心呢\n因为每次考虑的都是相邻的两个盒子，而且要用贪心\n所以应该每次就只用考虑这两个盒子就可以了\n每次计算中，只有第二个盒子会参与下一次的计算\n既然是要算吃得最少的数目，那么应该要先吃第二个盒子的糖\n这样就可以保证每个相邻的盒子中的糖满足条件且吃的糖的数量是最少的\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入 int n; int x; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; std::vector\u0026lt;int\u0026gt; list; list.resize(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; list[i]; } // 解题 size_t ans = 0; for (int i = 0; i \u0026lt; n - 1; i++) { // 按前面分析的思路解题 int temp = list[i] + list[i + 1]; if (temp \u0026gt; x) { // 计算满足条件要吃几颗 int d = temp - x; ans += d; // 如果第二个盒子糖果不足 if (list[i + 1] \u0026lt; d) { list[i] -= d - list[i + 1]; list[i + 1] = 0; } // 否则就直接减去 else { list[i + 1] -= d; } } } std::cout \u0026lt;\u0026lt; ans; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r经典最后答案爆数值范围了\n最开始ans是int类型，然后提交上去发现有两个数据点过不了\n下载下来一看输出就明白了，答案超21亿了\n于是把int改成size_t这样就过了\n(size_t在64位系统中是unsigned long long)\n","date":"2024-07-21T10:43:29+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%92-02/","title":"算法康复计划 02"},{"content":"这两年，技术研究得越来越多，但算法基本是没学了\n让我本就不强的算法能力更是雪上加霜\n于是我就打算趁着暑假的时间，每天做一道算法题\n也不是为了比赛之类的，只是觉得现在确实缺算法方面的能力\n顺便也当练练C++了，我C++熟练度也不够\n需要写在前面的是，我的代码会有很多封装，这样性能肯定不是最佳的\n\u0026lt;0x00\u0026gt; 今日题目：马的遍历\r洛谷的P1443\n题目描述\r有一个 $n \\times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。\n输入格式\r输入只有一行四个整数，分别为 $n, m, x, y$。\n输出格式\r一个 $n \\times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。\n样例 #1\r样例输入 #1\r3 3 1 1 样例输出 #1\r0 3 2 3 -1 1 2 1 4 数据规模与约定\r对于全部的测试点，保证 $1 \\leq x \\leq n \\leq 400$，$1 \\leq y \\leq m \\leq 400$。\n\u0026lt;0x01\u0026gt; 分析\r这个题目是一道搜索相关的题目\n搜索的话，基本上就是DFS深度优先和BFS广度优先\n本题需要计算马到棋盘的每一格最少需要走几步\n使用DFS的话马容易一条路走到黑，虽然也是能解决问题的\n而选择BFS的话，相当于同时放出好几匹马，更快得出最少步数\n因为走不到的地方要标-1，所以地图初始化所有标记为-1\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; // 为了更好的可读性，这里封装了一个Map类型 class Map { int n; int m; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; mat; public: // 负责访问内容 int \u0026amp;At(int x, int y) { return mat[y][x]; } // 运算符重载 std::vector\u0026lt;int\u0026gt; \u0026amp;operator[](int index) { return mat[index]; } void ShowMap() { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { std::cout \u0026lt;\u0026lt; mat[j][i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } // 复制构造函数，防止C++整花活 Map(const Map \u0026amp;c) { n = c.n; m = c.m; mat.resize(m); for (int i = 0; i \u0026lt; m; i++) { mat[i].resize(n); for (int j = 0; j \u0026lt; n; j++) { mat[i][j] = c.mat[i][j]; } } } // 正常的构造函数 Map(int n, int m) { this-\u0026gt;n = n; this-\u0026gt;m = m; mat.resize(m); for (int i = 0; i \u0026lt; m; i++) { mat[i].resize(n); for (int j = 0; j \u0026lt; n; j++) { mat[i][j] = -1; } } } }; // BSF状态结构 class State { public: int px; int py; int step = 0; State(int px, int py, int step, Map map) { this-\u0026gt;px = px; this-\u0026gt;py = py; this-\u0026gt;step = step; } }; // 马的移动 int dx[] = {-1, 1, 2, 2, -1, 1, -2, -2}; int dy[] = {-2, -2, -1, 1, 2, 2, -1, 1}; // 地图大小 int MaxX = 0; int MaxY = 0; // 出界判断 bool IsOutBorder(int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0) { return true; } if (x \u0026gt;= MaxX || y \u0026gt;= MaxY) { return true; } return false; } // BFS函数 void BFS(Map map, int x, int y) { // 使用std库中的队列来处理 std::queue\u0026lt;State\u0026gt; q; // 初始化第一个状态 map.At(x, y) = 0; q.push(State(x, y, 0, map)); // 进入BFS循环 while (!q.empty()) { // 获取队列顶部对象 State temp = q.front(); q.pop(); // 生成下面可能的8个状态 for (int i = 0; i \u0026lt; 8; i++) { // 临时的位置 int tx = temp.px + dx[i]; int ty = temp.py + dy[i]; // 判断是否出界 if (IsOutBorder(tx, ty)) { continue; } // 判断这个位置是否有马走过 if (map.At(tx, ty) != -1) { continue; } int ts = temp.step + 1; // 向全局地图中添加标记 map.At(tx, ty) = ts; // 向队列中添加新的状态 q.push(State(tx, ty, ts, map)); } } // 最后，输出答案 map.ShowMap(); } // main入口，负责读取与启动 int main(int argc, char **argv) { int x, y; std::cin \u0026gt;\u0026gt; MaxX \u0026gt;\u0026gt; MaxY \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; BFS(Map(MaxX, MaxY), x - 1, y - 1); return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r主要也就是最后输出的时候矩阵反了\n因为题目给的样例最后答案也是沿对角线对称的，一开始还真没发现\n","date":"2024-07-20T23:05:43+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%92-01/","title":"算法康复计划 01"},{"content":"嘶，总算是学校的事情忙完了，终于有点时间写写博客了\n这个学期感觉一直都在和时间赛跑，没啥时间写博客，自己的项目也基本都断了\n当然这些都是另外的话题了\n如果之前有看过我博客的人，应该会发现现在网页大变样了\n现在博客的框架从Hexo换到了Hugo\n中间切换花了我很多时间，里面也有很多能说道说道的\n需要注意的是，我的部署方案跟官方的不一样，所以部分配置会和官方文档有所出入\n\u0026lt;0x00\u0026gt; 为什么要换框架\r简单来说，也算是我闲着没事干\n当然，之前Hexo的流程不是很舒服，写博客的话图片很不好引用\n然后的话主题也不是很好看（我没时间去改主题）\n然后正好想尝试下新东西，然后就看到了Hugo，于是就试了试\n尝试之后发现这个框架使用体验确实舒适很多，于是就打算换框架了\n换了框架后，好处主要有以下几点：\n文章的图片资源可以更好的管理 Obsidian更好的融合 舒适的预览体验 \u0026lt;0x01\u0026gt; 安装Hugo与新建站点\r安装Hugo\r以windows为例，其他系统只能自己看资料了 安装Hugo是很简单的\n如果有安装scoop的话，可以直接敲命令安装\nscoop install hugo-extended 这里安装的是带扩展的版本，因为我使用的主题需要这个\n如果有安装winget，也可以直接敲命令安装\nwinget install Hugo.Hugo.Extended 如果上面两个包管理器都没安装，那么需要从Release中下载预构建的版本\n找到带windows的压缩包下载，里面会有一个hugo.exe\n然后丢到什么路径，添加到windows环境变量里面，这样就可以在命令行中调用了\n新建Hugo站点\r完成安装后，尝试新建站点来测试是否安装成功\n在希望存放站点内容的位置打开终端\nhugo new site TestBlog 这样会在这个位置创建叫TestBlog的文件夹，里面会包含hugo站点的结构\n以上就完成了Hugo站点的搭建\n\u0026lt;0x02\u0026gt; 配置Stack主题\r这里使用的主题是Stack，简洁好看\n路径约定\r./表示存放所有Hugo站点的路径\n所以./TestBlog就是存放TestBlog站点的路径\n本文后面所有的路径都将按此表示\n安装Stack主题\r./TestBlog/themes是存放所有主题的路径\n在此打开终端\ngit clone https://github.com/CaiJimmy/hugo-theme-stack.git 克隆主题仓库\n然后回到./TestBlog，里面有个hugo.toml\n将theme的值修改为'hugo-theme-stack'\n配置头像\r进入./TestBlog/themes/hugo-theme-stack\n这里是Stack主题的文件\n我们需要修改的头像在./TestBlog/themes/hugo-theme-stack/assets/img中\n那个avatar.png便是我们我修改的图像\n找自己的头像拖进去然后改名就可以了\n配置网站图标\r配置网站图标稍微麻烦点\n首先进入./TestBlog/themes/hugo-theme-stack\n创建叫static的文件夹，里面放入网站图标，这里取名favicon.webp\n然后回到./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n找到favicon，将值改为favicon.webp，也就是网站图标的文件名\n配置社交媒体菜单\r（指的是这个东西）\n在./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n在文件最后添加这些东西\nmenu: main: [] social: - identifier: github name: 起个名吧 url: GitHub链接 params: icon: brand-github - identifier: bilibili name: 起个名吧 url: bilibili链接 params: icon: brand-bilibili 但仅仅这样是不行的，如果构建网页会说没有brand-bilibili.svg\n所以我们需要添加这个svg\n进入./TestBlog/themes/hugo-theme-stack/assets/icons，里面是所有的图标文件\n新建一个文件，命名为brand-bilibili.svg，添加以下内容\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentcolor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili\u0026#34;\u0026gt; \u0026lt;path stroke=\u0026#34;none\u0026#34; d=\u0026#34;M0 0h24v24H0z\u0026#34; fill=\u0026#34;none\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M8 3l2 3\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M16 3l-2 3\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M9 13v-2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M15 11v2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; （从别人博客薅的）\n保存即可\n如果要添加其他网站图标也是这样\n\u0026lt;0x03\u0026gt; 文章路径与侧栏\rHugo的所有文章都是放在./TestBlog/content里面\nHugo支持页面包来对文章资源进行管理\n页面包就是按路径对文章进行打包，一个文章只能访问自己页面包内的内容\n这样就将每个文章独立开来，不像之前Hexo所有图片都在一个文件夹中\n（或许Hexo也有办法实现，但我不知道）\n修改默认文章目录\rStack主题默认指定./TestBlog/content/post为文章目录\n这里我改成了./TestBlog/content/article\n在./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n找到mainSections将值改为article即可\n侧栏部分\r这里的配置建议参考Stack主题给的exampleSite配置\n直接按page里面的结构配置即可\n文章路径参考\r我这的文章路径是这样的\ncontent ├── article | ├── posts | | ├── 随便起的文章名字 | | | ├── picture | | | | └── 1.png | | | └── index.md | | ├── ... | | └── ... | └── categories | ├── Blog | | ├── 随便起的文章名字 | | | ├── picture | | | | └── 1.png | | | └── index.md | | ├── ... | | └── ... | ├── ... | └── ... └── page ├── about | └── index.md ├── archives | └── index.md ├── links | └── index.md └── search └── index.md \u0026lt;0x04\u0026gt; obsidian配置\r用obsidian在./TestBlog/content创建仓库\nobsidian里面需要配置的东西不多，主要是把链接设置为相对文件的路径\n这样配置就可以了\n由于使用页面包进行管理，所以所有的文章文件名都是index.md\n这个会导致obsidian节点视图之类的功能显示的都是index，我目前没有很好的办法\n\u0026lt;0x05\u0026gt; 部署到Github Page上\r虽然官方文档有讲，但他们采用的是将整个站点push到github上\n然后采用Github Action来在上面构建网页\n这样的话如果Action脚本有误可能导致github page行为和本地测试不一样\n我打算本地构建，然后将构建好的网页push到github上面，这样逻辑跟Hexo那套差不多\n但Hugo没有这样的自动部署配置，所以要自己来\n大致流程是在./TestBlog/public中初始化git仓库\n添加远程git仓库\n拉取后提交所有更改\n如果需要切换分支的话再切换分支\n之后只要构建后提交更改并上传即可\n具体命令参考下面的自动化脚本\n\u0026lt;0x06\u0026gt; 通过PowerShell实现自动化\r因为是在windows平台，所以这里采用PowerShell来实现一些自动化\n统一变量配置\r因为会有好几个脚本，所以需要一个统一的变量配置\n# configs.ps1 # 获取脚本文件夹路径 $global:ShellScriptDir = Get-Location # 主目录 $global:SiteDir = \u0026#34;[...]\u0026#34; # 内容目录 $global:ContentDir = Join-Path -Path $global:SiteDir -ChildPath \u0026#34;content\u0026#34; # 文章目录 $global:ArticleDir = Join-Path -Path $global:ContentDir -ChildPath \u0026#34;article\u0026#34; # 一般文章目录 $global:PostsDir = Join-Path -Path $global:ArticleDir -ChildPath \u0026#34;posts\u0026#34; # 分类文章目录 $global:CategoriesDir = Join-Path -Path $global:ArticleDir -ChildPath \u0026#34;categories\u0026#34; # 基础URL $global:BaseURL = \u0026#34;[...]\u0026#34; # 远程Git仓库链接 $global:RemoteGitURL = \u0026#34;[...]\u0026#34; # 目标分支 $global:TargetBranch = \u0026#34;[...]\u0026#34; # 编辑器路径 $global:EditorPath = \u0026#34;[...]\u0026#34; 创建文章\r因为希望每次创建文章都会自动创建对应的页面包，所以也需要一个脚本\n# NewPost.ps1 param( [string] [ValidateNotNullOrEmpty()] $PostName, [string] $CategoryName, [bool] $IsStartServer ) # 导入配置变量 . .\\configs.ps1 # 保存当前的工作路径 $localDir = Get-Location # 切换工作路径 Set-Location $global:SiteDir # 普通文章创建 if ($CategoryName -eq \u0026#34;\u0026#34;) { # 新建hexo博客 $newPost = Join-Path -Path (Join-Path -Path \u0026#34;content\\article\\posts\u0026#34; -ChildPath $PostName) -ChildPath \u0026#34;index.md\u0026#34; hugo new $newPost # 创建图片文件夹 $newPostPicture = Join-Path -Path (Join-Path -Path $global:PostsDir -ChildPath $PostName) -ChildPath \u0026#34;picture\u0026#34; mkdir $newPostPicture } # 需要分类的文章 else { # 新建hexo博客 $categoryPath = Join-Path -Path \u0026#34;content\\article\\categories\u0026#34; -ChildPath $CategoryName $newPost = Join-Path -Path (Join-Path -Path $categoryPath -ChildPath $PostName) -ChildPath \u0026#34;index.md\u0026#34; hugo new $newPost # 创建图片文件夹 $categoryPath = Join-Path -Path $global:CategoriesDir -ChildPath $CategoryName $newPostPicture = Join-Path -Path (Join-Path -Path $categoryPath -ChildPath $PostName) -ChildPath \u0026#34;picture\u0026#34; mkdir $newPostPicture } # 启动编辑器 # Start-Process $global:EditorPath # 是否开启服务器预览 if ($IsStartServer) { hugo server } # 返回之前的工作路径 Set-Location $localDir 使用示例\n# 创建一篇普通的文章 .\\NewPost.ps1 -PostName 从Hexo到Hugo-记录博客框架切换 # 创建一篇文章，并分类为Blog .\\NewPost.ps1 -PostName 从Hexo到Hugo-记录博客框架切换 -CategoryName Blog 运行后会创建对应的页面包\n发布\r这里涉及到两个文件，一个InitGit.ps1用来初始化git仓库，一个Deploy.ps1做推送\nInitGit.ps1如下\n# InitGit.ps1 param( [bool] $IsForcePush = $false ) # 导入配置变量 . .\\configs.ps1 # 保存当前的工作路径 $localDir = Get-Location # 切换工作路径 Set-Location (Join-Path -Path $global:SiteDir -ChildPath \u0026#34;public\u0026#34;) # 初始化git git init git remote add origin $global:RemoteGitURL git pull git add . git commit -m (\u0026#34;Init: \u0026#34; + (Get-Date -Format \u0026#34;yyMMdd-HH:mm\u0026#34;)) git branch -u $global:TargetBranch if ($IsForcePush) { git push origin HEAD:$global:TargetBranch --force } # 返回之前的工作路径 Set-Location $localDir Deploy.ps1如下\n# Deploy.ps1 param( [bool] $IsForcePush = $false ) # 导入配置变量 . .\\configs.ps1 # 保存当前的工作路径 $localDir = Get-Location # 切换工作路径 Set-Location $global:SiteDir # 构建网页 hugo --gc --minify --baseURL $global:BaseURL # 准备推送 Set-Location (Join-Path -Path $global:SiteDir -ChildPath \u0026#34;public\u0026#34;) if (-not (Test-Path \u0026#34;.git\u0026#34;)) { . (Join-Path -Path $global:ShellScriptDir -ChildPath \u0026#34;InitGit.ps1\u0026#34;) -IsForcePush $true } else { git add . git commit -m (\u0026#34;Deploy: \u0026#34; + (Get-Date -Format \u0026#34;yyMMdd-HH:mm\u0026#34;)) # 是否强制推送 if ($IsForcePush) { git push origin HEAD:$global:TargetBranch --force } else { git push origin HEAD:$global:TargetBranch } } # 返回之前的工作路径 Set-Location $localDir 使用示例\n.\\Deploy.ps1 运行即可推送到GitHub Page上\n批量创建页面包路径结构\r因为之前使用的是hexo，里面都是单独的markdown文件\n如果自己手动一个一个移动并创建picture文件夹那就太累了\n所以还是要写一个脚本完成自动化\n# TransFromSingleFile.ps1 param( [string] [ValidateNotNullOrEmpty()] $postDir ) # 排除文件名单 $excludeList = \u0026#34;_index\u0026#34; Get-ChildItem -Path $postDir -File | ForEach-Object { if ($_.BaseName -notin $excludeList) { # 创建文件夹并移动 $destDir = Join-Path -Path $postDir -ChildPath $_.BaseName New-Item -ItemType Directory -Force -Path $destDir Move-Item -Path $_.FullName -Destination (Join-Path -Path $destDir -ChildPath \u0026#34;index$($_.Extension)\u0026#34;) # 创建对应的picture文件夹 $newPostPicture = Join-Path -Path $destDir -ChildPath \u0026#34;picture\u0026#34; mkdir $newPostPicture } } 使用示例\n.\\TransFromSingleFile.ps1 [某个路径] 运行可以为路径内所有文件创建同名文件夹，并将文件移动至对应文件夹后重命名为index.md\n里面也会创建picture文件夹\n","date":"2024-07-20T15:02:34+08:00","permalink":"https://mlacookie.github.io/article/categories/blog/%E4%BB%8Ehexo%E5%88%B0hugo-%E8%AE%B0%E5%BD%95%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E5%88%87%E6%8D%A2/","title":"从Hexo到Hugo 记录博客框架切换"},{"content":"（说实话我有点后悔用C#写Opencv了） 今天我们神秘的数字图像处理做实验了\n虽然东西是挺简单的，但因为我用的是C#，导致很多现成的代码都没法抄\n再加上虽然Opencvsharp4宣称是和C++的API是对应的\n但实际上的开发体验差别真挺大的，很多API的调用方法是不一样的\n（有些调用像C++，有些调用有自己的特色）\n基本上所有的代码都要自己去试，写着挺痛苦的\n所以还是讲讲我们做了啥吧\n\u0026lt;0x00\u0026gt;读取图像\r这个其实是简单的\n假设需要读取一个图片，比方说是D:/Test/1.png\n通过Cv2.ImRead()方法就可以读取为内置的矩阵类型了\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); 这个方法可以读取一般常见的图片格式\n然后，这个方法还可以传入第二个参数，用来控制读取的行为\n比方说我们希望获取的是图像的灰度图\nMat grayImage = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;, ImreadModes.Grayscale); ImreadModes是一个枚举类型，有很多常用的读取行为\n一般也就是这个ImreadModes.Grayscale获取灰度图用的多\nCv2.ImRead()这个参数的默认值是ImreadModes.Color，即默认读入带颜色的图像\n\u0026lt;0x01\u0026gt;将有色图转换为灰度图\r前面提到，我们可以指定读取图片时保存为灰度图\n那有没有别的在运行时从有色图转换为灰度图的方法呢？\n肯定是有的\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat grayImage = iamge.CvtColor(ColorConversionCodes.RGB2GRAY); 这样也完成了转换\n还有一个等价的写法\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat grayImage = new(); Cv2.CvtColor(image, grayImage, ColorConversionCodes.RGB2GRAY); 这样写也行\nCvtColor()方法中，传入的ColorConversionCodes也是个枚举类型\n里面也有很多常用的转换方式，有什么RGB2BGR之类的\n\u0026lt;0x02\u0026gt;图像按位取反\r这个在C#中的写法确实跟C++之类的挺像的\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat inversedImage = new(); Cv2.BitwiseNot(image, inversedImage); 当然也可以自己写对每个位的操作，但这样就太麻烦了\n\u0026lt;0x03\u0026gt;图像对比度增强\r关于图像对比度增强的办法有很多，我这里用的是限制对比度自适应直方图均衡化的办法\n（原理我也说不出来，没细学，还是看别的大佬的文章吧）\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat enhancedImage = new(); CLAHE clahe = Cv2.CreateCLAHE(3, new OpenCvSharp.Size(8, 8)); clahe.Apply(image, enhancedImage); 第一个参数表示像素出现的阈值，应该是百分比阈值，默认是40\n第二个参数表示重新分配的大小\n限制对比度自适应直方图均衡化的大体过程如下\n首先会统计每种像素的出现次数\n然后跟设置的阈值对比，如果超过阈值，会把多余的像素按设定的大小重新分配给别的类型的像素\n总之确实是能增强对比度（真说不大明白）\n\u0026lt;0x04\u0026gt;图像二值化\r所谓二值化算是极端化的灰度图，只有黑白两种颜色\n代码如下\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat binarizedImage = image.Threshold(127, 255, ThresholdTypes.Binary); 也有稍微麻烦点的写法\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat binarizedImage = new(); Cv2.Threshold(image, binarizedImage, 127, 255, ThresholdTypes.Binary); Threshold()第一个数字是阈值，第二个值算是默认值，具体行为看第三个参数\nThresholdTypes是一个枚举类型，表示如何处理图像\n二值化的时候这个值取ThresholdTypes.Binary，表示像素值大于阈值时用默认值，否则赋值0\n比方说在二值化的时候，某像素值为128\u0026gt;127，那么就会把它的值变为255\n其他的行为这里就不展开了\n\u0026lt;0x05\u0026gt;图片相加\r同大小图片相加\r这个其实很简单，毕竟在Opencv眼里，所有的图片都是矩阵，相加不是很简单嘛\nMat A = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat B = Cv2.ImRead(\u0026#34;D:/Test/2.png\u0026#34;); Mat addedImage = A + B; （就这样写就可以了）\n不嫌烦的话还有下面的写法\nMat addedImage = A.Add(B); Mat addedImage = new(); Cv2.Add(A, B, addedImage); 不同大小的图片相加\r这些Add()方法要求矩阵大小一致，相当于要求图片大小一致\n那如果我们就是要不同大小图片相加，就要多做些处理\n我的处理方式是\n先在比较大的图片中扣出跟小图片一样大小的部分\n抠出的图和小图片相加，然后再替换掉大图片扣掉的部分\n怎么抠出图像\rOpencvsharp4中有个Rect类型，可以用来划出需要的部分\n类型声明示例\nRect rect = new(0, 0, 100, 100); 前面表示起始位置，也即矩形的左上角的点坐标，后面两个参数表示矩形大小\n对于一个图像，假设我们需要在图像(100, 100)的地方扣出200*200大小的图片\n代码如下\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat temp = image[new Rect(100, 100, 200, 200)]; 需要注意的是，这里的temp获取到的是image对应区域的引用\n对temp的所有修改也会反应到image上\n如果需要新建一个矩阵，需要用CopyTo()方法\n完整的代码\r有了上面的基础，现在给出完整的图片相加代码\nMat L = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat S = Cv2.ImRead(\u0026#34;D:/Test/2.png\u0026#34;); //还需要注意框选的区域不能超过大图片的范围 Mat temp = image[new Rect(100, 100, S.Width, S.Height)]; temp = temp + s; 这样就可以了，至于图片相减也是差不多这样的代码\n","date":"2024-03-18T12:59:53Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-03/","title":"关于我用C#写Opencv这件事-03"},{"content":"这次来讲讲怎么在Godot中使用Opencv\n大体还是很简单的，因为Godot项目中是可以使用Nuget的 （Godot的C#后端比较新） 所以直接在项目中引用Opencvsharp4的包就好了 而且大体上的代码也是不变的 基本就是多一步转换成ImageTexture就可以\n还是以捕获摄像头为例 首先需要一个Sprite2D节点 创建一个脚本与之绑定 然后脚本代码如下\nusing Godot; using OpenCvSharp; public partial class CameraBehavior : Sprite2D { readonly VideoCapture camera; readonly Mat frame = new(); public override void _Ready() { camera = new VideoCapture(index, captureAPI); } public override void _Process(double delta) { //用_Process()代替了原来的while循环 camera.Read(frame); if (frame.Empty()) { Debug.WriteLine(\u0026#34;No Image\u0026#34;); return null; } var bytes = frame.ToBytes(); Image img = new(); img.LoadPngFromBuffer(bytes); Texture = ImageTexture.CreateFromImage(img); } } 这样，与之绑定的Sprite2D就可以显示摄像头捕获的画面了\n然后调整下摄像头捕获画面的大小和Sprite2D的位置\nOpencv中别的处理也可以用类似的方式实现 这样就相当于Godot负责前端的显示渲染，C#代码部分负责后端的逻辑算法处理\n（这篇写得比较水，下一篇来个大的）\n","date":"2024-03-17T02:19:35Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-02/","title":"关于我用C#写Opencv这件事-02"},{"content":"怎么突然要用Opencv了\r我们有一门神秘课程，课设要写一个Opencv的应用 我是不知道我们臭做游戏的学这个有啥用\n总之我要整这么一个Opencv的应用 最后我打算做一个基于Opencv的AR应用 （这样还算跟我的专业有点联系）\n大致的架构\r语言的话当然是我心爱的C# 然后配合Godot来渲染\n这样的好处就是语言是我熟悉的，大致的运行模型是有的 然后拜.net不断进化所赐，跨平台也好做 Godot本身也是跨平台的，到时候也能移植到安卓上 （虽然跨平台算是个添头）\n怎么用C#写Opencv\r现在大致的架构有了，怎么用C#做Opencv开发呢 这就要用到些Nuget包了\n在.net中做这种开发，需要用到opencvsharp4这个包 （或者说用EmguCV包，这个我没用过）\n需要注意的是，opencvsharp4这个包貌似不同版本的api不一样 （怎么跟之前的SharpPcap一样） 所以这里包括之后的代码不一定能在之后和之前的版本运行，就当个参考吧 我这用的版本是4.9.0\n这个包本质上就是原本的Opencv在C++的库做了封装 自己用在工程上还是要自己做一些封装的 虽然确实还是能照C++代码写出C#的代码 但会非常痛苦，会遇到包括但不限于名称对不上、神秘类型的问题\n如何捕获摄像头画面\r作为系列的第一篇博客，也讲讲我写的第一段关于Opencv的代码吧 Opencv中包含了一些捕获摄像头的功能， 这样就不需要别的库来做这个了\n先贴出代码\nusing OpenCvSharp; namespace OpenCVTest; public class Program { // 视频捕获设备 static VideoCapture camera = new(0); // 捕获的帧 static Mat frame = new(); public static void Main() { // 设置休眠时间 int sleepTime = (int)Math.Round(1000 / capture.Fps); while(true) { camera.Read(frame); if(frame.Empty()) { break; } // 显示 Cv2.imshow(\u0026#34;Test\u0026#34; , frame); Cv2.WaitKey(sleepTime); } } } 这样就完成了摄像头画面的捕获，其实还是挺简单的\n下面稍微解释下代码 VideoCapture类是Opencv库自带的视频捕获类型 它的构造函数里可以输入两个参数，第一个是捕获的设备标号，表示用哪个摄像头 第二个是捕获用的API，默认参数是Any，基本上不用动\nMat在Opencv中代表矩阵，具体的数据是交给C++的库处理的 Opencv中的几乎所有操作都是对矩阵的操作 关于Mat还有很多能说的，但这里说就要展开太多了，之后讲到再提\n下面的Cv2.imshow()就是一个通用的显示方法，可以显示图片之类的 Cv2.WaitKey()表示等待的时间\n","date":"2024-03-13T21:51:11Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-01/","title":"关于我用C#写Opencv这件事-01"},{"content":"最近在写一个WPF项目，然后今天遇到个非常神秘的问题 就是界面的InitializeComponent()莫名奇妙报错找不到方法了 我仔细检查代码，也没发现问题 而且最抽象的是，程序也能正常运行 我用ILSpy去看编译后的文件，发现InitializeComponent()也是有的\n但报错看着总是不舒服啊，还是要解决 参考网上的说法，进入项目的文件夹 然后把obj文件夹删掉，再在vs里面重新生成一下就好了 据说是因为分布类的问题，实际编译时生成的代码是正确的 但是IntelliCode依赖的文件可能没更新上 然后就开始误报找不到InitializeComponent()\n总之还是一个很神秘的问题\n","date":"2024-03-07T01:10:14Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADinitializecomponent-%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/","title":"WPF开发过程中InitializeComponent()神秘报错"},{"content":"闲着没事想着优化一下hexo的博客配置 我原来一直都是用vscode写markdown的，至于体验嘛，能写但不是很舒适 所以我就尝试换成了现在在用的obsidian，体验就好多了\n然后就按网上的教程，尝试配置更加优雅的流程 然后发现原来用的hexo框架有点老了，就干脆重装了 没想到啊，重装个hexo又出了很多问题 所以这篇博客就从hexo的安装开始讲吧\n\u0026lt;0x00\u0026gt; hexo的安装\r（一般情况下跟着hexo官方教程没啥问题） 首先是要有Node.js环境，这个随意，最好是最新的版本 还要安装git，这个直接网上找安装包安装就好了\nnpm换源\rnpm原本的国内连接不畅，所以要换源 一般是换成国内的淘宝源\n一般敲命令方法\rnpm config set registry https://registry.npm.taobao.org 通过nrm切换\rnrm是npm的源管理器，可以在不同的源中切换 如果没有什么特殊上网方式访问原本的源的话还是建议先手动切换源 （nrm也是靠npm下载的）\n# -g参数表示全局安装，这样的话可以在任何目录中使用nrm npm install -g nrm nrm use taobao # 查看其它可以用的源 nrm ls # 测试源 nrm test 安装hexo\r首先是安装hexo环境\nnpm install -g hexo-cli 然后挑一个空的文件夹，初始化 （这里取名叫HexoBlog了）\nhexo init ./HexoBlog 然后原本空的文件夹里面会生成一些文件 安装hexo依赖\ncd ./HexoBlog npm install 这样之后，hexo就搭建好了 但貌似hexo的依赖文件写的版本可能比较老了，最好还是更新一下\nnpm update \u0026lt;0x01\u0026gt; 安装Anatolo主题\r别的主题就看具体的安装说明了，我这里还是用Anatolo了\n首先是在HexoBlog文件夹\ngit clone https://gitee.com/Lhcfl/hexo-theme-anatolo.git themes/Anatolo npm install hexo-renderer-pug --save npm install hexo-renderer-stylus --save 然后进入HexoBlog/themes/Anatolo中，复制_config.example.yml为_config.yml 这个_config.yml是Anatolo的配置文件 这里还需要多做一步，这一步在原本的安装文件中没有说\nnpm install 需要在Anatolo中再安装一次依赖，如果没有这一步的话运行时会报错找不到模块 我的猜想是我们在安装hexo依赖时没有全局安装，所以要在这里再安装一次 （或者所有的npm都-g全局安装也行，但这样对C盘不友好，尤其是像我并不是专门做Nodejs开发的人）\n然后回到HexoBlog，修改_config.yml中的theme: Anatolo 这样主题也安装好了\n\u0026lt;0x02\u0026gt; 优化Hexo配置\r部署到Github Page上\r这个网上的教程足够多了，这边不细讲 就是记得安装hexo-deployer-git插件就好 在HexoBlog中\nnpm install hexo-deployer-git --save 更方便的分文件管理\rhexo的默认所有的博客文章都存放在HexoBlog/source/_posts下面 虽然可以在里面用文件夹归类不同的文章，但需要给这些博客手动写上categories属性 这就很麻烦了，手写麻烦还容易出错\n可以安装一个插件，hexo-auto-category 它可以在hexo生成网页时自动给每个博客打上对应的categories属性\n在HexoBlog中\nnpm install hexo-auto-category --save 修改_config.yml，添加下面的语句\nauto_category: enable: true depth: 这样就安装好并启用了\n\u0026lt;0x03\u0026gt; 使用obsidian作为编辑器\robsidian确实香，比起原本的vscode好多了，毕竟是专门的markdown编辑器 但要在hexo中使用obsidian作为编辑器，还需要做一些小优化\n仓库的话，用obsidian打开HexoBlog/source/_posts就可以了\n图片问题\rhexo在生成时，图片需要在HexoBlog/source下面 但由于obsidian打开的目录在HexoBlog/source/_posts，所以会检索不到图片\n我的解决方案是在HexoBlog/source下面新建picture文件夹来专门存图片 然后在HexoBlog/source/_posts下面添加picture软连接，让obsidian可以检索到\n添加软连接的命令在powershell下和cmd下面有所不同，但都需要管理员权限\n# powershell New-Item -ItemType SymbolicLink -Path $放的地方 -Name $名字 -Target $连接的目标 # cmd mklink /d $软连接存放路径 $连接的目标 然后就是在obsidian中编辑时，引用图片的格式应是![](/picture/...) 最好把obsidian的文件与链接\u0026gt; \u0026gt; 自动添加wiki引用关了，[[]]格式的连接hexo本身解析不了 （貌似有插件在解决这个问题，但我没试成功过）\n\u0026lt;0x04\u0026gt; 使用脚本做自动化\rhexo的生成和部署都还是靠cli命令的 所以可以写一些脚本来做一些自动化 这里的脚本都是powershell脚本\n新建博客文章并编辑\r# (@24-03-07) 优化脚本，增加去除URL特殊字符 param( [string] [ValidateNotNullOrEmpty()] $Name ) function ValidatedName { param ( [string] [ValidateNotNullOrEmpty()] $Name ) $SpecialCharacters = [char[]]@( \u0026#34;` \u0026#34; \u0026#34;`!\u0026#34; \u0026#34;`\u0026#34;\u0026#34; \u0026#34;`#\u0026#34; \u0026#34;`$\u0026#34; \u0026#34;`%\u0026#34; \u0026#34;`\u0026amp;\u0026#34; \u0026#34;`\u0026#39;\u0026#34; \u0026#34;(\u0026#34; \u0026#34;)\u0026#34; \u0026#34;*\u0026#34; \u0026#34;+\u0026#34; \u0026#34;,\u0026#34; \u0026#34;-\u0026#34; \u0026#34;.\u0026#34; \u0026#34;/\u0026#34; \u0026#34;:\u0026#34; \u0026#34;;\u0026#34; \u0026#34;\u0026lt;\u0026#34; \u0026#34;=\u0026#34; \u0026#34;\u0026gt; \u0026#34; \u0026#34;?\u0026#34; \u0026#34;@\u0026#34; \u0026#34;[\u0026#34; \u0026#34;\\\u0026#34; \u0026#34;]\u0026#34; \u0026#34;^\u0026#34; \u0026#34;_\u0026#34; \u0026#34;``\u0026#34; \u0026#34;{\u0026#34; \u0026#34;|\u0026#34; \u0026#34;}\u0026#34; \u0026#34;~\u0026#34; ) # 先每个替换成- foreach ($Character in $SpecialCharacters) { $Name = $Name.Replace($Character, \u0026#34;-\u0026#34;) } # 返回时使用正则表达式匹配连续的-，并替换为单个- return $Name -Replace \u0026#39;([-])+\u0026#39;, \u0026#39;-\u0026#39; } # 指定Obsidian目录 $ObsidianPath = \u0026#34;C:\\Users\\cookie\\scoop\\apps\\obsidian\\current\\Obsidian.exe\u0026#34; # 新建hexo博客 hexo new $Name # 去除URL特殊字符 $Name=ValidatedName -Name $Name # 创建图片文件夹 mkdir ./source/picture/$Name # 启动Obsidian Start-Process $ObsidianPath -ArgumentList ./source/_posts # cls Clear-Host 本地化部署测试\rparam( [Int16] $Port ) # 清理hexo缓存 hexo clean # hexo生成 hexo g # 启动本地hexo服务器 if ($Port -eq $null) { hexo server } else{ hexo server -p $Port } \u0026lt;0x05\u0026gt; 安装过程中可能的问题\rhexo的有些依赖可能已经已放弃维护了 比如说hexo-renderer-sass，这个非常容易报错 （貌似删了不影响整体运行） 可以替换成hexo-renderer-sass-next，这个稳定很多\n\u0026lt;0x06\u0026gt; 这套方案的问题\r不支持Obsidian的wiki链接解析 也没用上Obsidian自带的模板功能 文章之间相互引用也很麻烦，要知道文章的具体URL\n","date":"2024-03-03T13:24:40Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E6%88%91%E7%9A%84hexo%E9%85%8D%E5%90%88obsidian%E7%9A%84%E9%85%8D%E7%BD%AE/","title":"我的hexo配合obsidian的配置"},{"content":"众所周知，Win10的LTSC非常精简 精简到原本的截图与草图的工具都没了 系统里只能截图，然后自动保存在剪贴板中\n但这不是很方便，比方说要保存到某个目录中，或者做些标记 所以还是挺需要原本的截图与草图工具的\n截图与草图工具可以在微软的软件商店中下载到 但问题是，Win10LTSC也没有软件商店 这个可以靠配置winget来解决 （这个的配置这里暂时不讲，网上的教程很多）\n如果需要安装截图与草图，需要在命令行中输入下面的指令\nwinget install \u0026#34;Snipping Tool\u0026#34; 回车等待就好了，安装完就能用了\n","date":"2024-03-03T01:57:13Z","permalink":"https://mlacookie.github.io/article/posts/%E5%9C%A8win10ltsc%E4%B8%8A%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE%E4%B8%8E%E8%8D%89%E5%9B%BE/","title":"在win10LTSC上安装截图与草图"},{"content":"新年了，时间真的好快\n转眼间博客站也开了快一年了\n在这一年中，分享了很多知识，也开了很多新坑\n（我超级写不完😂）\nWPF之后还是会写的，最起码把M9AWPF项目的经验讲完\n别的一些经验还是会分享的\n（就是更新得不会很勤快了）\n至于说为什么这段时间博客写的少了\n之前也有提到过，我最近都在写一些系统性的文档\n（C#入门，设计模式，现代C++等等）\n（从去年10月开始用语雀，写了6万多字）\n所以就没啥时间去写博客了\n这些系统性的文档暂时都是我们社团的独占内容\n（急着看可以直接加入我们社团看😄）\n但等到内容严谨完善时，我也会公开的\n其实真正的原因还是我整个人的想法在这一年里发生了很大的变化\n这个博客站是在我最迷茫的时候开的，不知道做什么，想着找点事情做\n所以三两天，从不会Linux到会点基础的命令，从没干过网页到磕磕碰碰建起网站\n再用几天时间，申请了域名，做了ICP备案（虽然现在因为没时间折腾撤销了）\n那几天，几乎到哪里都是握着ssh，在研究怎么搭，挺有意思的\n（我室友那时候也都在搭博客，然后吵了几天用哪个框架好）\n最后我选择了hexo，简单，能用markdown，能挂GithubPage\n（扯远了）\n总之，前面的文章也有提到，自从我们游戏社团成立后，我也算是找到了一个着力点\n我是真的想把社团发展壮大，让每个人不至于被编程的问题难到\n还有就是我们工地的车万群现在真的可以说是朝气蓬勃\n大家都很想做些车万的二创，那我自然也是很想的\n所以，原来还在钻研的WPF，现在在钻研Unity、Godot\n原来忙着写点博客，现在忙着写这些系统文档\n加上还要重新拾起一些因为中学学业而被迫放下的一些兴趣爱好\n所以是真的没啥时间写博客了\n不过，我还是会尽力的\n（实在不行就当QQ空间多发电了😊）\n说起这个，之前写了篇讲780m在Blender中不能用Cycles渲染器的博客\n于是有个网友顺着这个博客找到了我的B站号私信我，问我些问题\n我那时候真的又惊喜又激动，我一直以为我写的博客没人看的\n所以哪怕第二天要期末考，我也先帮忙把他的问题解决了\n真的，就是这种成就感，让我知道，我写的博客并不是毫无意义\n我为什么要写博客，是为了践行开源精神\n计算机的繁荣，离不开开源二字\n那些愿意把知识分享给素未蒙面的网友的人，本身就是在开源那些知识\n所以我也想成为这样的人，把我会的，我踩过的坑，讲给各位\n这样不仅仅是分享了知识，也是传递开源精神与文化\n我自认为我是一个理想主义的人\n虽然我不能成为天上最耀眼的那颗星，但我愿意把我的一切经验都传授给后人\n我可能没有能力达成我的理想，但你，我的朋友，你可能因为这些知识，能够成就你的梦想\n这篇博客写得实在是太跳跃了，总之很感想您能看到这里，听我年末的碎碎念\n感谢各位给这个互联网不起眼的小窝捧点人场\n愿诸位，运赛因幡，福胜寅丸，新的一年一定要吉祥如意啊~\n","date":"2024-02-09T00:42:37Z","permalink":"https://mlacookie.github.io/article/posts/%E5%90%84%E4%BD%8D%E6%96%B0%E5%B9%B4%E6%96%B0%E6%B0%94%E8%B1%A1/","title":"各位新年新气象"},{"content":"我经常会开一堆网页，如果采用水平的标签页的话会经常找不到标签页\n而火狐又不像别的浏览器，起码到目前为止都没有官方的垂直标签页的支持\n经过一番探索，实际上是可以自己改出来的\n\u0026lt;0x00\u0026gt; 效果展示\r效果还是很不错的\n\u0026lt;0x01\u0026gt; 安装Tree Style Tab插件\r这是一个能在侧栏以树的形式管理标签页的插件，功能还挺多的\n这个插件在火狐的插件商店里就有\n别的类似的插件应该也有，但这里就用这个插件了\n建议先熟悉下这个插件的操作再做下面的操作\n\u0026lt;0x02\u0026gt; 打开about:config的一个选项\r首先要打开about:config的关于自定义界面的选项\n火狐会跳出提示，别动别的东西就好\n搜索toolkit.legacyUserProfileCustomizations.stylesheets，把值改成true即可 \u0026lt;0x03\u0026gt; 打开标题栏\r在火狐顶部右键，找到定制工具栏\n（图片右上角）\n然后打开左下角的标题栏\n这样做是为了在隐藏顶栏后还能做拖动窗口之类的操作\n\u0026lt;0x04\u0026gt; 找到用户的profile文件夹\r这个也简单，Win+R输入%APPDATA%\\Mozilla\\Firefox\\Profiles\\\n里面可能会有多个名字很乱的文件夹，问题不大，找到里面文件最多的文件夹\n那个就是存用户设置的地方\n（我这里是这样的）\n\u0026lt;0x05\u0026gt; 创建修改界面的文件\r在刚刚找到的文件夹里新建叫chrome的文件夹\n然后在chrome文件夹里面新建一个userChrome.css的文件\n打开编辑，输入下面的代码\n/*侧边栏头部是否显示，会影响书签侧栏之类的，可以不写*/ #sidebar-header { display: none !important; } /*隐藏顶栏，也就是原来的标签栏*/ #TabsToolbar { visibility: collapse !important; } 然后重启火狐理论上就生效了\n","date":"2024-01-02T21:34:53Z","permalink":"https://mlacookie.github.io/article/posts/%E5%A6%82%E4%BD%95%E5%B0%86firefox%E6%94%B9%E6%88%90%E5%9E%82%E7%9B%B4%E6%A0%87%E7%AD%BE%E9%A1%B5/","title":"如何将firefox改成垂直标签页"},{"content":"什么是SharpPcap\r最近嘛，要写各种课设，计网也要\n课设就算了，里面还有一个网络编程\n要求捕获些IP数据报，并输出些IP数据报里面的一些数据\n然后一看要求，霍，好家伙，能用C#，那就简单了\n说回正题，要了解什么是SharpPcap，就要先了解WinPcap\nWinPcap是在windows下抓包的工具集合，相当于一个抓包的api\n有了这个，我们就不需要直接与网卡打交道了，要抓包，直接调WinPcap提供的api\nSharpPcap就是把这些api打包成C#的形式，让我们可用在C#中方便的抓包\n安装\r这个就很简单了，直接到Nuget包管理器里面安装就是了\n(@ 24-01-11)\n其实应该用NPcap的，这个比较新，WinPcap有点老了\nWinPcap调用不了无线网卡 这两个SharpPcap都可以调用\nNPcap下载\n在写代码前，还要检查下又没有安装过WinPcap，没有的话会找不到捕获的设备\nWinPcap下载\n这个也是装上就完事了\n写代码\r需要注意的是，SharpPcap貌似重构过好多次，我看到的使用范例有好几版\n但都没用，最后还是靠我自己反编译看的\n(GitHub那里的范例也是不能直接用的)\n总之，我这里用的是6.2.5的版本，别的版本我不管\n丢一段代码，里面带着详细的注释(这段代码也是我计网课设网络编程的代码)\n(@ 24-01-11)\n稍微修改下，原来的代码在处理标识符的逻辑点问题\n(转成BitArray会出现高低位顺序的问题)\nusing System; using SharpPcap; using PacketDotNet; using System.Collections; namespace Test { public class Program { static void Main() { CaptureDeviceList devices = CaptureDeviceList.Instance;//获取所有可用的设备 if (devices.Count \u0026lt; 1) { Console.WriteLine(\u0026#34;No devices were found on this machine\u0026#34;); return; }//没有就直接退出了 Console.WriteLine(\u0026#34;\\nThe following devices are available on this machine:\u0026#34;); Console.WriteLine(\u0026#34;----------------------------------------------------\\n\u0026#34;); for (int i = 0; i \u0026lt; devices.Count; i++) { Console.WriteLine($\u0026#34;index:{i}|{devices[i].Description}\\n\u0026#34;); }//输出可用的设备及其编号 string num = Console.ReadLine();//获取用户输入的编号 ICaptureDevice device = devices[int.Parse(num)];//获取对应的设备对象 device.Open(DeviceModes.Promiscuous, 10000);//准备启动设备 string filter = \u0026#34;ip\u0026#34;; device.Filter = filter;//设置过滤器为ip数据报 device.OnPacketArrival += Device_OnPacketArrival;//设置收到包后的回调方法 device.StartCapture();//开始捕捉 Console.ReadLine(); device.StopCapture();//如果按下任意键，终止捕捉 device.Close();//释放设备 } private static void Device_OnPacketArrival(object sender, PacketCapture e) { var ip = e.GetPacket().GetPacket().Extract\u0026lt;IPPacket\u0026gt;();//把捕捉到的包转换成ip数据报 //因为库里没有处理标识符和片偏移的逻辑，这里要自己写处理逻辑 var s = new BitArray(new byte[] { ip.HeaderData[5], ip.HeaderData[4] });//获取第5第6字节的数据 var symbol = new BitArray(new byte[] { ip.HeaderData[7], ip.HeaderData[6] });//获取第7第8字节的数据 Console.WriteLine(); Console.WriteLine($\u0026#34;Version:\\t{ip.Version}\u0026#34;); Console.WriteLine($\u0026#34;Length:\\t\\t{ip.TotalLength}\u0026#34;); Console.WriteLine($\u0026#34;Serial:\\t\\t{BitArrayToInt(s, 0, 15)}\u0026#34;); Console.WriteLine($\u0026#34;DF:\\t\\t{symbol[14]}\u0026#34;); Console.WriteLine($\u0026#34;MF:\\t\\t{symbol[13]}\u0026#34;); Console.WriteLine($\u0026#34;Offest:\\t\\t{BitArrayToInt(symbol, 0, 12)}\u0026#34;); Console.WriteLine($\u0026#34;From:\\t\\t{ip.SourceAddress}\u0026#34;); Console.WriteLine($\u0026#34;To:\\t\\t{ip.DestinationAddress}\u0026#34;); Console.WriteLine($\u0026#34;Protocol:\\t{ip.Protocol}\u0026#34;); for (int i = 0; i \u0026lt; ip.HeaderData.Length; i++) { if (ip.HeaderData[i] \u0026lt; 16) { Console.Write(\u0026#34;0{0:X} \u0026#34;, ip.HeaderData[i]); } else { Console.Write(\u0026#34;{0:X} \u0026#34;, ip.HeaderData[i]); } if (i % 4 == 3) { Console.WriteLine(); } } Console.WriteLine(); } static int BitArrayToInt(BitArray bitArray, int head, int end)//只是个把二进制数组转换成数字的方法 { int a = 0; for (int i = head; i \u0026lt;= end; i++) { if (bitArray[i]) { a += 1; } a *= 2; } return a; } } } 实际上确实就这么一段代码就够了\n里面的注释也已经点明了具体的功能\n需要注意的是，这里通过事件机制来处理收到包的情况\n也就是这一句\ndevice.OnPacketArrival += Device_OnPacketArrival;//设置收到包后的回调方法 在device收到数据报后，会触发OnPacketArrival事件\n然后就可用用事件那一套机制来处理收到的包了，也就是这一段代码\nprivate static void Device_OnPacketArrival(object sender, PacketCapture e) { var ip = e.GetPacket().GetPacket().Extract\u0026lt;IPPacket\u0026gt;();//把捕捉到的包转换成ip数据报 //因为库里没有处理标识符和片偏移的逻辑，这里要自己写处理逻辑 var s = new BitArray(new byte[] { ip.HeaderData[5], ip.HeaderData[4] });//获取第5第6字节的数据 var symbol = new BitArray(new byte[] { ip.HeaderData[7], ip.HeaderData[6] });//获取第7第8字节的数据 Console.WriteLine(); Console.WriteLine($\u0026#34;Version:\\t{ip.Version}\u0026#34;); Console.WriteLine($\u0026#34;Length:\\t\\t{ip.TotalLength}\u0026#34;); Console.WriteLine($\u0026#34;Serial:\\t\\t{BitArrayToInt(s, 0, 15)}\u0026#34;); Console.WriteLine($\u0026#34;DF:\\t\\t{symbol[14]}\u0026#34;); Console.WriteLine($\u0026#34;MF:\\t\\t{symbol[13]}\u0026#34;); Console.WriteLine($\u0026#34;Offest:\\t\\t{BitArrayToInt(symbol, 0, 12)}\u0026#34;); Console.WriteLine($\u0026#34;From:\\t\\t{ip.SourceAddress}\u0026#34;); Console.WriteLine($\u0026#34;To:\\t\\t{ip.DestinationAddress}\u0026#34;); Console.WriteLine($\u0026#34;Protocol:\\t{ip.Protocol}\u0026#34;); for (int i = 0; i \u0026lt; ip.HeaderData.Length; i++) { if (ip.HeaderData[i] \u0026lt; 16) { Console.Write(\u0026#34;0{0:X} \u0026#34;, ip.HeaderData[i]); } else { Console.Write(\u0026#34;{0:X} \u0026#34;, ip.HeaderData[i]); } if (i % 4 == 3) { Console.WriteLine(); } } Console.WriteLine(); } 这里的e就是捕获到的包，然后就可用进行一系列的处理了\n","date":"2023-12-25T10:01:56Z","permalink":"https://mlacookie.github.io/article/posts/%E7%AE%80%E5%8D%95%E7%94%A8%E4%B8%8Bsharppcap/","title":"简单用下SharpPcap"},{"content":"(@ 24-01-12)\n这篇博客目前写的有点简练，之后会再补充的\n\u0026lt;0x01\u0026gt; 先描述下问题\r最近入了台笔记本，7840HS的，CPU强核显也强\n（主要是没米了）\n然后毕竟是做游戏相关的，Blender总得装上吧 然后发现，跑Cycles渲染器会报错\nHIP binary kernel for this graphics card compute capability (11.0) not found\n就会报这个错误\n解决办法\r从网站上下源码编译Blender就好\nBuild Blender On Windows\n需要安装\nVS2022的C++桌面开发工作负载 TortoiseSVN Git CMake perl python 然后就按官方文章讲的，在cmd里面运行make update和make就好\n（powershell也不是不行，改成./make，但没试过）\n问题分析\r就是这么个问题\nradeon780m对应得代码是gfx1103\n但是blender正常下载的版本还没有带对应这个代码的驱动文件\n在最新的代码中，已经包含了生成代号gfx1103的驱动文件的代码了\n（其实就是CMakeList里面加了个gfx1103）\n","date":"2023-11-29T22:39:09Z","permalink":"https://mlacookie.github.io/article/posts/radeon780m%E6%A0%B8%E6%98%BE%E8%B7%91blender%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/","title":"radeon780m核显跑blender相关的问题"},{"content":"不打算续费阿里云的服务器了\n(虽然本来就是嫖的7个月)\n为什么呢，主要就是因为成本算下来感觉不合适\n不是说贵，而是事情太多，没时间维护\n应该也发现了，我已经接近1个月没写博客了\n这段时间事情实在是多，但都是好的事情多\n我终于算是找到能为之奋斗的方向了\n于是仔细想想，服务器这块估计是没时间维护了\n虽然国内的服务器关闭了，但Github Page的还是在的\n(反正免费，就挂着了)\n至于这么干之后受影响最大的是什么\n那应该就是我的那些Git仓库的国内镜像了\n但问题不大，Github上也都是还在的\n","date":"2023-11-19T22:53:27Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%AD/","title":"国内阿里云服务器关闭"},{"content":"\u0026lt;0x00\u0026gt; ListView是什么\r贴张图就好了\n就是类似这种一行一行展示信息的控件\n当然也不一定是像这种的类似表格的样子(这种后面会讲)\n但都是一行一行的以行为单位的显示一些集合类的显示控件\n\u0026lt;0x01\u0026gt; 先讲WPF里面自带的ListView\r先给个代码，做一个最简单的演示\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;/Window\u0026gt; //ViewModel.cs //常用引用 namespace WPFTest { internal class ViewModel { public List\u0026lt;string\u0026gt; SomeItems { get; set; } = new List\u0026lt;string\u0026gt;() { \u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;fff\u0026#34;, }; } } 演示的结果\n这个就是最简单的ListView，也是WPF默认的样式\n(从这期开始的图会多一点，以前的博文也会慢慢补图，感觉没图还是不好理解)\n我们可以先分析下这个控件需要什么，我们能得到什么\n首先就肯定是需要一个集合啦\n集合无所谓类型(应该都能用，看你怎么绑定)\n然后我们能得到一个这样的显示\n我们可以看到，在这个控件里面已经实现了页面滚动与子项的选择\n(可以说除了有点不符合当代审美之外都没啥问题)\n单项添加\r有时候可能也不是集合提供子项，可能本身就是写死的\n这时候就要自己写ListViewItem了\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;ListView SelectionMode=\u0026#34;Single\u0026#34;\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something1\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something2\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something3\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something4\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something5\u0026#34;/\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 每个ListViewItem也都能设置自己的Background之类的属性，这里就不多写了\n美化子项\r那我们还是要稍微美化一下的，虽然这样搞已经能用了\n我们有两种方式\n一个是操作ItemStyle，另一个是操作ItemTemplate\n操作ItemStyle\r\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;Red\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;Style.Triggers\u0026gt; \u0026lt;!--Trigger这里就偷懒了--\u0026gt; \u0026lt;/Style.Triggers\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 通过ListView.ItemContainerStyle里面设置ListViewItem的样式\n样式就按一般的方式走，这里就随便设置了下，Triggers也能设置，这里懒得写了\n操作ItemTemplate\r这里需要修改下ViewModel，为了更方便的绑定\n//ViewModel2.cs //常用引用 namespace WPFTest { internal class ViewModel2 { public List\u0026lt;TypicalItem\u0026gt; SomeItems { get; set; } = new List\u0026lt;TypicalItem\u0026gt;() { new TypicalItem(\u0026#34;aaa\u0026#34;, new SolidColorBrush(Color.FromRgb(82,114,248))), new TypicalItem(\u0026#34;bbb\u0026#34;, new SolidColorBrush(Color.FromRgb(72,137,217))), new TypicalItem(\u0026#34;ccc\u0026#34;, new SolidColorBrush(Color.FromRgb(91,199,240))), new TypicalItem(\u0026#34;ddd\u0026#34;, new SolidColorBrush(Color.FromRgb(72,214,217))), new TypicalItem(\u0026#34;eee\u0026#34;, new SolidColorBrush(Color.FromRgb(82,248,205))), }; } class TypicalItem { public string Name { get; set; } public Brush Color { get; set; } public TypicalItem(string name, Brush color) { Name = name; Color = color; } } } \u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 效果就差不多这样\n区别\r实际上两个的侧重点是不一样的\nItemContainerStyle重点在每个子项的样式设置\n比方说就是每个子项的背景，子项按下的动画效果之类的\nItemTemplate侧重在子项内部是怎么显示的\n比方说写了个数据类型，里面有好几条属性\n那么就可以用ItemTemplate来自定义这些属性怎么显示\n我怀疑ListViewItem里面就是包着自己的UI树的\n但可视化树没显示，也不敢说死\n这两个的效果肯定是能合并在一起的，毕竟这俩侧重点是完全不一样的\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;!--其实就加了这一个块--\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 和程序行为合并\r那下一步就是写选中子项的行为了\n我们可以通过设置SelectionChanged事件\n为了演示，先修改下前端代码，这里举选择子项切换Border背景颜色的例子\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;!--加了个Grid，上下分割--\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34; SelectionMode=\u0026#34;Single\u0026#34; SelectionChanged=\u0026#34;ListView_SelectionChanged\u0026#34;\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;!--用来显示子项切换的效果的Border--\u0026gt; \u0026lt;Border Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;MyBorder\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; //MainWindow.xaml.cs //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void ListView_SelectionChanged(object sender, SelectionChangedEventArgs e) { MyBorder.Background = (e.AddedItems[0] as TypicalItem).Color; } } } 这样就解决了\n.xaml的代码就不解释了，.cs的代码还是能讲一下的\n主要就是用e.AddedItems[0]拿到选中的TypicalItem对象\n(e.AddedItems[0]这个语法确实很怪，估计是主要是为了支持多个选中的情况)\n如果给ListView起了名字的话也可以这么写(这里起名是MyListView)\n//MainWindow.xaml.cs //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void MyListView_SelectionChanged(object sender, SelectionChangedEventArgs e) { MyBorder.Background = (MyListView.SelectedItem as TypicalItem).Color; } } } 一般来说这么访问选中的子项会多一点\n因为有些时候会去想双击的代码，这就要用MouseDoubleClick事件了\n但MouseDoubleClick是不带SelectionChangedEventArgs e的\n也就是说我们是不能靠传参变量e来获取选择了哪个子项的\n但靠MyListView.SelectedItem这种方式就方便很多，都能用了\n顺便在这里提一点，如果要定义多个鼠标事件，不能采用传统的.xaml写事件然后在.cs写\n因为这么写运行的时候这些MouseHandler会相互屏蔽而导致有些就触发不了\n比如按传统方式同时设置MouseDoubleClick和MouseRightButtonDown，只能触发前者\n要都能触发，应该在控件的初始化用代码初始化这些Handler\n.xaml里面可以按传统方法留一个，但别的都要靠代码方式添加\n//MainWindow.xaml.cs(随便举例的，与前面的代码无关) //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); //就是在这里自己添加 MyListView.AddHandler(MouseDoubleClickEvent, new MouseButtonEventHandler(this.MyListView_MouseDoubleClick), true); MyListView.AddHandler(MouseRightButtonDownEvent, new MouseButtonEventHandler(this.MyListView_MouseRightButtonDown), true); } private void MyListView_MouseDoubleClick(object sender, MouseButtonEventArgs e) { //处理代码 } private void MyListView_MouseRightButtonDown(object sender, MouseButtonEventArgs e) { //处理代码 } } } 还有就是我还没啥办法实现类似Button绑定ICommand的做法\n但其实可以把方法本体写在VM里，然后在.cs里用DataContext调命令，实现猴版的MVVM\n这里就不细讲了\n网格布局GridView\r博客最上面的图就是使用了GridView的效果\n(就是这张)\nGridView是嵌套在ListView里面的，具体代码如下\n(还是用得ViewModel2.cs)\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34;\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 这样就实现了类似前面那张图的效果了\n这里不难看出GridView是隶属于ListView的\n然后对于每一个格子，也是能自定义Template的\n最上面的是Header，也能自定义\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn\u0026gt; \u0026lt;!--就改了这里--\u0026gt; \u0026lt;GridViewColumnHeader\u0026gt; \u0026lt;TextBlock Text=\u0026#34;emm\u0026#34; Background=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/GridViewColumnHeader\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 简单写一下就是这样了\n前面讲的SelectionChanged和MouseDoubleClick之类的还是写在ListView的块里\n这样就可以实现表格化的效果了\n\u0026lt;0x02\u0026gt; 讲讲ModernWPF的ListView\r因为有自己的练手项目在用这个包，所以就顺便讲讲了\n(Nuget上有好多叫ModernWPF的包，我自己用的是这个)\n之前的博客也有讲过一点\n在ModernWPF的包里面有两种ListView实现\n一种是使用WPF原生的ListView但修改了Style来匹配风格\n另一种是包里面自己写的ListView\n前者就要求别去改Style，不然所有的样式又要自己写\n后者的化代码风格会更像UWP开发，有些写法确实挺新的\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;!--这里用的是最前面的ViewModel--\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;ListView Grid.Row=\u0026#34;0\u0026#34; ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;ui:ListView Grid.Row=\u0026#34;1\u0026#34; ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; 这里演示了这个包里面的两种写法，效果上是一样的\n其余大部分都可以按WPF原生的写法写\n但如果要用GridView，那么只有原生的写法(这个包没自己写)\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 这里可以看得，如果用GridView的话，右边的滚动条时不会收纳的\n(准确来说自动从收纳状态变成展开状态)\n别的自定义之类的也和WPF原生写法一样，就是尽量别动Style\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34;\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;Button Content=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 写这篇博客真的花了不少时间，大家看得开心就好\n","date":"2023-09-18T20:10:22Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006-%E5%85%B3%E4%BA%8Elistview/","title":"WPF学习笔记06-关于ListView"},{"content":"20周岁生日了，挺好的\r","date":"2023-09-16T20:55:27Z","permalink":"https://mlacookie.github.io/article/posts/%E5%9C%B0%E7%90%83online%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF20%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5/","title":"地球online在线时长20周年纪念"},{"content":"前言\r这篇博客是我边看发布会边写的\n虽然已经尽可能得减少错误，但仍可能留存些问题，望海涵\n开场\r经典凌晨一点\u0026quot;Good morning\u0026quot;\n差不多就是简要总结了下今年WWDC的成果\n然后吹了下15寸的MacBook Air\nWatch series9\r价格：399$ 起\n(顺带一提，Watch SE 249$ 起)\n亮点\r采用全新S9芯片(更强的性能)\n有新一代U2芯片(更精确的苹果设备定位)\n加入新的一碰传名片功能\n全天候显示，但新屏幕亮度可低至1nit，而且更亮\n新手势，佩戴手表时轻碰食指和拇指两下可实现一系列功能，比如接打电话之类的\n(靠神经网络实现的)\n加入了很多人工智能的功能(没来得及记)\nWatchOS10优化了骑行检测，可以接蓝牙设备检测\n介绍苹果的环保计划\r通过短片介绍了苹果当前的环保进度\n2030年前实现所有业务碳中和\n(尽可能多的使用回收材料)\n宣布Watch series9将采用100%的清洁能源生产\n减小手表的包装盒(环保嘛)\nWatch series9是苹果第一个碳中和的产品\n(后面的产品或多或少都讲了环保，就不讲了，大致就是用了些回收材料)\n表带\r有和Hermes合作的表带\n和Nike合作的表带\nWatch Ultra2\r价格：799$ 起\n亮点\r(有些Watch series9也有的就不讲了) 使用S9和U2\n屏幕更亮，有3000nits\nIPhone15 和 IPhone15 Plus\r价格：799$ 起\nPlus版价格：899$ 起\n(顺带一提，SE版 429$ 起)\n亮点\r有灵动岛(我不好评价这玩意)\n屏幕更亮，1500nitsHDR亮度，2000nits峰值亮度\n手感提升，航空级铝边(玄学)\n背板采用融色玻璃，色彩更好(新的颜色确实不错)，蚀刻哑光工艺，抗污不粘指纹\n官方钦定苹果更保值(这个是真想不到的)\n4800w四合一像素后摄主摄\n经典后摄色彩统一\n新的HDR模式，优化了照片的色彩(样片嘛，看着肯定好看)\n采用A16芯片(内存带宽提升50%，能耗降低20%)\n搭载U2芯片，苹果间设备连接性提升(距离更远了)\n基于机器学习的通话降噪\n接口改type-c(终于，但速度是2.0)\n配MagSafe\n卫星方面（刚好讲到了）\r卫星通话业务扩展到14个国家（没中国）\n推出卫星呼叫道路救援功能\n卫星呼叫服务将在iPhone15系列上免费提供2年\nIPhone15 Pro 和 IPhone15 Pro Max\r价格：999$ 起\nMax版价格：1199$ 起\n亮点\r(有些IPhone15有的这里也不讲了)\n全新钛金属材质，造就最轻的IPhone(官网186g)，最窄的边框\n最坚固的玻璃，超瓷晶玻璃\n钛合金阳极氧化后有PVD图层保护\n新的框架结构可更方便地更换背板玻璃(苹果会让用户自己修？)\n经典静音键没了，改成一个可自定义操作的按键\n带ProMotion，待机显示(全天候显示)\n搭载A17 Pro(怎么A17还带Pro的)\nA17Pro部分\r3nm工艺\n6核心(2p+4e设计)，最多10%单核性能提升(嗯，挤牙膏)\n神经网络引擎升级，强化客户端处理能力\n搭载多个专用处理引擎(ProRes编码，AV1解码，屏幕驱动引擎)\n搭载USB3控制器，带来20x的传输速度提升(可不嘛，非Pro还是2.0速度)\nPro级GPU，六核设计，有硬件光追(真的意外，看来换架构了)\n上采样技术(感觉上像DLSS的技术，有用到神经网络引擎)\n(讲游戏环节有农，原，星铁，生化4)\n(大伟哥亲自上台讲解)\n将会在IPhone上发行最新的主机级刺客信条(刺客信条幻景)\n摄影部分\r4800w主摄有更大的底\nPro Max搭载5x潜望式长焦(四次折光结构)(等效120mm)\n(Pro是3x的长焦)\n微距模式\nLog模式编码，有ACES色彩认证\n可以拍摄空间视频了(晚些开放该功能)\niCloud+ (正好讲到)\r添加6TB和12TB的挡位\n然后就没了\r没错，就开了一个半小时不到就没了\n我的评价是不如今年的WWDC有意思\n太平淡了，我都快看睡过去了\n东西都是常规升级，没啥震撼的升级\nU2的升级还是不错的，苹果的很多独特的体验都源自这个芯片\n但别的升级只能说中规中矩\n期待的芯片升级感觉就跟挤牙膏一样(光追是挺意外的，但从演示看感觉只是有了而已)\n还有约1/3的内容在讲环保，苹果嘛\n没有Ipad系列更新，没有Mac系列的更新(这个到也合理，WWDC刚更新过)\n也难怪只开一个半小时，就更新这两个的话确实没啥可讲的\n还是挺失望的，以为WWDC搞那么大会在发布会上整点大的\n结果拿出来的东西和前代差别不大，挤牙膏式升级(对普通用户而言)\nRNM，退钱，太失望了，我超\n已经结束嘞\n","date":"2023-09-13T01:10:46Z","permalink":"https://mlacookie.github.io/article/posts/23%E5%B9%B4%E8%8B%B9%E6%9E%9C%E7%A7%8B%E5%AD%A3%E5%8F%91%E5%B8%83%E4%BC%9A%E7%9C%81%E6%B5%81/","title":"23年苹果秋季发布会省流"},{"content":"前言\r我在半年前已经将我的IPad出手了，所以这里写的体验都是基于半年前的IPadOS16.1\n为什么半年后还写这个呢，主要是想练练手，没怎么写过评测类的文章，顺便分享下我的体验\n\u0026lt;0x01\u0026gt; 为什么选择IPad\r这个小标题看着有些怪哈，但既然说放弃，那肯定有一开始选择的理由的\n好不容易考上了大学，总该为自己添置些设备\n当时的用的电脑还是老笔记本，但性能还够用，就先不换了\n但高中的时候啊，我发觉书和卷子实在是太多了\n平时就是一大堆书和卷子垒在桌子上，找书找卷子非常困难\n所以考上大学我就想买个平板，来做我的移动图书馆\n当时我的选择有IPad系列，小米平板5系列，OPPOPad系列还有就是二手板子\n当时看了好多评测，图稳选择了IPad系列\n因为它软件丰富笔好用，硬件强悍屏准确(IPad数字系列除外)\n\u0026lt;0x02\u0026gt; 错误的选择，为不存在的需求买单\r最开始我只是想买台IPad记笔记\n然后不断的增加可能的需求\n画画，开发，剪视频，修图还有打原神😅\n也没怎么考虑未来真的会不会干这些事情\n反正从原来打算收一台IPadAir5一路升级到买一台全新的IPadPro2022-1T\n还买了支笔(笔二手的，大概五百多)\n现在看来就挺离谱的，实际上我根本没有上述的刚需\n(画画有别的选择，开发用IPad基本没戏，剪视频修图更是不会用IPad，也就打原神了)\n但目前来看，有这样一台性能强劲的IPad，好好用个五六年也还好\n为啥最后放弃使用IPad呢？\n\u0026lt;0x03\u0026gt; IPadOS，使我放弃的根本\r到手后，我也是第一时间开始熟悉IPadOS\n我对IPad还是挺熟悉的，小学的时候用过IPadMini2(拆机尸体还在我架子上)\n激活后没一会儿，差不多就熟悉了\n买了Procrate、Goodnote5，差点也买了LumaFusion(还好没买)\n(但我现在还是吹爆Goodnote5，这是我用过最好用的笔记软件，体验非常好)\n装上苹果的库乐队，玩了好一会\n最后当然是装上原神，体验很流畅，就是掉电比我想象得快\n(原Bench果然名不虚传)\n正式进入了大学，这台IPad也陪伴了我一个学期，我也开始觉得这IPad并不能满足我需求\n正如苹果宣传的一样，\u0026quot;你的下一台电脑，何必是电脑\u0026quot;，我希望IPad能有电脑的能力\n也不是说有多强的性能，能码字，能写代码，满足外出工作需求就够了\n尤其是自从IPad搭载m1以来，一直有传言说IPad会搭载MacOS，我也一直有这不切实际的幻想吧\n(说真的，如果IPad能搭载MacOS，直接绝杀，所有轻薄本都不用混了，可惜不可能)\n于是我发现，在着上面搞开发几乎不可能，而我又是计算机系的学生\n(我知道可以搭CodeServer，但这样不是任何设备都能搞开发吗)\n本来想通过些别的办法解决，比方说UTM虚拟机跑Windows\n(人家开发者真的猛，都搞定了m1的GPU驱动)\n结果呢，发现完美解决要越狱，打开JIT加速才有比较好的性能\n而我手头的IPad本身系统版本就新，我还手贱升级到IPadOS16，莫得退路\n其实不越狱也能跑，就是靠开发者签名跑JIT加速，然后再跑UTM\n这个方法确实能跑，但要么你自己是开发者，要么找别的开发者签名\n前者要苹果开发者年费700，后者感觉不是很稳，所以这条子路基本也寄了\n到目前为止，不能开发就不能开发吧，那就做做生产力吧\n出门干活的话用远程桌面续续命好了，反正我基本不出门\n然后就是我最头疼的问题，苹果的文件管理\n这个倒是购买前我没去思考的问题，都什么年代了，总该有个合理的文件管理吧\n但IPadOS就是没有，那个叫文件的应用并不是给你管理文件的，顶多说让你把IPad当硬盘用\n或者说给不同的软件做中转用的\n比方说编辑个文档，我先要在软件里写好，然后到处到文件里，再传文件，有点麻烦\n(也赖我，不用MacOS)\n而且我常用Windows，和IPad交换文件极其困难\n效率最高的方式居然是拿U盘拷文件过去\n(可以用KDE Connect来传文件，当时不知道这软件有IOS版)\n忍了一学期，最后实在是忍不了一点，最后就放弃IPad了\n基本上不是IPad本身的问题，只能说IPadOS不适合我\nIPadOS很喜欢教用户做事，苹果嘛，老毛病了\n但IPad上的软件也喜欢教用户做事，基本上可设置选项不多，让用户自己适应\n这也算我放弃IPad的一个原因\n\u0026lt;0x04\u0026gt; IPad是个好工具，但它不适合我\r说了这么多，其实我仍然觉得这款IPadPro是一款不错的产品\n优秀的工业设计，顶级的屏幕，强劲的性能，丰富的软件，还有优秀的系统体验\n我是真的很喜欢IPadPro的机身，全铝磨砂机身，摸着很舒适\n屏幕是我见过最好的屏幕，看HDR视频简直就是享受，搭配上四扬声器，看电影很棒\nm1，不必说，移动端数一数二的存在\n\u0026quot;Only Apple can do\u0026quot;的软件生态，几乎所有的创意工作都能在这上面完成(除了开发)\nIPadOS虽然没有能用的文件管理，但整个系统体现的就是灵动，按下就有反馈\n而且说实在的，IPadPro的价格也没有很贵(如果能发挥它的实力的话)\n像画画领域，IPadPro+ApplePencil的价格跟Wacom高端数位屏比，苹果这套就有了性价比\n影视领域，现在有了DavinciForIPad，白天拍，路上就能粗剪，这带来的效率提升是巨大的\n修图的话，用那些软件，差不多拍完回去的路上就能完成调色，非常优雅(这个也不一定要Pro的)\n搞音乐更不用说，库乐队已经很强大了，现在还有LogicForIPad，更强大\n而且貌似IPad上还有些碟机软件，接上碟机就能用，比macbook更轻便\n举这些例子也不是说鼓励大家买IPad，我也只是挑IPad的专长讲，具体我也不是很熟\n真搞生产力，IPad的弱势也有，比方说程序开发\n虽然说有在搞XcodeForIPad，但也不用抱太大希望，这个要看你的开发贴不贴近苹果生态\n(总不能指望这玩意能编译C#之类吧)\n搞CodeServer的方案我总是感觉很野鸡，毕竟这样的话啥设备不能开发啊\n还有就是，我原以为，IPad是最脱离苹果生态的产品，哪怕没有一个苹果的产品也能用得好\n但我现在觉得最脱离苹果生态的产品还得是macbook，IPad更像是macbook的附属品\n我有个室友，他的日用电脑就是macbook，在我的IPad出手前借给他用了几天\n他整体体验下来感觉非常妙，随航，隔空投递，接力真的很舒服\n尤其是随航，它可以让IPad成为macbook的副屏，我们不清楚苹果是这么实现的，这玩意延迟巨低\n所以，IPad好吗，它真的很好，但它不适合我\n(所以我现在换成了Samsung的TabS7😋)\n","date":"2023-09-06T15:21:11Z","permalink":"https://mlacookie.github.io/article/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E4%BD%BF%E7%94%A8ipad/","title":"我为什么放弃使用IPad"},{"content":"\u0026lt;0x00\u0026gt; 介绍下ModernWPF\r这个其实是个Nuget包，里面有很多现代化设计的WPF组件\n不是之前说嘛，在WPF里面做现代化的UI设计很复杂\n现在差不多就是别人已经把最复杂的实现写完了，我们只要调用就好了\n这个包的实现风格是UWP风格(也就是WinUI2)\n里面的很多用法是参考UWP的(我具体用下来就是UWP的api级复刻)\n所以有些组件的用法跟WPF的常见实现不一样(就比如这里讲的导航界面)\n安装的话用VS的Nuget包管理器就可以\n(Nuget上有很多包叫ModernWPF，我用的是这个，别的实现我就不清楚了，最好一样吧)\nGithub项目主页\n在Github上也有这个项目的Wiki，所有组件的使用都有列举一点\n因为差不多是完全复刻UWP的，所以有些样例会直接跳转到微软的文档\n照样看就是了，代码实现是差不多的(跳转的文档是英文的，最好就直接看英文，这样最准确)\n\u0026lt;0x01\u0026gt; 如果是一般的WPF项目，我们该怎么实现导航\r还是先稍微讲讲一般的WPF项目里怎么实现导航\n假设我们有MainWindow.xaml，PageViewModel.cs，SomePage.xaml\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;window ...\u0026gt; \u0026lt;window.DataContent\u0026gt; \u0026lt;local:PageViewModel/\u0026gt; \u0026lt;/Window.DataContent\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;!--第一列放导航的按钮--\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;!--若干按钮，具体就不设计了--\u0026gt; \u0026lt;Button Command=\u0026#34;{Binding NavigateToPage}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;!--内容展示的页面--\u0026gt; \u0026lt;UserControl Grid.Column=\u0026#34;1\u0026#34; Content=\u0026#34;{Binding CurrentPage}\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/window\u0026gt; //PageViewModel.cs //常见的引用 namespace TestProject.ViewModel { internal partial class PageViewModel:ObservableObject { [ObservableProperty] public object? currentPage; public ICommand NavigateToPage{get;set;} public PageViewModel() { CurrentPage=new SomePage(); NavigateToPage=new RelayCommand(()=\u0026gt;CurrentPage=new SomePage()); } } } (这里的一些没见过的东西是在Community.MVVM包里面的，上一篇结尾有介绍)\n\u0026lt;!--SomePage.xaml--\u0026gt; \u0026lt;UserControl ...\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Emmm\u0026#34; Foreground=\u0026#34;White\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; FontSize=\u0026#34;32\u0026#34;/\u0026gt; \u0026lt;/UserControl\u0026gt; 这里通过UseControl控件来存放我们自己写的SomePage\n导航栏的每个按钮会绑定一个Command，来控制UserControl的Content\n因为这个Content就存放具体的页面嘛，所以只要改这个Content就相当于切换页面了\n之后有什么多的页面就是先新建一个UserControl控件并完成设计\n然后再在PageViewModel.cs里面实现切换代码(就是写一行改CurrentPage的代码)\n最后在MainWindow.xaml里面为对应按钮绑定Command就好\n其实最好是在PageViewModel里用一个object数组存储不同的page，我这里就偷懒了\n还有就是导航栏我也没咋设计，基本上就是用Triger配合Setter做就可以了，这里也摸了\n\u0026lt;0x02\u0026gt; 用ModernWPF里面的NavigationView实现导航\r(虽然是介绍怎么在ModernWPF里面实现导航，因为用法极像UWP，也算介绍UWP的开发了)\n在ModernWPF中用NavigationView做导航就没有类似按钮绑定Command的用法了\n准确来说，用ModernWPF甚至都不需要写一个对应的VM\n那么怎么切换页面呢\n差不多就是靠.xaml附带的.cs里面实现了\n先上代码\n(ModernWPF有使用前的一些步骤，在它的readme有写，就两步，我就不介绍了)\n\u0026lt;!--ModernUITest.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;TestProject.ModernUITest\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; xmlns:local=\u0026#34;clr-namespace:TestProject\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34; Title=\u0026#34;ModernUITest\u0026#34; Height=\u0026#34;800\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;ui:NavigationView IsBackButtonVisible=\u0026#34;Collapsed\u0026#34; IsTitleBarAutoPaddingEnabled=\u0026#34;False\u0026#34; PaneTitle=\u0026#34;Test\u0026#34; PaneDisplayMode=\u0026#34;Auto\u0026#34; ItemInvoked=\u0026#34;NavigationView_ItemInvoked\u0026#34;\u0026gt; \u0026lt;ui:NavigationView.MenuItems\u0026gt; \u0026lt;ui:NavigationViewItem Icon=\u0026#34;Home\u0026#34; Tag=\u0026#34;TestProject.Page.PageTest1\u0026#34; Content=\u0026#34;Sample Item 1\u0026#34; IsSelected=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;ui:NavigationViewItem Icon=\u0026#34;Keyboard\u0026#34; Content=\u0026#34;Sample Item 2\u0026#34; Tag=\u0026#34;TestProject.Page.PageTest2\u0026#34;/\u0026gt; \u0026lt;/ui:NavigationView.MenuItems\u0026gt; \u0026lt;UserControl Name=\u0026#34;UC\u0026#34;/\u0026gt; \u0026lt;/ui:NavigationView\u0026gt; \u0026lt;/Window\u0026gt; //ModernUITest.xaml.cs //常见的引用 namespace TestProject { public partial class ModernUITest : Window { public ModernUITest() { InitializeComponent(); UC.Content = new PageTest1();//给一个默认的页面 } private void NavigationView_ItemInvoked(ModernWpf.Controls.NavigationView sender, ModernWpf.Controls.NavigationViewItemInvokedEventArgs args) { if(args.IsSettingsInvoked==true) { NavigationView_Navigate(typeof(int), args.RecommendedNavigationTransitionInfo); //我这里没写Setting的page，所以就随便写了typeof(int) } else if(args.InvokedItemContainer!=null) { NavigationView_Navigate(Type.GetType(args.InvokedItemContainer.Tag.ToString()), args.RecommendedNavigationTransitionInfo); } } private void NavigationView_Navigate(Type navPageType, NavigationTransitionInfo transitionInfo) { Type preNavPageType = UC.Content.GetType(); if(navPageType is not null \u0026amp;\u0026amp; !Type.Equals(navPageType, preNavPageType)) { if(navPageType==typeof(PageTest1)) { UC.Content = new PageTest1(); } if (navPageType == typeof(PageTest2)) { UC.Content = new PageTest2(); } } } } } (PageTest1和PageTest2的代码就不贴了，就纯纯的一行字)\n先讲下包里的东西\rui:WindowHelper.UseModernWindowStyle=true表示使用ModernWPF的窗口样式\nwindow控件下面只有ui:NavigationView\n先在ui:NavigationView里面设置ui:NavigationView.MenuItems\n再在里面设置ui:NavigationViewItem，要几个就设置几个\nui:NavigationView下面有个UserControl，这个就是我们要切换的页面\nui:NavigationView里面有些属性\nIsBackButtonVisible=\u0026quot;Collapsed\u0026quot;是关闭默认的返回按钮\nIsTitleBarAutoPaddingEnabled=\u0026quot;False\u0026quot;是关闭顶栏的自动排布\nPaneTitle=\u0026quot;Test\u0026quot;就是会显示在最上面的那行字，展开时会显示\nPaneDisplayMode=\u0026quot;Auto\u0026quot;这里显示了自动展开，就是最大化窗口时会自动展开\nItemInvoked=\u0026quot;NavigationView_ItemInvoked\u0026quot;这个是实现导航最关键的部分，后面讲\nui:NavigationViewItem里别的应该都能看懂\n就是Tag这个是最关键的，规范的话里面要填上要导航页面对应的类型全名\n就是对应页面的namespace.类名，因为按规范导航会用到Type来判断\n(估计是因为微软文档写的是用Frame实现页面导航)\n.xaml里要干的事\r在ui:NavigationView里写上ItemInvoked=\u0026quot;NavigationView_ItemInvoked\u0026quot;，名字随意\n在ui:NavigationViewItem里正确写上Tag\n给UserControl起个名，好让我们在.cs拿到对象\n剩下的事就交给.cs了\n.cs里要干的事\r按上面的样式写就可以了\n大致的调用过程\r在NavigationView里面切换页面会触发ItemInvoked绑定的事件\n在ItemInvoked绑定的方法中，先判定是不是要切换到Setting的页面\n(args.IsSettingsInvoked==true) (因为这里的NavigationView没有设置IsSettingsVisible=\u0026quot;False\u0026quot;)\n然后判定args.InvokedItemContainer!=null\n这两条路径都会调用导航方法NavigationView_Navigate\n这个导航方法会要求传入一个Type和一个NavigationTransitionInfo\n(NavigationTransitionInfo在这里确实没啥用)\n这个Type用来判断具体要切换到哪个页面\n其实Tag随便写也没啥问题，主要看写的导航方法是什么\n这里我写的代码极致精简的话完全可以初始化一个Dictionary\u0026lt;string,object\u0026gt;\n然后直接在ItemInvoked绑定的方法中切换就可以了\n像这样\nnamespace TestProject { public partial class ModernUITest : Window { Dictionary\u0026lt;string, object\u0026gt; pages; public ModernUITest() { InitializeComponent(); pages = new Dictionary\u0026lt;string, object\u0026gt; { {\u0026#34;Page1\u0026#34;,new PageTest1()}, {\u0026#34;Page2\u0026#34;,new PageTest2()}, {\u0026#34;Setting\u0026#34;,new SettingPage()}, }; UC.Content = pages[\u0026#34;Page1\u0026#34;]; } private void NavigationView_ItemInvoked(ModernWpf.Controls.NavigationView sender, ModernWpf.Controls.NavigationViewItemInvokedEventArgs args) { if (args.IsSettingsInvoked == true) { UC.Content = pages[\u0026#34;Setting\u0026#34;]; } else if (args.InvokedItemContainer != null) { UC.Content = pages[args.InvokedItemContainer.Tag.ToString()]; } } } } 对应的Tag再改改就好\n\u0026lt;0x03\u0026gt; 两种做法的区别\r我个人来看的话，按第一种实现会更加优雅\n毕竟前端只要有按钮绑定Command就好了\n但这么做的话就是控件要自己开发了(也确实不是大问题，主要是WPF现在只有维护了)\n第二种方式相对来说没那么优雅，但真正做到了前端的事前端干\n按照MVVM的理论，VM是用来连接前后端的\n但第一种方法我们仅仅是为了前端切换页面就写了个PageViewModel实现\n某种程度上确实不大符合MVVM的定义\n(我知道有别的方式可以不单独写VM，但别的方式确实没单独写VM直观)\n而第二种方法把前端的事情聚合在一起，那些新的页面都是在前端new出来的\n有啥好处呢，主要还是方便管理吧，功能更加聚合了\n","date":"2023-08-30T13:28:48Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-%E6%80%8E%E4%B9%88%E7%94%A8modernwpf%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%AF%BC%E8%88%AA%E7%9A%84%E7%95%8C%E9%9D%A2/","title":"WPF学习笔记05-怎么用ModernWPF实现带导航的界面"},{"content":"\u0026lt;0x00\u0026gt; 相对更正规的MVVM的写法\r前一篇文章不是讲MVVM模型嘛，然后这几天看了看别人写的代码\n确实有很多值得学习的地方\n单独拆个BaseViewModel出来\r之前讲到ViewModel要实现接口INotifyPropertyChanged来通知前端属性更改\n基本上所有的VM都要用到的，所以最好就是有个BaseViewModel类，给所有的VM继承\n具体代码如下\nnamespace WPFTest.VM { public class BaseViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; internal void NotifyPropertyChanged(string propertyName) { PropertyChangedEventHandler handler = PropertyChanged; if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName)); } } } 其实就是把那些代码单独拆出来了\n然后所有的VM继承这个类就好了\n之前也讲到RelayCommand类也是经常用到的工具类\n所以一般这两个类的文件会放在同一个文件夹下\n这里的命名空间也进行了规范(我这里为了简单就只写缩写了)\n反正就是M/V/VM分三块地就行了\n具体还是按着规范怎么舒服怎么来\n另一种更舒适的方式添加DataContext\r之前在前端引入VM的上下文是靠对应.cs文件里加this.DataContext=this;实现\n现在有相对舒适的做法\n首先要在.xaml的xmlns中引入命名空间\n然后加入具体控件的DataContext\n具体要添加的代码如下\n\u0026lt;Window ... xmlns:vm=\u0026#34;clr-namespace:WPFTest.VM\u0026#34; ...\u0026gt; ... \u0026lt;Window.DataContext\u0026gt; \u0026lt;vm:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; ... \u0026lt;/Window\u0026gt; 这里的vm可以随便改的，ViewModel是具体的VM\n这样写的话就尽可能避开对应的.cs，尽可能把前端实现交给.xaml\n\u0026lt;0x01\u0026gt; 关于窗口透明化\r之前是在Window标签里设置AllowTransparency=True和Background=\u0026quot;Transparent\u0026quot;来实现\n但这样实现的窗口性能会受很大影响(相关分析可以看大佬lindexi的博客)\n简单来说就是这样写会相对频繁的申请内存，让CPU和内存的负荷加大\n所以怎么办呢，我们也可以通过WindowChrome实现\n更多的信息可以看大佬walterlv的博客\n还有大佬丑萌气质狗的博客\n我这里就接着我的代码改改了\n具体修改的代码如下\n\u0026lt;!--前一个是隐藏window默认控件的，后一个是仅允许最小化的意思--\u0026gt; \u0026lt;!--具体也不清楚为啥，后一个必须是CanMinimize或NoResize才有透明--\u0026gt; \u0026lt;Window ... WindowStyle=\u0026#34;None\u0026#34; ResizeMode=\u0026#34;CanMinimize\u0026#34; ...\u0026gt; \u0026lt;!--修改WindowChrome--\u0026gt; \u0026lt;WindowChrome.WindowChrome\u0026gt; \u0026lt;WindowChrome GlassFrameThickness=\u0026#34;-1\u0026#34;/\u0026gt; \u0026lt;/WindowChrome.WindowChrome\u0026gt; \u0026lt;!--别的代码--\u0026gt; \u0026lt;!--在Template里设置背景透明，一定别忘加ContentPresenter--\u0026gt; \u0026lt;Window.Template\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Window\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;Transparent\u0026#34;\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; Margin=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;ContentPresenter ClipToBounds=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Window.Template\u0026gt; \u0026lt;!--别的控件--\u0026gt; \u0026lt;/Window\u0026gt; 还有我们原来负责最小化和关闭程序的两个按钮要加上WindowChrome.IsHitTestVisibleInChrome=\u0026quot;True\u0026quot;\n这个原理在丑萌气质狗的博客里有讲\n(其实建议不搞异型窗口，容易出很多莫名其妙的问题)\n\u0026lt;0x02\u0026gt; 一些常用的Nuget包\rWPF的强大还体现在有很多Nuget包\n这些包大多是些UI组件，使WPF也可以方便的实现现代化的UI\n我自己在研究的有ModernWPF和FluentWPF\nMordernWPF提供了些现代化的窗口和组件\nFluentWPF实现了Fluent设计的UI，看着好看很多\n这两个用得应该还算广吧(我在很多的WPF项目里看到有用的)\n性能方面还没怎么试(没研究明白)\n还有一个不是专门给WPF用的，而是方便MVVM设计的\n叫CommunityToolkit.Mvvm，很好用的\n平时我们写MVVM模式总是要像最上面一样写一个BaseViewModel还有一个RelayCommand\n这些常用的基础类已经在这个包里写好了\n尤其是这玩意8.0版本加入了源代码生成器的特性，现在写属性和前端通知就很方便\n具体可以看B站up-十月的寒流的视频\n(人家是真大佬，他的视频做的都很不错的)\n(所以我的博客就摸了😋)\n","date":"2023-08-23T00:49:54Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-mvvm%E5%92%8C%E5%88%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%A1%A5%E5%85%85/","title":"WPF学习笔记04-MVVM和别的一些东西的补充"},{"content":"\u0026lt;0x00\u0026gt; 经典在前面写点啥\r很早就想去这种大型的THO活动了\n刚上大学的时候本来是想能赶上浙江的THO\n结果呢，刚好跟我们第一次期中考撞上了\n这期中考呢，还有点重要，跟分班有关系\n所以就没敢去浙T\n(顺带一提，23年浙T在10.28，我必有时间去)\n所以嘛，在B站上刚看到上海THO，一下子就买了票\n好嘛，总算是能开开眼见识下国内东方众的热情了\n本来还想看看今年的幻奏的，但看了看时间，看了看上海的住宿价格，就没去(挺可惜的)\n于是就守着火车最早的发售点买了票\n住宿就在学校寝室了，极致省钱\n最有意思的是我以为我们校车万群友也会去不少，所以我也没在群里说\n结果在开展会前两天问了两圈，没个群友去\n哇，那怕不是我一个人在展会晃悠\n我老社恐了，但还是想，票都买了，还是去吧\n\u0026lt;0x01\u0026gt; 大概讲下看展的一天(流水账警告)\r我先是从学校寝室出发赶到杭州站\n最离谱的是出发前一个晚上我给手机充电，然后不知怎么晚上停电了(晚上热得睡不着)\n总共就睡了3小时不到，然后带着63%电量的手机出门\n好在说坐上列车有插头，但快充头会掉，所以就只能用边上的USB口充，好歹能充吧\n一路上充到85%，算是能熬过一天了\n下了列车，看到有人cos小玲，我就直接跟他们去了😂\n不过有一说一啊，上海15号线的指引确实比较神秘，其实出南站往一号口进去就可以了\n但上面的标志没换，我问了下老同学，他说这条线比较新，可能指引还没跟上\n一路上我社恐嘛，不敢搭话\n到红宝石路后，很明显有一群人往某个方向走，那这也很明显是去上T的嘛\n路上呢，碰见俩人貌似有点找不到路，我就鼓起勇气去搭了下话(所以有时我也在想我到底是不是社恐)\n一聊起来就马上熟悉起来了\n排队入场的时候就一直聊，他们是上海当地的，还在上高中\n甚至他们还有个同学就在场子里设摊买专辑，叫Talkie Dance，真挺厉害的\n人是真的多，当然人多才热闹\n为了倒时候能先吃饭，在他们俩拜访完他们同学后我们就在场馆内的麦那里排队了\n那边是先订餐，然后会给一张凭证，到时候来取\n(来吃麦主要是为了那个挂件)\n麦的边上是红魔馆补给站，卖些蛋糕面包，价格也挺好的\n总之我们十点入场，然后排队到十二点才吃完饭\n吃完饭后，我们仨打算先去预约园神，然后就跑到那个摊\n一扫码，哇，人是真的太多了，根本扫不出来，我们就说之后再来吧\n那干啥呢？之前就光顾着吃饭了，还没完整逛过整个场馆\n场馆说大不大，说小不小，但容纳600越共还是略显拥挤了\n那也得挤着逛啊，我们从游戏区开始，绕S型路线，逛到主舞台\n(顺便说下，一路上也看到很多抽象玩意)\n(比方说距离阿求诞辰30周年还有约354天之类的，很乐)\n好，总体有个概念了\n再按S型路线绕一圈，一路上我们仨各自爆了点米\n我入了套三月精和kk做的扑克，他们也入了点东西\n到了大概一点左右，槐南茶馆的相声节目就快开始了，我们也就赶到主舞台，找块地儿先坐\n槐南茶馆的人气确实旺啊，还没正式开始呢，舞台前就坐了一大圈人\n到了正式开始的时候，那熟悉的仨人上台了\n一开口，氦，就是个地道(手动单臂大回旋)\n具体可以看看B站的视频\n好久没有这么过瘾地听一场相声了，在这感谢槐南茶馆的付出\n(真看几次笑几次，真的就是人们喜欢的艺术啊)\n看完后啊，我的口音也给他们同步了😝\n那看完相声也下午两点了，距离展会结束还有3小时\n那咋整啊，接着逛嘛\n基本上就是绕着摊转了一圈又一圈，我们仨呢也爆了几轮米\n买了各种奇怪的东西，可谓收获颇丰\n最重要的是我们终于预约上了园神，哇，太好了\n(工作人员也跟着我们激动😄)\n最后啊，逛到下午四点，真的逛不动了(那时候已经走了一万六千步了)\n(本来还想去雾雨咖啡店打个卡，但真走不动路了)\n那就回去了，我们仨告别，各回各家\n但问题是我的高铁票是晚上七点的，也行，就在火车站歇下脚了\n上了高铁，发现后面就坐俩上T回来的人，寒暄了两句\n到了杭州，坐地铁，回寝室，睡觉\n\u0026lt;0x02\u0026gt; 一些感想\r看得出来还是有不少人热爱着这个圈子，新人老人都有\n说实在的，我其实对二次元相关的了解不深\n看过的番剧屈指可数，反正就是个臭打游戏而且也没打多好的人\n但我入东方的圈子少说也有四五年了，是什么让我能一直待在这个圈子呢\n我觉得是整个氛围\n整个东方的世界观并不是由某个主题创造的，而是由大家共同创建的\n这就很好啊，感觉就跟开源的魅力一样，大家都可以有所作为\n整个圈子为大家搭建了一个舞台，谁都可以表演自己的一技之长\n这个圈子真挺不错的，也难怪整个圈子活了近20年了\n虽然圈子大了也啥人都有，但这么多年了，也算是啥风雨都经历过了吧\n热爱真的可以激发人的斗志\n像我找的那俩上海本地人的那个设摊的同学，我是真的佩服\n当然更多的也是羡慕，才高中就有些建树\n我从小也一直想干点啥，小学开始就想自己做一款游戏\n于是小学开始接触了一点点的RPG Maker\n(那时候还是用Ruby做脚本语言)\n当然，也没学进去多少\n初中在看Java，高中没时间，也只能折腾折腾计算器了\n当然，我现在也还是想着自己做一款游戏\n但相比那些年纪青青就有这么多成就的人总感觉我这个年纪能干成是应该的\n氦，或许跟教育也有关系吧，我是小县城出来的人，大家都是传统的人\n父辈还是希望我走一条传统的路，向上爬吧\n所以现在我也慢慢地承认各种平庸\n包括我自己的平庸，家庭的平庸，小县城的平庸\n(我也不是说我家庭不够好，小县城不够好之类的，仅仅是一些观念上)\n那些年纪青青有所建树的人不仅仅是他们自己很有想法\n而且他们身边的人也会帮助他们实现理想\n(貌似讲得太偏了)\n总之，这次上海THO的行程真的很不错，也算我难得会记忆的一天\n(我一般记性很差的)\n以后有THO我估计也会常去，人还是喜欢热闹点的地方\n","date":"2023-08-21T11:05:18Z","permalink":"https://mlacookie.github.io/article/posts/%E4%B8%8At%E7%9C%9F%E7%9A%84%E5%A4%AA%E5%A5%BD%E4%BA%86/","title":"上T真的太好了"},{"content":"前言\r突发奇想，想研究下IL语言\n本来以为会挺难的，结果发现貌似还行\n注意：本博客不打算详细讲解IL的原理之类的\n只是大概讲讲我研究的成果\n这里推荐两篇博客，他们那讲的更详细\n一个是来自Zery的IL指令详细\n另一个是布鲁克石的30分钟？不需要，轻松读懂IL\n\u0026lt;0x01\u0026gt; 什么是IL语言\r这就要从.net的运行结构开始讲起\n.net框架下面有好多们语言，但.net的运行时就一个\n所以这个运行时怎么能同时跑这么多的语言，是每个语言一个实现吗？\n肯定不是，这太麻烦了\n所以.net编译器会将它托管的语言先编译成一个中间语言，这个中间语言就是IL\n.net运行时会动态解释这个IL文件(这个跟Java差不多的流程)\n通过IL语言，.net实现了多语言共用一个运行时，也让不同语言能非常方便地整合进一个项目\n(反正编译出来的东西都是一样的)\n这个具体的过程可以看本叫《CLR via C#》(俗称C#圣经😂，最近在看)\n里面讲到过\n\u0026lt;0x02\u0026gt; 怎么查看IL语言\r第一种方法，ILDasm\nVisual Studio自带的反汇编软件(但我没找到)\n参考微软的文档就好\n第二种方法，sharplab.io\n这是个给C#用的实时转换成IL的网页工具\n这个还可以转换成编译器优化后的代码甚至是给CLR执行的汇编代码\n在线执行也是可以的，而且它可以列出所写代码的所有语法点并列出微软的说明文档链接\n不过毕竟是网页工具，并不完全支持所有的FCL库，所以可能有些库用不了\n总之这是个非常方便的工具，有什么小测试都可以在上面测试\n第三种方法，ILSpy\n这个工具也挺好用的，有支持Visual Studio的插件\n装上就可以写代码的时候直接反编译\n(@ 23-08-22)\n只是看核心库源代码的话还有一种办法，官方的源代码网站\n具体我没怎么用过，就先补充在这里吧\n我现在在用第二种和第三种方法\n平时做小测试网页工具用用就好了\n但在研究.net的底层api的时候就需要用ILSpy了\n(虽然.net core开源了，但自己找效率确实低，反编译哪里不会点哪里)\n\u0026lt;0x03\u0026gt; C#的编译过程\rC#编译到IL分两步\n第一步：编译器优化代码\n第二步：编译成IL\n在第一步中，编译器将对原代码进行彻头彻尾的改造\n比方说代码有一句int a = 5;，在优化过程中会改名为int num = 5;\n还有就是将一些编译期就知道结果的值计算出来，比如\u0026quot;a\u0026quot;+\u0026quot;b\u0026quot;就会直接优化成\u0026quot;ab\u0026quot; 在这个过程中，编译器还会加上非常多的，用于跟CLR通信的指令\n这些指令主要是指导CLR正确执行代码，具体我也不是很熟，以后再说\n第二步编译成IL就看靠编译器了\n这两步具体实现可以看Roslyn的源码，在GitHub上\n(我还没开始研究这玩意)\n另外还有就是C#编译有两种模式\nDebug和Release\n前者编译出的代码并不是最优化的，里面会有很多的nop指令\n(就是执行这条指令啥也不干，方便调试打断点用的)\n后者是用来发布的，编译出来的代码是经过编译器完全优化的\n\u0026lt;0x04\u0026gt; 开始研究IL\r首先先是一段简单的代码\nusing System; public class C { public void M() { int a=3; string str=\u0026#34;abc\u0026#34;; Console.WriteLine(a+str); } } 看看它编译后的IL语言(Debug下编译)\n.assembly _ { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) .custom instance void [System.Runtime]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4e 6f 6e 45 78 63 65 70 74 69 6f 6e 54 68 72 6f 77 73 01 ) .custom instance void [System.Runtime]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [System.Runtime]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) .permissionset reqmin = ( 2e 01 80 8a 53 79 73 74 65 6d 2e 53 65 63 75 72 69 74 79 2e 50 65 72 6d 69 73 73 69 6f 6e 73 2e 53 65 63 75 72 69 74 79 50 65 72 6d 69 73 73 69 6f 6e 41 74 74 72 69 62 75 74 65 2c 20 53 79 73 74 65 6d 2e 52 75 6e 74 69 6d 65 2c 20 56 65 72 73 69 6f 6e 3d 37 2e 30 2e 30 2e 30 2c 20 43 75 6c 74 75 72 65 3d 6e 65 75 74 72 61 6c 2c 20 50 75 62 6c 69 63 4b 65 79 54 6f 6b 65 6e 3d 62 30 33 66 35 66 37 66 31 31 64 35 30 61 33 61 15 01 54 02 10 53 6b 69 70 56 65 72 69 66 69 63 61 74 69 6f 6e 01 ) .hash algorithm 0x00008004 // SHA1 .ver 0:0:0:0 } .class private auto ansi \u0026#39;\u0026lt;Module\u0026gt;\u0026#39; { } // end of class \u0026lt;Module\u0026gt; .class public auto ansi beforefieldinit C extends [System.Runtime]System.Object { // Methods .method public hidebysig instance void M () cil managed { // Method begins at RVA 0x206c // Code size 29 (0x1d) .maxstack 2 .locals init ( [0] int32 a, [1] string str ) IL_0000: nop IL_0001: ldc.i4.3 IL_0002: stloc.0 IL_0003: ldstr \u0026#34;abc\u0026#34; IL_0008: stloc.1 IL_0009: ldloca.s 0 IL_000b: call instance string [System.Runtime]System.Int32::ToString() IL_0010: ldloc.1 IL_0011: call string [System.Runtime]System.String::Concat(string, string) IL_0016: call void [System.Console]System.Console::WriteLine(string) IL_001b: nop IL_001c: ret } // end of method C::M .method public hidebysig specialname rtspecialname instance void .ctor () cil managed { // Method begins at RVA 0x2095 // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Object::.ctor() IL_0006: nop IL_0007: ret } // end of method C::.ctor } // end of class C .class private auto ansi sealed beforefieldinit Microsoft.CodeAnalysis.EmbeddedAttribute extends [System.Runtime]System.Attribute { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void Microsoft.CodeAnalysis.EmbeddedAttribute::.ctor() = ( 01 00 00 00 ) // Methods .method public hidebysig specialname rtspecialname instance void .ctor () cil managed { // Method begins at RVA 0x2050 // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Attribute::.ctor() IL_0006: nop IL_0007: ret } // end of method EmbeddedAttribute::.ctor } // end of class Microsoft.CodeAnalysis.EmbeddedAttribute .class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.RefSafetyRulesAttribute extends [System.Runtime]System.Attribute { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void Microsoft.CodeAnalysis.EmbeddedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void [System.Runtime]System.AttributeUsageAttribute::.ctor(valuetype [System.Runtime]System.AttributeTargets) = ( 01 00 02 00 00 00 02 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00 54 02 09 49 6e 68 65 72 69 74 65 64 00 ) // Fields .field public initonly int32 Version // Methods .method public hidebysig specialname rtspecialname instance void .ctor ( int32 \u0026#39;\u0026#39; ) cil managed { // Method begins at RVA 0x2059 // Code size 15 (0xf) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Attribute::.ctor() IL_0006: nop IL_0007: ldarg.0 IL_0008: ldarg.1 IL_0009: stfld int32 System.Runtime.CompilerServices.RefSafetyRulesAttribute::Version IL_000e: ret } // end of method RefSafetyRulesAttribute::.ctor } // end of class System.Runtime.CompilerServices.RefSafetyRulesAttribute (注释是Sharpio自动生成的)\n额，看着是有点多，但其实很多只是自动生成的代码\n如果只关注我们自己方法实现的话，实际只要看这么点就好\n.method public hidebysig instance void M () cil managed //方法签名 { .maxstack 2 //定义计算栈大小 .locals init ( [0] int32 a, [1] string str ) //初始化变量链表 IL_0000: nop //啥也不干(Debug下编译) IL_0001: ldc.i4.3 //初始化int32的数值3，并加载到计算栈上 IL_0002: stloc.0 //弹出一个栈顶元素，并存储到变量列表的0号位上(就是变量a) IL_0003: ldstr \u0026#34;abc\u0026#34; //初始化字符串\u0026#34;abc\u0026#34;，并加载到计算栈上 IL_0008: stloc.1 //弹出栈顶元素，存储到变量链表1号上(变量str) IL_0009: ldloca.s 0 //加载变量列表0号位(变量a)到计算栈上 IL_000b: call instance string [System.Runtime]System.Int32::ToString() //调用方法 IL_0010: ldloc.1 //加载变量列表1号位(变量str)到计算栈上 IL_0011: call string [System.Runtime]System.String::Concat(string, string) //调用方法，有几个参就弹出几个栈顶元素，返回值再压入栈 IL_0016: call void [System.Console]System.Console::WriteLine(string) //调用方法 IL_001b: nop //啥也不干 IL_001c: ret //方法结束，返回 } (已经打上了我自己的注释了)\n所以其实也不是挺难的，就是IL的指令差不多都是简写，乍一看确实不明觉厉\n(所以会看IL就可以出去装逼了😅) IL还有很多指令，具体可以看我最上面推荐的两篇博客\n这里的计算栈其实就是个可以放任何类型的栈，计算用的\n具体的CLR执行细节可以看看《CLR via C#》讲的很详细\n","date":"2023-08-03T02:44:36Z","permalink":"https://mlacookie.github.io/article/posts/%E6%B5%85%E8%B0%88c%23%E8%BD%ACil%E8%AF%AD%E8%A8%80/","title":"浅谈C#转IL语言"},{"content":"\u0026lt;0x00\u0026gt; MVVM模型介绍\rMVVM模型并不是一个编程的语法，而是一种设计思路\n整体分三块(M/V/VM)\nM(Model)指数据模型，差不多就是程序的后端部分\nV(View)指界面，就是程序前端\nVM(View Model)，这个不大好翻译，其实就是负责前后端连接\n这样做有什么好处\n简单说就是低耦合高内聚(网上都这么说的)\n换句话说就是修改时更加的灵活，架构更加明白\nMVVM模型是从MVC模型发展过来的，主要解决的就是开发过程中代码结构混乱的问题\n比方说开发一个项目，分前端后端，如果不采用这些设计思路，很可能两人各搞各的\n要连接前后端，既可以是前端控制后端数据，也可以是后端修改前端显示\n这样势必会造成整个项目的混乱，不好管理\n所以MVVM模型引入了VM作为前后端的中间层\n前端的V可以通过VM修改M，后端的M也可以通过VM通知前端的V要界面更新\n这样的话，前后端本身就差不多分离了，前后端开发互不干扰\n反正最后都是靠写一个VM连接在一起的，当然相应的代码量就多了\n总之，MVVM模型不是开发必须的，如果就一个人随便写写，那么肯定是怎么舒服怎么来的\n如果是稍微大一点的项目，不采用合适的开发模式，到时候管理代码有的受的\n\u0026lt;0x01\u0026gt; 如何在WPF中实现MVVM\rWPF里面不是有些.xaml的文件嘛，这些就是我们的V\n然后在整个工程中，我们还可以新建很多的.cs文件(这个看你用什么.net的语言)\n这些.cs文件就是我们的M和VM\n当然，为了区分方便，通常会在文件后面跟上后缀\n比如*M.cs代表这个文件描述的是一个数据模型\n*VM.cs代表这个文件描述的是一个VM\n反正怎么习惯怎么来就是\n在这篇博客里，我的文件命名没有这么这么规范\n因为就像之前说的，MVVM只是一种设计思路\n\u0026lt;0x02\u0026gt; 正式开始实现\r首先先分析我们的需求，就拿我们之前的计算器吧\n前端的实现我们已经有了，就是那个.xaml文件\n后端我们就要先分析下了，怎么搞一个计算器的后端\n首先我们先思考下一个计算器需要维护什么数据\n因为我们打算实现的就是个日常的计算器而不是图形计算器之类的东西\n所以肯定要维护一条当前的结果\n然后还要一个标志符来保存当前选定的运算\n同时还要有个flag来表明正在计算\n最后还要维护一个显示的值\n所以总共是要维护4条数据\n所以对我们的计算器后端文件如下\n//Calculator.cs //常见的引用 namespace WPFTest { public class Calculator { //这里按道理应该用private，通过对象方法调用这些变量，这里偷下懒 internal bool flag = false; //表示正在计算 internal int? calculate = null; //标识当前的运算符 internal double? ans = null; //存储当前的结果 internal string Display = \u0026#34;0\u0026#34;; //当前显示的值 public void Calculate() //计算方法 { switch (calculate) { case 1: ans += Double.Parse(Display); break; case 2: ans -= Double.Parse(Display); break; case 3: ans *= Double.Parse(Display); break; case 4: ans /= Double.Parse(Display); break; } } } } 接下来就是来写我们的VM部分\n我这个写得比较繁琐，但就是那个意思\n//ViewModel.cs //常见的引用 namespace WPFTest { //要实现接口INotifyPropertyChanged public class ViewModel : INotifyPropertyChanged { //实现接口的要求，看不懂没关系，这么写就好 public event PropertyChangedEventHandler PropertyChanged; private void NotifyPropertyChanged(string propertyName) { PropertyChangedEventHandler handler = PropertyChanged; if(handler != null) handler(this, new PropertyChangedEventArgs(propertyName)); } //声明一个Calculator对象 private readonly Calculator _calculator = new Calculator(); //声明一个Display属性，关键啊 public string Display { get { return _calculator.Display; //定义get，挺正常的写法 } set { _calculator.Display = value; NotifyPropertyChanged(\u0026#34;Display\u0026#34;); //定义set，最后调用的方法通知属性已更改，让前端更新显示 } } public void MinusSign_Click() //减法的实现 { if (_calculator.flag) { if (Display[0] == \u0026#39;-\u0026#39;) { Display = Display.Substring(1, Display.Length - 1); } else { Display = \u0026#34;-\u0026#34; + Display; } } } //后面方法的实现略 public ICommand ButtonMinusSign //将减法方法声明成属性 { get { return new RelayCommand(MinusSign_Click); //RelayCommand后面讲 } } //后面的方法属性声明略 } } Display要声明成属性的样式，因为xaml里面能绑定的量要是属性\n所以后面的按钮方法都要声明成属性，这样才能在xaml里面绑定\n当然这里还出现了两个新东西\n一个是接口INotifyPropertyChanged，还有RelayCommand\nINotifyPropertyChanged字面意思就是通知属性更改\n就是说这个类里面有属性在更改时需要通知前端，让前端显示的东西也跟着改\n这个接口要求实现一个通知方法，反正就按上面的抄就好了\n(大体的原理就是发起一个事件，传回去，让前端知道有东西变了，再回来看)\nRelayCommand是自己实现的类，代码如下\n//RelayCommand.cs //常见的声明 namespace WPFTest { //实现ICommand接口 internal class RelayCommand : ICommand { //一个只读的Action属性，存储指令 public Action ExecuteAction { get; } public event EventHandler CanExecuteChanged; //构造函数 public RelayCommand(Action executeAction) { ExecuteAction = executeAction; } //表示能不能执行(我们这就默认能执行) public bool CanExecute(object parameter) { return true; } //调用方法 public void Execute(object parameter) { ExecuteAction(); } } } 就是这样，本质就是用泛型委托打包了个方法\n这个类也方便我们把方法打包成一个属性，好绑定到xaml中\n最后终于是我们的前端界面了\n其实多的不用改\n\u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; d:DataContext=\u0026#34;{d:DesignInstance Type=local:ViewModel}\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;!--这里指定了DataContext，让xaml能找到对应的属性--\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;6\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Border Name=\u0026#34;border\u0026#34; Background=\u0026#34;#241238\u0026#34; CornerRadius=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{TemplateBinding Content}\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;ControlTemplate.Triggers\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsMouseOver\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;#190D24\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsPressed\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;Black\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;/ControlTemplate.Triggers\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; MouseMove=\u0026#34;Border_MouseMove\u0026#34; Margin=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026#34;0\u0026#34; Orientation=\u0026#34;Horizontal\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34;\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Minimize\u0026#34; Click=\u0026#34;Button_Minimize_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0DC4E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Close\u0026#34; Click=\u0026#34;Button_Close_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0443E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;TextBlock Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;{Binding Display}\u0026#34; FontSize=\u0026#34;28\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34; Foreground=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;!--Text这里绑定的是显示的内容--\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Command=\u0026#34;{Binding ButtonMinusSign}\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;!--Command这里绑定的就是按钮的指令--\u0026gt; \u0026lt;!--后面的Button就不写了--\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; 其实就打注释的那三处要变，别的都不用改\n\u0026lt;0x03\u0026gt; MVVM模型到底有什么用\r说实在的，我刚学完这模型我也是说这玩意有啥用\n甚至觉得我是不是少看了些什么\n因为从逻辑上，这么写代码，代码量多了，但功能都没变过\n就感觉这么写很多余\n但实际上，我思考了好一阵(也是这篇博客拖这么久写完的原因)\n这个项目太小了，体现不出来\n想象一个稍微大点的项目，前后端分别开发的\n假设最终就两个主要的文件，一个前端，一个后端\n如果说后端突然抽风要改方法名，那前端也得跟着改(这就是耦合的情况)\n但如果用MVVM模型，在前后端之间再加层\u0026quot;胶水\u0026quot;层\n这样当后端改名的时候，\u0026ldquo;胶水\u0026quot;层的名字没改，前端就不用改，提高了效率\n(这样也叫解耦)\n别的好处我也很难讲了，毕竟目前我的开发经验不多\n正如我最前面写的，这个只是个思想，并不是什么语法之类的\n(总算写完了)\n","date":"2023-07-22T17:39:25Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-mvvm%E6%A8%A1%E5%9E%8B/","title":"WPF学习笔记03-MVVM模型"},{"content":"\u0026lt;0x00\u0026gt; WPF的界面美化挺方便的\r就研究了一小时不到，成功让计算器的UI上升了一个档次\n先看成果(因为相较于之前的界面确实帅多了)\n现代多了\n(为了显示效果改了下比例)\n咱们一块块慢慢讲\n\u0026lt;0x01\u0026gt; 如何实现自定义窗口控件与圆角窗口\r首先看这个界面，比较特殊的就是这个窗口有圆角\n而且右上角的按钮不是Windows的默认样式\n(红色的按钮是关闭，黄色的是最小化窗口)\n要做到这一点，我们要让窗口运行在无边框的模式下\n但运行在无边框模式下后，原先的窗口控件也没有了\n所以要自己写按钮实现窗口关闭和窗口最小化的功能\n(窗口最大化也差不多的逻辑，但这里不需要实现)\n无边框窗口\r首先要设置个无边框的窗口\n我们需要在\u0026lt;Window\u0026gt;标签里面加上WindowStyle=\u0026quot;None\u0026quot;就可以实现无边框的窗口了\n(@ 23-07-19)\n其实更正规的做法应该是用WindowChrome，当时不大会，这个只能说是个下策\n这个方法本质上是抛弃了非工作区的控件而在工作区重写这些窗口控件，效率有点低\n\u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;Window/\u0026gt; (差不多就这样，没讲的属性后面讲)\n这样，我们确实获得了一个无边框的窗口\n但这样有几个问题\n第一，窗口的圆角无法调整\n第二，窗口不能拖动\n解决第一个问题\r这意味着我们要自己写一个窗口实现\n(其实不难)\n系统的窗口相当于最下面的图层\n现在这个窗口不能满足我们的需求，所以我们要先隐藏自带的窗口\n在\u0026lt;Window\u0026gt;标签里面加上AllowsTransparency=\u0026quot;True\u0026quot;和Background=\u0026quot;Transparent\u0026quot;\n这两条属性表示允许窗口透明并设置窗口背景为透明\n下面我们要自己写一个背景来代替原来的窗口背景\n我们之前不是拿一个\u0026lt;Grid\u0026gt;包裹所有的控件吗\n既然是背景，那层级肯定是比这个Grid更高的\n所以只需要在\u0026lt;Grid\u0026gt;外面再套个\u0026lt;Border\u0026gt;就好\n(\u0026lt;Border\u0026gt;可以简单理解为绘制一个矩形)\n\u0026lt;!--差不多像这样--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Border ...\u0026gt; \u0026lt;Grid ...\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; \u0026lt;Border\u0026gt;也可以设置不少的属性\n为了实现窗口圆角，设置下CornerRadius就好\n解决第二个问题\r在原生的窗口中，窗口的移动是靠上面的那一条的\n相当于窗口移动事件是绑定在那一条控件上的\n现在我们隐藏了，所以要自己去绑定这个窗口移动事件\n现在刚好写了个\u0026lt;Border\u0026gt;，这个可以绑定窗口移动事件\n在\u0026lt;Border\u0026gt;绑定MouseMove事件(就是添加个属性)\n这个相当于之前给Button绑定Click事件，要在对应.cs里面实现功能\nprivate void Border_MouseMove(object sender, MouseEventArgs e) { if (e.LeftButton == MouseButtonState.Pressed) { this.DragMove(); } } 加上这段代码就好\n现在这个窗口就能拖动了\n自定义窗口控件按钮\r本质上就是自己写个按钮，一个用来关闭程序，一个用来最小化\n(当然为了能放下这俩按钮还需要对页面布局做个小改动，这里就不写了)\n直接贴代码\n//关闭窗口 private void Button_Close_Click(object sender, RoutedEventArgs e) { this.Close(); } //最小化窗口 private void Button_Minimize_Click(object sender, RoutedEventArgs e) { this.WindowState = WindowState.Minimized; } 这两个方法绑定到对应的按钮就好\n\u0026lt;0x02\u0026gt; 如何实现圆角的按钮\r要实现圆角的按钮，我们需要重写按钮的绘制方法\n在xaml中，这个重写其实也挺简单的，我们仅需更改按钮的模板\n更改模板的方法有两种，先讲怎么更改单个按钮的模板\n(关闭窗口和最小化窗口的按钮样式就是这么实现的)\n\u0026lt;Button ...\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;!--具体的实现--\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; 在具体的实现里面写上绘制的样式就行了\n如果有很多的按钮需要更改为一个统一的样式，我们需要在\u0026lt;Style\u0026gt;中更改模板\n\u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;!--其他Setter--\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;!--具体的实现--\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; 注意，如果模板要绑定属性，TargetType=\u0026quot;Button\u0026quot;不能省\n({TemplateBinding Content}就是个绑定的语法，相当于拷贝Button.Content的内容)\n(具体看原代码吧，绑定确实不大好解释)\n更改过模板后，原来的触发器也给替换掉了，要我们自己再写一套\n(就是比方说鼠标放按钮上，按钮的颜色变深一点之类的)\n这个就要在\u0026lt;ControlTemplate\u0026gt;块中加上\u0026lt;ControlTemplate.Triggers\u0026gt;块\n再在里面写上若干\u0026lt;Trigger\u0026gt;即可\n\u0026lt;Trigger\u0026gt;就用来控制前端的显示，不管后端的\n\u0026lt;Trigger\u0026gt;中有Property(设置触发器类型)和Value(设置触发值)\n常用的Property有IsMouseOn(鼠标在不在上面)和IsPressed(鼠标有没有按下)\n\u0026lt;Trigger\u0026gt;块中通过\u0026lt;Setter\u0026gt;来设置样式\n这里的\u0026lt;Setter\u0026gt;需要加上TargetName(因为可能有好几个需要绘制的东西)\n\u0026lt;0x03\u0026gt; 如何实现背景的色彩渐变\r添加色彩渐变很简单\n\u0026lt;Border\u0026gt;块中加上这些代码即可\n\u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; 其中\u0026lt;LinearGradientBrush\u0026gt;指定了线性渐变\nStartPoint与EndPoint指定了起止点，\u0026quot;0,0\u0026quot;表示左上角，\u0026quot;0,1\u0026quot;表示左下角\n\u0026lt;GradientStop\u0026gt;中可以指定渐变的颜色，Offset相当于颜色在渐变条上的位置\n(如果用过些图像处理工具应该是能理解Offset的功能的)\n\u0026lt;0x04\u0026gt; 绘制窗口阴影\r因为我们已经把原生的窗口干掉了嘛，所以窗口阴影也没了\n没窗口阴影的话总是看着有些违和\n添加窗口阴影也很简单\n\u0026lt;Border\u0026gt;块中加上这些代码即可\n\u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; 在\u0026lt;Border\u0026gt;中也要调整下Margin属性，不然阴影可能显示不出\n附录\rMainWindow.xaml.cs的代码就不贴了，基本没什么改动\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;6\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Border Name=\u0026#34;border\u0026#34; Background=\u0026#34;#241238\u0026#34; CornerRadius=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{TemplateBinding Content}\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;ControlTemplate.Triggers\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsMouseOver\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;#190D24\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsPressed\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;Black\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;/ControlTemplate.Triggers\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; MouseMove=\u0026#34;Border_MouseMove\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026#34;0\u0026#34; Orientation=\u0026#34;Horizontal\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34;\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Minimize\u0026#34; Click=\u0026#34;Button_Minimize_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0DC4E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Close\u0026#34; Click=\u0026#34;Button_Close_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0443E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;TextBlock Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;0\u0026#34; FontSize=\u0026#34;28\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34; Foreground=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Click=\u0026#34;Button_MinusSign_Click\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Clear\u0026#34; Click=\u0026#34;Button_Clear_Click\u0026#34; Content=\u0026#34;CE\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Backspace\u0026#34; Click=\u0026#34;Button_Backspace_Click\u0026#34; Content=\u0026#34;←\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num9\u0026#34; Click=\u0026#34;Button_Num9_Click\u0026#34; Content=\u0026#34;9\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num8\u0026#34; Click=\u0026#34;Button_Num8_Click\u0026#34; Content=\u0026#34;8\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num7\u0026#34; Click=\u0026#34;Button_Num7_Click\u0026#34; Content=\u0026#34;7\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num6\u0026#34; Click=\u0026#34;Button_Num6_Click\u0026#34; Content=\u0026#34;6\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num5\u0026#34; Click=\u0026#34;Button_Num5_Click\u0026#34; Content=\u0026#34;5\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num4\u0026#34; Click=\u0026#34;Button_Num4_Click\u0026#34; Content=\u0026#34;4\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num3\u0026#34; Click=\u0026#34;Button_Num3_Click\u0026#34; Content=\u0026#34;3\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num2\u0026#34; Click=\u0026#34;Button_Num2_Click\u0026#34; Content=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num1\u0026#34; Click=\u0026#34;Button_Num1_Click\u0026#34; Content=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num0\u0026#34; Click=\u0026#34;Button_Num0_Click\u0026#34; Content=\u0026#34;0\u0026#34; Grid.ColumnSpan=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Dot\u0026#34; Click=\u0026#34;Button_Dot_Click\u0026#34; Content=\u0026#34;.\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Div\u0026#34; Click=\u0026#34;Button_Div_Click\u0026#34; Content=\u0026#34;/\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Mul\u0026#34; Click=\u0026#34;Button_Mul_Click\u0026#34; Content=\u0026#34;*\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Sub\u0026#34; Click=\u0026#34;Button_Sub_Click\u0026#34; Content=\u0026#34;-\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Add\u0026#34; Click=\u0026#34;Button_Add_Click\u0026#34; Content=\u0026#34;+\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Equal\u0026#34; Click=\u0026#34;Button_Equal_Click\u0026#34; Content=\u0026#34;=\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; (经典写博客耗时比写代码多😂)\n","date":"2023-07-17T01:04:58Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96%E8%AE%A1%E7%AE%97%E5%99%A8/","title":"WPF学习笔记02-简单美化计算器"},{"content":"\u0026lt;0x00\u0026gt; 我为何选择WPF\r(@ 23-08-25)\n慢慢学了一个月，总算知道为啥现在用WPF的个人项目不多了\n写简单的UI确实非常方便，但如果要用些现代些的设计就很烦了\n非常容易出现些神秘问题\n这个我也说不明白，大概就是因为之前看到有些项目的窗口就是WPF写的吧\n一定要找个理由就是WPF的支持丰富\n作为一个老UI框架，教程满天飞，更重要的是，用WPF仍可以设计出现代的UI\n(而且相比那些electron框架来说性能更好，只要不搞跨平台)\n目前在Windows下，微软这常见的有四套UI框架\n分别是：WinFrom、WPF、WinUI3、XAUI\nWinFrom实在是老，做一些效果动画会比较费力\nWPF虽然也挺老的，但支持的特性足够做些不错的UI了\nWinUI3新是新，但教程不多，文档支持也比较神秘\nXAUI能跨平台，但微软特色，永不推广，而且也比较新，文档比较神秘\n从WPF开始，微软的UI框架都是要写.xaml的\n所以学会WPF之后，迁移到微软更新的UI框架的学习成本是相对低的\n目前我体验下来WPF算是很好入门的了，只需要会一门.net框架下的语言就可以入门\nxaml语法也不难，可以说看多了也会了\n而且微软的看家本领，UI的可视化开发(Visual Studio)，这对效率提升真的很有帮助\n这篇文章的代码来自我自己随便搞的简易计算器\n(整个程序就花了一个小时写完，足见WPF是多方便)\n\u0026lt;0x01\u0026gt; WPF的典型结构\r我这里创建的是基于C#的WPF项目\n创建完我们可以看到如图的项目结构\n差不多就是一个.xaml文件下套.cs文件\n其中在App.xaml文件中，定义了这个应用的基本信息(主要就是启动窗口是哪一个)\nMainWindows.xaml定义了窗口的样式(这个的编辑界面就是一半实时预览窗口，一半是代码编辑器)\n下面的.cs文件可以说描述程序的行为\n简单来说就是.xaml文件管前端(界面)，.cs文件管后端(行为)\n具体的东西后面再讲\n\u0026lt;0x02\u0026gt; XAML的简单语法\rxaml这玩意就是参考xml语法的\n如果能看懂xml甚至是html也能看懂xaml\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;800\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;TextBlock Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;0\u0026#34; FontSize=\u0026#34;30\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Click=\u0026#34;Button_MinusSign_Click\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Clear\u0026#34; Click=\u0026#34;Button_Clear_Click\u0026#34; Content=\u0026#34;CE\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Backspace\u0026#34; Click=\u0026#34;Button_Backspace_Click\u0026#34; Content=\u0026#34;←\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num9\u0026#34; Click=\u0026#34;Button_Num9_Click\u0026#34; Content=\u0026#34;9\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num8\u0026#34; Click=\u0026#34;Button_Num8_Click\u0026#34; Content=\u0026#34;8\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num7\u0026#34; Click=\u0026#34;Button_Num7_Click\u0026#34; Content=\u0026#34;7\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num6\u0026#34; Click=\u0026#34;Button_Num6_Click\u0026#34; Content=\u0026#34;6\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num5\u0026#34; Click=\u0026#34;Button_Num5_Click\u0026#34; Content=\u0026#34;5\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num4\u0026#34; Click=\u0026#34;Button_Num4_Click\u0026#34; Content=\u0026#34;4\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num3\u0026#34; Click=\u0026#34;Button_Num3_Click\u0026#34; Content=\u0026#34;3\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num2\u0026#34; Click=\u0026#34;Button_Num2_Click\u0026#34; Content=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num1\u0026#34; Click=\u0026#34;Button_Num1_Click\u0026#34; Content=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num0\u0026#34; Click=\u0026#34;Button_Num0_Click\u0026#34; Content=\u0026#34;0\u0026#34; Grid.ColumnSpan=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Dot\u0026#34; Click=\u0026#34;Button_Dot_Click\u0026#34; Content=\u0026#34;.\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Div\u0026#34; Click=\u0026#34;Button_Div_Click\u0026#34; Content=\u0026#34;/\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Mul\u0026#34; Click=\u0026#34;Button_Mul_Click\u0026#34; Content=\u0026#34;*\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Sub\u0026#34; Click=\u0026#34;Button_Sub_Click\u0026#34; Content=\u0026#34;-\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Add\u0026#34; Click=\u0026#34;Button_Add_Click\u0026#34; Content=\u0026#34;+\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Equal\u0026#34; Click=\u0026#34;Button_Equal_Click\u0026#34; Content=\u0026#34;=\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; (为了代码高亮正常工作，这里的代码设置为xml的高亮格式)\n一块块掰碎讲\n声明部分\r就是最上面一坨不知道什么东西的部分，随便写写的话根本不需要知道这些是啥，别动就好\n(因为我目前也不是很懂这些)\n\u0026lt;Window.Resources\u0026gt;\r这里面我就定义了个Button类型的Style\n其实就是规定了Button的一些默认参数\n在下面写Button的时候就不用一个个都写这些东西了\nStyle里面定义了按钮到界面边界的距离(Margin)有5单位\n字体大小(FontSize)为30个单位\n(在WPF里，并不是以像素为单位，而是按DPI来确定实际像素单位大小)\n\u0026lt;Style\u0026gt;里面要指定设置的类型(TargetType)\n在\u0026lt;Style\u0026gt;块中，用\u0026lt;Setter\u0026gt;标签来设置类型下面的属性\n\u0026lt;Setter\u0026gt;标签里面Property选择属性，Value选择值\n\u0026lt;Grid\u0026gt;\r在WPF中，有两种常用的界面布局\n分别是：网格布局(\u0026lt;Grid\u0026gt;)和栈布局(\u0026lt;StackPanel\u0026gt;)\n\u0026lt;Grid\u0026gt;可以把一块区域分割成一个网格，网格里面可以塞控件\n\u0026lt;StackPanel\u0026gt;就是个栈，所有控件从上到下(从左到右)排列\n基本上用这两种布局的互相嵌套能解决绝大多数的布局\n我这里的布局选择了\u0026lt;Grid\u0026gt;里面再套一个\u0026lt;Grid\u0026gt;\n具体实现\r在\u0026lt;Grid.RowDefinitions\u0026gt;块里面塞两个\u0026lt;RowDefinition/\u0026gt;把Grid分成两行\n(塞几个\u0026lt;RowDefinition/\u0026gt;就是有几行，列同理)\n在一个\u0026lt;RowDefinition/\u0026gt;里加入Height=\u0026quot;auto\u0026quot;表示第一行的高度随内容改变\n(就是跟着第一行的控件高度走)\n然后正式往Grid网格里面塞控件，先第一行\n首先是再塞了个\u0026lt;Grid\u0026gt;，然后在里面塞了个\u0026lt;TextBlock\u0026gt;\n其中，Grid.Row可以指定控件所在的网格行号，列同理\n并定义了一系列的属性参数\n(Name属性就是给.cs调用的对象名，HorizontalAlignment是水平对正方式，设置为右对齐)\n(不是很懂我当时写的逻辑，其实不用多写个\u0026lt;Grid\u0026gt;，直接塞\u0026lt;TextBlock\u0026gt;就好)\n第二行，塞了个\u0026lt;Grid\u0026gt;，并定义出5*4的网格\n下面就是一大堆的按键定义，相对比较无趣\n值得说道的是Click属性，这个会指向对应.cs的一个具体的方法名，实现前后端的融合\n(具体看后端实现就可以了)\n还有按钮0多了个Grid.ColumnSpan=\u0026quot;2\u0026quot;，这个就是让这个按钮可以跨两列显示\n由于有之前的\u0026lt;Style\u0026gt;的定义，所有的按钮都自带字体大小30单位，间距5单位的属性\n这样，我们成功整出了一个简单的计算器界面\n长这样的\n\u0026lt;0x03\u0026gt; 与C#后端的结合\r(@ 23-08-14)\n实际上这样并不是搞后端，这些都是再定义前端的行为\n具体搞后端可以看我之后写的讲MVVM设计模型的博客\n但如果项目很小的话这样搞也没问题的\n与C#后端的结合可以说非常简单，就是调用和更改控件对象的成员值就可以\n还记得我们已经在.xaml中为一些控件添加了Name属性吗\n这些Name属性是实现前后端融合的关键\n//等于号按键点击事件的实现逻辑 private void Button_Equal_Click(object sender, RoutedEventArgs e) { if (flag \u0026amp;\u0026amp; ans != null) { Calculate(); flag = false; Answer.Text = ans.ToString(); calculate = null; } } 别的都不重要，还记得我们有一个\u0026lt;TextBlock\u0026gt;的Name属性设置为Answer吗\n通过Answer.Text可以直接访问并修改\u0026lt;TextBlock\u0026gt;的内容，非常方便\n(Answer.Text就是String类型)\n其他的控件也同理\n接下来要处理下按钮的点击事件了\n这个也非常简单，我们之前已经设置了每个按钮的Click属性\n接下来就是在对应的.cs中实现逻辑就好\n//大概的结构 namespace WPFTest { public partial class MainWindow : Window { //... private void Button_MinusSign_Click(object sender, RoutedEventArgs e); //加负号按钮的点击事件 private void Button_Clear_Click(object sender, RoutedEventArgs e); //清屏键的点击事件 private void Button_Backspace_Click(object sender, RoutedEventArgs e); //退格键的点击事件 private void Button_Num9_Click(object sender, RoutedEventArgs e); private void Button_Num8_Click(object sender, RoutedEventArgs e); private void Button_Num7_Click(object sender, RoutedEventArgs e); private void Button_Num6_Click(object sender, RoutedEventArgs e); private void Button_Num5_Click(object sender, RoutedEventArgs e); private void Button_Num4_Click(object sender, RoutedEventArgs e); private void Button_Num3_Click(object sender, RoutedEventArgs e); private void Button_Num2_Click(object sender, RoutedEventArgs e); private void Button_Num1_Click(object sender, RoutedEventArgs e); private void Button_Num0_Click(object sender, RoutedEventArgs e); //各个数字键的点击事件 private void Button_Dot_Click(object sender, RoutedEventArgs e); //小数点按键的点击事件 private void Button_Div_Click(object sender, RoutedEventArgs e); private void Button_Mul_Click(object sender, RoutedEventArgs e); private void Button_Sub_Click(object sender, RoutedEventArgs e); private void Button_Add_Click(object sender, RoutedEventArgs e); //+-*/键的点击事件 private void Button_Equal_Click(object sender, RoutedEventArgs e); //等于号的点击事件 } } 每个按钮的点击事件都相当于在C#中的一个方法\n点击一次就触发一次\n附录\r完整的MainWindow.xaml已经贴在上文了，这里就不再放了\n//MainWindow.xaml.cs using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes; namespace WPFTest { public partial class MainWindow : Window { bool flag = false; int? calculate = null; double? ans = null; public MainWindow() { InitializeComponent(); } private void Calculate() { switch (calculate) { case 1: ans += Double.Parse(Answer.Text); break; case 2: ans -= Double.Parse(Answer.Text); break; case 3: ans *= Double.Parse(Answer.Text); break; case 4: ans /= Double.Parse(Answer.Text); break; } } private void Button_MinusSign_Click(object sender, RoutedEventArgs e) { if (flag) { if (Answer.Text[0]==\u0026#39;-\u0026#39;) { Answer.Text = Answer.Text.Substring(1, Answer.Text.Length - 1); } else { Answer.Text = \u0026#34;-\u0026#34; + Answer.Text; } } } private void Button_Clear_Click(object sender, RoutedEventArgs e) { flag = false; calculate = null; ans = null; Answer.Text = \u0026#34;0\u0026#34;; } private void Button_Backspace_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text = Answer.Text.Substring(0, Answer.Text.Length - 1); if (Answer.Text.Length == 0) { flag = false; Answer.Text = \u0026#34;0\u0026#34;; } } } private void Button_Num9_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;9\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;9\u0026#34;; } } private void Button_Num8_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;8\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;8\u0026#34;; } } private void Button_Num7_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;7\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;7\u0026#34;; } } private void Button_Num6_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;6\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;6\u0026#34;; } } private void Button_Num5_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;5\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;5\u0026#34;; } } private void Button_Num4_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;4\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;4\u0026#34;; } } private void Button_Num3_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;3\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;3\u0026#34;; } } private void Button_Num2_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;2\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;2\u0026#34;; } } private void Button_Num1_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;1\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;1\u0026#34;; } } private void Button_Num0_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;0\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;0\u0026#34;; } } private void Button_Dot_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;.\u0026#34;; } } private void Button_Div_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 4; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 4; } } private void Button_Mul_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 3; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 3; } } private void Button_Sub_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 2; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 2; } } private void Button_Add_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 1; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 1; } } private void Button_Equal_Click(object sender, RoutedEventArgs e) { if (flag \u0026amp;\u0026amp; ans != null) { Calculate(); flag = false; Answer.Text = ans.ToString(); calculate = null; } } } } 逻辑就是随性写的，不保证完全没Bug，应该是没严重Bug的\n(所以也没写高精度的运算处理)\n(写这篇博客比我写代码的时间都长😂)\n","date":"2023-07-15T20:51:01Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/","title":"WPF学习笔记01-一个简单的计算器"},{"content":"前言\r一般来说离散的课设都是给一大堆题目然后自己选的\n我选的是合式公式的真值表和成真成假赋值\n算是里面相对难的\n(别的是真挺简单的)\n课设我是拿C#写的(人生苦短，还是用好用的语言吧)\n应该常用的.net版本都能跑起来吧，代码里没怎么用新特性\n(我用的是.net 6.0)\nC#的语法还是挺好懂得，用过C系语言看懂应该问题不大\n同样，可以在本文最后复制所有的原码\n(就一个文件，就不发本站的gitea了)\n(报告自己写写挺快的)\n\u0026lt;0x00\u0026gt; 如何解析合式公式\r在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的\n(所谓解析就是判断计算的优先级)\n比方说我们有公式1+2*3/(4-5)\n按运算优先级加上括号就是(1+((2*3)/(4-5)))\n所以说我们该如何让计算机按这样的优先级计算呢\n双栈法\n准备两个栈，一个是运算数栈，一个是运算符栈\n运算式在运算前先在首位各加括号(确保最后会栈空)\n然后从左向右遍历运算式\n遇到(时直接压入运算符栈，遇到数字压入运算数栈\n当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入\n如果不是，那么就先进行弹出操作\n每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中\n重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止\n如果遍历过程中遇到)，则反复进行弹出操作，直到弹出一个(为止\n(动画是用manim做的，头一次做)\n同样的思路也可以运用在合式公式上\n具体流程如下：\n1 给公式的左右套上括号 2 从左向右读取 3 如果遇到(，将(压入运算符栈后继续 4 如果遇到运算数，压入操作数栈后继续 5 如果遇到运算符，按照以下规则： a 如果运算符栈为空或栈顶元素优先级小于当前运算符，直接压入运算符栈 b 若遇到栈顶元素为┐(非)，需要弹出所有的连续┐(非)，弹出此运算符再弹出一个运算数，并将运算结果压回操作数栈 c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照5.a压入运算符栈 6 遇到)时，反复按照规则弹出，直到运算符栈顶为(，最后移除栈顶的( 7 读取完毕后，操作数栈留下的东西就是公式答案 这个就不再用动画演示了，本质上就是一般+-*/运算双栈法的变种\n唯一不一样的就是对于┐(非)要注意连续弹出问题\n因为┐(非)是一个右结合单目运算符，而且优先级最高\n如果不先处理调连续的┐(非)容易解析出问题\n所以要把连续的┐(非)全弹出，当作一个整体，这样才能出正确答案\n\u0026lt;0x01\u0026gt; 由双栈法构建运算树\r目前我们已经有方法解析合式公式了，但有一个问题\n我们的题目要求给出一个真值表\n如果每次计算我们都要先解析一遍合式公式的话，效率不会很高\n所以我们要用一种数据结构来保存计算的结构\n每个单一操作数数可以改变对应的真假指派(就是T/F)\n对于一个计算的过程，我们可以抽象成一个树\n所有的操作数都是树的叶子(最末端的节点)\n操作数由运算符连接，合成一个新节点\n如此嵌套，最后连接在一个根节点上\n每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果\n就是这么个结构\n怎么构建这棵树呢，其实之前的双栈法里就有这个答案\n我们仅需略微更改下代码，操作数栈不存储运算结果而是存储运算节点\n这样走一遍公式就相当于构建了一颗计算树\n最后只要存储根节点就好了\n\u0026lt;0x02\u0026gt; 逻辑实现\r按从低到高的优先级列出运算符的枚举类型\rpublic enum Operator//枚举运算符 { LeftBracket,//左括号 XNOR,//双条件运算符 Odds,//条件运算符 Or,//析取运算符 And,//合取运算符 Not,//取反运算符 } 定义计算树的计算节点类(仅列出定义)\rinternal class CalculateNode//定义计算节点 { CalculateNode? left;//运算符左边 CalculateNode? right;//运算符右边 Operator oper;//节点的运算符 bool ans;//该节点答案 internal CalculateNode(bool ans);//末节点构造方法 internal CalculateNode(CalculateNode? left, CalculateNode right, Operatoroper);//计算节点构造方法 static bool Odds(bool a, bool b);//单独定义条件运算符 bool Calculate(CalculateNode node);//从某节点递归计算 internal bool Calculate();//提供一个入口 internal void ChangeAns(bool ans);//改变末节点的值 } 可以看到，每个计算节点包含运算符，左边节点，右边节点，节点答案\n操作数节点仅有节点答案(所以左右节点的类型是可空类型)\n因为条件运算符没有现成的运算符，所以自己写一个\nCalculate(CalculateNode node)通过递归来遍历每个节点并给出每个节点的答案\nCalculate()专门给外部调用的，里面就一句return Calculate(this);\nChangeAns(bool ans)用来改变操作数的真假指派\n定义WellFormedFormula类(仅列出定义)\rpublic class WellFormedFormula { string formula;//原公式 Dictionary\u0026lt;string, CalculateNode\u0026gt; map;//以string方式索引所有节点 Dictionary\u0026lt;int, string\u0026gt; dic;//以int方式索引所有根节点的名字 CalculateNode root;//最终答案节点 bool[] truthTable;//真值表 private static bool IsOperator(char c);//判断是否为二元运算符 private static char OperatorToChar(Operator op);//运算符换成char private static Operator CharToOperator(char c);//char换成运算符 private bool Verify();//验证公式是否有效 private void Init();//初始化计算树 public WellFormedFormula(string formula);//构造方法 public bool Calculate(int n); public bool Calculate(Dictionary\u0026lt;string, bool\u0026gt; keyValuePairs);//单独计算用 private void CalculateAll();//全计算 public void ChangeFormula(string formula);//更改公式 public void ShowrTruthTable();//展示真值表 public void ShowFormula();//展示公式 public void ShowAllNode();//展示所有节点信息，用于调试 public void ShowTrueAssignment();//展示所有成真赋值 public void ShowFalseAssignment();//展示所有成假赋值 public void ShowDNF();//主析取范式 public void ShowCNF();//主合取范式 } 最关键的是Init()方法，别的实现不难\nprivate void Init()//初始化计算树(略去实现细节) { Verify();//验证 //获取所有的变量 //... //构建计算树 //... CalculateAll();//顺便把真值表给算了 } 在Init()中，先验证公式合法性(防输入错误)\n然后会先遍历遍公式，获取所有的变量名并创建操作数节点(末节点)\n然后再遍历一遍，构建计算树\n构建完成后，root指向根节点，map可以按节点名索引到对应的操作数节点\ndic可以按index索引到节点名字(方便遍历)\n构建完再计算所有的赋值情况，直接得出真值表\n其他的方法都是调用真值表答案，不会再计算公式\n构建过程就是双栈法构建\n附录，所有的代码\r//核心逻辑实现 namespace CStest { public enum Operator//枚举运算符 { LeftBracket,//左括号 XNOR,//双条件运算符 Odds,//条件运算符 Or,//析取运算符 And,//合取运算符 Not,//取反运算符 } internal class CalculateNode//定义计算节点 { CalculateNode? left;//运算符左边 CalculateNode? right;//运算符右边 Operator oper;//节点的运算符 bool ans;//该节点答案 internal CalculateNode(bool ans)//末节点构造方法 { left = null; right = null; this.ans = ans; } internal CalculateNode(CalculateNode? left, CalculateNode right, Operator oper)//计算节点构造方法 { this.left = left; this.right = right; this.oper = oper; } static bool Odds(bool a, bool b)//单独定义条件运算符 { if (!a) { return true; } else { if (b) { return true; } else { return false; } } } bool Calculate(CalculateNode node)//从某节点递归计算 { if (node.right == null)//递归边界条件 { return node.ans; } switch (node.oper) { case Operator.Not: node.ans = !Calculate(node.right); break; case Operator.And: node.ans = Calculate(node.left) \u0026amp;\u0026amp; Calculate(node.right); break; case Operator.Or: node.ans = Calculate(node.left) || Calculate(node.right); break; case Operator.Odds: node.ans = Odds(Calculate(node.left), Calculate(node.right)); break; case Operator.XNOR: node.ans = !(Calculate(node.left) ^ Calculate(node.right)); break; } return node.ans; } internal bool Calculate()//提供一个入口 { return Calculate(this); } internal void ChangeAns(bool ans)//改变末节点的值 { this.ans = ans; } } public class WellFormedFormula { string formula;//原公式 Dictionary\u0026lt;string, CalculateNode\u0026gt; map;//以string方式索引所有节点 Dictionary\u0026lt;int, string\u0026gt; dic;//以int方式索引所有根节点的名字 CalculateNode root;//最终答案节点 bool[] truthTable;//真值表 private static bool IsOperator(char c)//判断是否为二元运算符 { return c == \u0026#39;∧\u0026#39; || c == \u0026#39;∨\u0026#39; || c == \u0026#39;→\u0026#39; || c == \u0026#39;⊙\u0026#39;; } private static char OperatorToChar(Operator op)//运算符换成char { switch (op) { case Operator.And: return \u0026#39;∧\u0026#39;; case Operator.Or: return \u0026#39;∨\u0026#39;; case Operator.Odds: return \u0026#39;→\u0026#39;; case Operator.XNOR: return \u0026#39;⊙\u0026#39;; } return \u0026#39; \u0026#39;; } private static Operator CharToOperator(char c)//char换成运算符 { switch (c) { case \u0026#39;∧\u0026#39;: return Operator.And; case \u0026#39;∨\u0026#39;: return Operator.Or; case \u0026#39;→\u0026#39;: return Operator.Odds; case \u0026#39;⊙\u0026#39;: return Operator.XNOR; } return Operator.LeftBracket; } private bool Verify()//验证公式是否有效 { if (IsOperator(formula[0]) || formula[^1] == \u0026#39;┐\u0026#39; || IsOperator(formula[^1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//在首尾出现了不该出现的运算符 } int l = 0;//统计左括号 int r = 0;//统计右括号 for (int i = 0; i \u0026lt; formula.Length; i++) { if (formula[i] == \u0026#39;(\u0026#39;) { l++; } else if (formula[i] == \u0026#39;)\u0026#39;) { r++; } if (formula[i] == \u0026#39;┐\u0026#39;) { if (IsOperator(formula[i + 1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//取反运算符后接别的运算符 } } if (IsOperator(formula[i])) { if (IsOperator(formula[i - 1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;); } if (IsOperator(formula[i + 1]) || formula[i + 1] == \u0026#39;┐\u0026#39;) { throw new Exception(\u0026#34;Error in formula\u0026#34;); } }//都是判断多个运算符不应该相连的情况 } if (l != r) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//左右括号数不匹配 } return true; } private void Init()//初始化计算树 { Verify();//验证 string formula = \u0026#34;(\u0026#34; + this.formula + \u0026#34;)\u0026#34;; //获取所有的变量 int index = 0; bool flag = true; for (int i = 0; i \u0026lt; formula.Length; i++) { if (flag \u0026amp;\u0026amp; formula[i] != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; formula[i] != \u0026#39;┐\u0026#39; \u0026amp;\u0026amp; !IsOperator(formula[i])) { index = i; flag = false; } else if (formula[i] == \u0026#39;)\u0026#39; || formula[i] == \u0026#39;┐\u0026#39; || IsOperator(formula[i])) { if (index != i \u0026amp;\u0026amp; !flag \u0026amp;\u0026amp; !map.ContainsKey(formula[index..i])) { map.Add(formula[index..i], new CalculateNode(false)); dic.Add(dic.Count, formula[index..i]); } flag = true; } } flag = true; //构建计算树 Stack\u0026lt;string\u0026gt; v = new Stack\u0026lt;string\u0026gt;();//操作数栈 Stack\u0026lt;Operator\u0026gt; op = new Stack\u0026lt;Operator\u0026gt;();//运算符栈 string sa; string sb;//两个临时string变量 for (int i = 0; i \u0026lt; formula.Length; i++) { if (formula[i] == \u0026#39;(\u0026#39;)//左括号直接压入栈 { op.Push(Operator.LeftBracket); continue; } if (flag \u0026amp;\u0026amp; formula[i] != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; formula[i] != \u0026#39;┐\u0026#39; \u0026amp;\u0026amp; !IsOperator(formula[i])) { index = i; flag = false; } else if (formula[i] == \u0026#39;)\u0026#39; || formula[i] == \u0026#39;┐\u0026#39; || IsOperator(formula[i])) { if (index != i \u0026amp;\u0026amp; !flag)//压入操作数 { v.Push(formula[index..i]); flag = true; } if (formula[i] == \u0026#39;┐\u0026#39;) { op.Push(Operator.Not);//取反直接压入 } else if (formula[i] == \u0026#39;)\u0026#39;)//遇到右括号不断弹出，直到遇到左括号 { while (op.Peek() != Operator.LeftBracket) { if (op.Peek() == Operator.Not) { sa = v.Pop(); map.Add(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;, new CalculateNode(null, map[sa], Operator.Not)); v.Push(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;); break; } else { sa = v.Pop(); sb = v.Pop(); map.Add(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;, new CalculateNode(map[sb], map[sa], op.Peek())); v.Push(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;); } op.Pop(); } op.Pop();//弹出左括号 } else { if (op.Count != 0 \u0026amp;\u0026amp; CharToOperator(formula[i]) \u0026lt; op.Peek()) { if (op.Peek() == Operator.Not) { do//由于取反运算可多个连接，所以要一次性弹出所有连续的取反运算 { op.Pop(); sa = v.Pop(); map.Add(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;, new CalculateNode(null, map[sa], Operator.Not)); v.Push(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;); } while (op.Peek() == Operator.Not); } else { sa = v.Pop(); sb = v.Pop(); map.Add(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;, new CalculateNode(map[sb], map[sa], op.Peek())); v.Push(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;); op.Pop(); } } op.Push(CharToOperator(formula[i]));//最后把当前运算符压入 } } } root = map[v.Pop()];//最后的操作数就是root节点 truthTable = new bool[(int)Math.Pow(2, dic.Count)]; CalculateAll();//顺便把真值表给算了 } public WellFormedFormula(string formula)//构造方法 { map = new Dictionary\u0026lt;string, CalculateNode\u0026gt;(); dic = new Dictionary\u0026lt;int, string\u0026gt;(); this.formula = formula; Init(); } public bool Calculate(int n) { return truthTable[n]; } public bool Calculate(Dictionary\u0026lt;string, bool\u0026gt; keyValuePairs)//单独计算用 { if (keyValuePairs.Count != dic.Count) { throw new Exception(); } foreach (var kv in keyValuePairs) { map[kv.Key].ChangeAns(kv.Value); } return root.Calculate(); } private void CalculateAll()//全计算 { Stack\u0026lt;bool\u0026gt; b = new Stack\u0026lt;bool\u0026gt;(); int index; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { b.Clear(); index = i; while (index \u0026gt; 0) { if (index % 2 == 1) { b.Push(true); } else { b.Push(false); } index /= 2; } while (b.Count \u0026lt; dic.Count) { b.Push(false); } for (int j = 0; j \u0026lt; dic.Count; j++) { map[dic[j]].ChangeAns(b.Pop()); } truthTable[i] = root.Calculate(); } } public void ChangeFormula(string formula)//更改公式 { this.formula = formula; map.Clear(); dic.Clear(); Init(); } public void ShowrTruthTable()//展示真值表 { for (int i = 0; i \u0026lt; dic.Count; i++) { Console.Write(dic[i] + \u0026#39;\\t\u0026#39;); } Console.WriteLine(formula); Stack\u0026lt;bool\u0026gt; b = new Stack\u0026lt;bool\u0026gt;(); int index; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { index = i; while (index \u0026gt; 0) { if (index % 2 == 1) { b.Push(true); } else { b.Push(false); } index /= 2; } while (b.Count \u0026lt; dic.Count) { b.Push(false); } while (b.Count \u0026gt; 0) { if (b.Pop()) { Console.Write(\u0026#34;T\\t\u0026#34;); } else { Console.Write(\u0026#34;F\\t\u0026#34;); } } if (truthTable[i]) { Console.WriteLine(\u0026#34;T\u0026#34;); } else { Console.WriteLine(\u0026#34;F\u0026#34;); } } } public void ShowFormula()//展示公式 { Console.WriteLine(formula); } public void ShowAllNode()//展示所有节点信息，用于调试 { Console.Write(\u0026#34;| \u0026#34;); foreach (var m in map) { Console.Write(m.Key + \u0026#34; | \u0026#34;); } Console.WriteLine(); } public void ShowTrueAssignment()//展示所有成真赋值 { Console.Write(\u0026#34;All true assignment: \u0026#34;); for (int i = 0; i \u0026lt; dic.Count; i++) { if (i == 0) { Console.Write(dic[i]); } else { Console.Write(\u0026#34; | \u0026#34; + dic[i]); } } Console.WriteLine(); int index; Stack\u0026lt;byte\u0026gt; temp = new Stack\u0026lt;byte\u0026gt;(); for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { temp.Clear(); if (truthTable[i]) { index = i; while (index \u0026gt; 0) { temp.Push((byte)(index % 2)); index /= 2; } while (temp.Count \u0026lt; dic.Count) { temp.Push(0); } while (temp.Count \u0026gt; 0) { Console.Write(temp.Pop()); } Console.WriteLine(\u0026#34;(\u0026#34; + i + \u0026#34;)\u0026#34;); } } } public void ShowFalseAssignment()//展示所有成假赋值 { Console.Write(\u0026#34;All false assignment: \u0026#34;); for (int i = 0; i \u0026lt; dic.Count; i++) { if (i == 0) { Console.Write(dic[i]); } else { Console.Write(\u0026#34; | \u0026#34; + dic[i]); } } Console.WriteLine(); int index; Stack\u0026lt;byte\u0026gt; temp = new Stack\u0026lt;byte\u0026gt;(); for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { temp.Clear(); if (!truthTable[i]) { index = i; while (index \u0026gt; 0) { temp.Push((byte)(index % 2)); index /= 2; } while (temp.Count \u0026lt; dic.Count) { temp.Push(0); } while (temp.Count \u0026gt; 0) { Console.Write(temp.Pop()); } Console.WriteLine(\u0026#34;(\u0026#34; + i + \u0026#34;)\u0026#34;); } } } public void ShowDNF()//主析取范式 { int count = 0; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { if (truthTable[i]) { if (count == 0) { Console.Write(\u0026#34;m(\u0026#34; + i + \u0026#34;)\u0026#34;); } else { Console.Write(\u0026#34;∨m(\u0026#34; + i + \u0026#34;)\u0026#34;); } count++; } } Console.WriteLine(); } public void ShowCNF()//主合取范式 { int count = 0; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { if (!truthTable[i]) { if (count == 0) { Console.Write(\u0026#34;M(\u0026#34; + i + \u0026#34;)\u0026#34;); } else { Console.Write(\u0026#34;∧M(\u0026#34; + i + \u0026#34;)\u0026#34;); } count++; } } Console.WriteLine(); } } } //main.cs namespace CTest{ public class test { public static void Main(String[] args) { WellFormedFormula w = new WellFormedFormula(\u0026#34;(P∨Q)∧(P→R)\u0026#34;); w.ShowAllNode(); w.ShowrTruthTable(); w.ShowTrueAssignment(); w.ShowFalseAssignment(); w.ShowCNF(); w.ShowDNF(); } } } ","date":"2023-07-04T13:14:00Z","permalink":"https://mlacookie.github.io/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B2%E8%A7%A3/","title":"浙工大离散课设讲解"},{"content":"\u0026lt;0x00\u0026gt; 前言\r我的题目是幼儿园的信息管理系统(第29号)\n运行在Cmake 3.25.3+mingw 12.2.0上\n基本要求： 能从文件读出一个班级小朋友的信息，并能将管理信息保存到文件 小朋友的信息包括：姓名、出生年月（年龄）、性别、住址、身高、体重、父母联系人姓名、联系电话，备注信息等 功能要求： 1、系统以菜单方式工作； 2、增加修改和删除小朋友信息； 3、查询某个小朋友的父母联系人姓名及联系电话；查询小朋友住址； 4、显示所有小朋友信息：能根据小朋友的身高、体重分别排序，或者按身高体重比排序； 5、能按性别统计班级男女生人数比例； 6、可以进行小朋友信息的文件读写。 实现上面功能是挺简单，所以我加入了一些新功能\n于是就实现了些杂七杂八的东西(之后也会重点介绍的):\n双向模板链表 方向键界面控制 csv的文件读取和导出 多文件管理 从临时文件恢复 本来想实现更多的，实际上摸了就没写😋\n(主要是真没啥好写的)\n你可以在本站gitea下载源代码\n(课设报告就不发了，自己写写挺快的)\n\u0026lt;0x01\u0026gt; 双向链表实现\r//Mylist.cpp 仅列出声明，完整代码见源文件 #pragma once #include \u0026lt;cstddef\u0026gt; //NULL的定义在这个头文件里(我用的是mingw) using namespace std; template \u0026lt;class T\u0026gt; class MyList; //提前声明类型 template \u0026lt;class T\u0026gt; class MyNode { T content; // 存放内容 MyNode\u0026lt;T\u0026gt; *next; // 指向下一个Node MyNode\u0026lt;T\u0026gt; *back; // 指向前一个Node friend class MyList\u0026lt;T\u0026gt;; // 为List类提供访问权限(方便) friend class Tool; // 为Tool类提供访问权限(方便) MyNode(); public: MyNode(const T \u0026amp;content, MyNode *next = NULL, MyNode *back = NULL); MyNode(const MyNode \u0026amp;n); //一些节点的构造函数 MyNode\u0026lt;T\u0026gt; \u0026amp;operator=(const MyNode \u0026amp;n); //保险起见，重载下赋值运算 }; template \u0026lt;class T\u0026gt; class MyList { int length; // List的长度 MyNode\u0026lt;T\u0026gt; *head; // 指向头节点 MyNode\u0026lt;T\u0026gt; *end; // 指向尾节点 MyNode\u0026lt;T\u0026gt; *Find(int index) const; // 内部按index搜索用 friend class Tool; // 为Tool类提供访问权限(懒得写访问的函数了) public: MyList(); bool Insert(const T \u0026amp;c, int n = 0); // 插入List，可指定插入位置 bool Delete(int index); // 按index删除List元素 void Clear(); // 清空List内容 int GetLength() const; // 返回List的长度 MyList\u0026lt;T\u0026gt; \u0026amp;operator=(const MyList\u0026lt;T\u0026gt; \u0026amp;n); //保险起见，重载下赋值运算 T *operator[](int index) const; // 外部按index搜索用 ~MyList(); // 析构是门学问 }; 泛型类 MyNode\u0026lt;T\u0026gt;\r主要就是存放内容物的节点，为了数据结构的可拓展性，就写了个泛型\n基本就没啥好说的，关键就是用指针关系吧各个节点连接起来\n我这里采用的是双向链表的数据结构，即每个节点可以找到它的前一个后一个\n所以我这里的MyNode类需要两个指针，一个指前一个节点，一个指后一个节点\n泛型类 MyList\u0026lt;T\u0026gt;\r说白了，这部分的内容就是把各个节点拼起来\n为了首尾插入效率与保险起见，这个双向列表带有空的首尾节点\n(但最终代码没有完成对末尾插入的优化，忘了\n总之，数据结构图如下\n每个节点都可以找到它的前后节点\n虽然对插入操作没什么优势，但可以加速删除操作\n对于删除操作，仅需传入节点位置即可删除\n相当于把要删除的东西抽出来，再两边节点建立连接\n(单向链表的删除比较抽象)\n对于Clear()操作，相当于走一遍链表，边走边删对象\n走完了再回归到初始状态\n析构就是Clear()后再把首尾节点也删了\n剩下的都挺直观的，也不说了\n\u0026lt;0x02\u0026gt; 方向键控制\r方向键控制的代码写在UI.hpp里\nUI.hpp里面都是一堆静态函数，提供一些标准化输出实现\n(压缩代码量)\n//能实现方向控制的示例代码 #include \u0026lt;conio.h\u0026gt; //必要的头文件 using namespace std; int main() { char c; c = _getch(); swich(c) { case 72: //上方向键的代码 case 80: //下方向键的代码 case 75: //左方向键的代码 case 77: //右方向建的代码 case 13: //回车键的代码 } return 0; } 关键就是_getch()这个函数，他会捕获命令行界面的按键，然后返回对应按键的编码\n其他的按键编码网上应该都能找到的\n顺带讲下UI.hpp里的东西\n结构体 UIInfo\r就是用来传递菜单信息的结构体\n好让主函数知道进行了什么操作，选了哪一个\nUI类\r里面都是静态函数\nConfirm(...)函数用来显示确认菜单\nyesText写确认的文字\nnoText写取消的文字\ncontent写显示的内容\nSelect(...)函数显示选择菜单\n有三个重载\n总之可以显示标题，功能选择项，一般选择项，描述词，默认指针位置\ntitle标题\nfunction功能选择项\ncontent一般选择项\nhead描述词\nindex默认指针位置\n一般选择项十个每页，功能选择项始终显示\nShow(...)函数就是个简单的输出函数\n没啥好说的，让输出好看点而已\n\u0026lt;0x03\u0026gt; CSV文件的读写\rCSV文件的读写代码写在ManageTool.hpp里\n//导出为CSV文件 //原代码的逻辑已经嵌在相关函数里了，这里单独拿出来 #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;MyClass.hpp\u0026#34; #include \u0026#34;MyDate.hpp\u0026#34; #include \u0026#34;UI.hpp\u0026#34; using namespace std; string temp; //当前文件路径 MyClass *selectClass; //MyClass是我写的班级类 ofstream writeFile; //写入文件流 void ExportCSVFile() { writeFile.open(temp.substr(0, temp.length() - 4) + \u0026#34;-\u0026#34; + selectClass-\u0026gt;className + \u0026#34;.csv\u0026#34;, ios::out); writeFile \u0026lt;\u0026lt; \u0026#34;Class name: \u0026#34; \u0026lt;\u0026lt; selectClass-\u0026gt;className \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; selectClass-\u0026gt;children.GetLength() \u0026lt;\u0026lt; \u0026#34;,\\n\u0026#34;; writeFile \u0026lt;\u0026lt; \u0026#34;Name,Birthday,Age,Gender,Address,Height,Weight,Parent\u0026#39;s name,Parent\u0026#39;s phone,note,\\n\u0026#34;; for (int i = 0; i \u0026lt; selectClass-\u0026gt;children.GetLength(); i++) { writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;birthday.GetDate() \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; if (selectClass-\u0026gt;children[i]-\u0026gt;isBoy) { writeFile \u0026lt;\u0026lt; \u0026#34;Boy,\u0026#34;; } else { writeFile \u0026lt;\u0026lt; \u0026#34;Girl,\u0026#34;; } writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;address \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;height \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;weight \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;parentName \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;parentPhone \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;note \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } writeFile.close(); UI::Show(\u0026#34;CSV file has been generate\u0026#34;); break; } //由CSV文件导入 //原代码的逻辑已经嵌在相关函数里了，这里单独拿出来 #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;MyClass.hpp\u0026#34; #include \u0026#34;MyDate.hpp\u0026#34; #include \u0026#34;UI.hpp\u0026#34; using namespace std; string path; //路径 MyClass *selectClass; //MyClass是我写的班级类 ifstream readFile; // 读取文件流 Student Create(vector\u0026lt;string\u0026gt; \u0026amp;list) { //由传入的list来创建Student对象并返回 //代码略，见原代码 } void ImportCSV() { readFile.open(path + \u0026#34;\\\\\u0026#34; + files[u.index], ios::in); selectClass-\u0026gt;children.Clear(); string temp; getline(readFile, temp, \u0026#39;,\u0026#39;); getline(readFile, temp, \u0026#39;,\u0026#39;); readFile.get(); vector\u0026lt;string\u0026gt; list; int num = atoi(temp.c_str()); for (int i = 0; i \u0026lt; 10; i++) { getline(readFile, temp, \u0026#39;,\u0026#39;); } //用来忽略表头的 for (int i = 0; i \u0026lt; num; i++) { list.clear(); readFile.get(); //吞上一行回车 for (int j = 0; j \u0026lt; 10; j++) { getline(readFile, temp, \u0026#39;,\u0026#39;); list.push_back(p.assign(temp)); } selectClass-\u0026gt;children.Insert(Create(list), selectClass-\u0026gt;children.GetLength()); } readFile.close(); } CSV文件其实就是数值1,数值2,...这样组成的文件，这种文件格式可以被Excel读取\n输出的时候先输出基本班级信息，然后按行输出每个人的信息\n导入CSV时先读取基本班级信息，然后按行导入学生信息\n输出一般不大会遇到问题，就是读取时文件指针的控制是个问题\n这里在读取时用getline(ifstream,string,char)来读取，碰到,就截断\n前面还有readFile.get()来吞上一行的空格\n\u0026lt;0x04\u0026gt; 多文件管理\r为了方便备份和多幼儿园管理(?)，实现了多工程文件的选择\n选择和访问都应该不成问题，但获取对应文件夹下指定类型的所有文件是个问题\n//关键代码 #include \u0026lt;io.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void GetFiles(string path, vector\u0026lt;string\u0026gt; \u0026amp;files, string fileType) // 获取指定路径下指类型的所有文件名 { intptr_t hFile = 0; // 句柄编号 struct _finddata_t fileInfo; // 文件信息结构体 if ((hFile = _findfirst((path + \u0026#34;\\\\*\u0026#34; + fileType).c_str(), \u0026amp;fileInfo)) != -1) { do { files.push_back(fileInfo.name); // 给files加入文件名 } while (_findnext(hFile, \u0026amp;fileInfo) == 0); _findclose(hFile); // 关闭句柄 } } 这段代码实现了获取指定路径下指定文件类型的所有文件名\n通过句柄实现(也就是用系统api)\n最后的结果会保存在传入的files中\n注意，网上的多数代码会将句柄编号的类型写为long\n但在win10环境下，使用long类型的句柄会导致精度丢失进而导致错\n使用intptr_t就没这个问题\n\u0026lt;0x05\u0026gt; 从临时文件恢复\r为了防止用户系统崩溃(也可能程序崩溃)导致的数据丢失\n管理系统在选择文件后会新建一个一样的同名的.tmp临时文件\n后续的所有文件写入操作都会对这个.tmp文件操作\n只有在用户正常退出系统时才会将.tmp文件保存为.dat文件\n具体来说就是选择文件时并没有真正打开选择的文件，而是读取到文件名\n在选择班级之后，正常读取文件\n如果在班级管理界面里修改了相关数据，并不是修改原文件，而是创建同名临时文件，将修改后的结果写入\n最后用户正常退出后，在主对象析构中把原文件删了，然后把临时文件的后缀改成.dat\n代码就不单独拆出来了，原代码里有具体标明的\n\u0026lt;0x06\u0026gt; 把所有东西拼起来\r总体采用了UI与处理分离的设计\nUI.hpp负责所有的界面输出，ManageTool.hpp负责所有的数据处理和页面逻辑\nmain()函数里就建立了Tool对象然后调用MainDisplay()启动\n之后不同的功能就是不同的函数，不同的页面也是不同的函数\n页面函数调用下一个页面的函数来实现功能的切换\n页面函数相当于不同功能的调度器，页面输出还是靠UI.hpp的函数\nUI的选择结果由UIInfo传递\n其他的文件只是定义所需要的不同的类型\n这样就吧所有的东西都拼起来了\n后记\r课设的基本要求都不难，但是都要完成\n如果要拿优秀，肯定是要扩充功能的\n如果想不到能扩充啥功能，可以优化UI\n课设一般也不大需要多少时间，熟练的话写完课设大概3天\n","date":"2023-06-15T23:42:16Z","permalink":"https://mlacookie.github.io/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7c++%E8%AF%BE%E8%AE%BE%E8%AE%B2%E8%A7%A3/","title":"浙工大c++课设讲解"},{"content":"\u0026lt;0x00\u0026gt; 这就是个很神秘的问题\r突然想写一段 python 代码，然后打开 vscode\n就很神秘，明明啥配置都没改，代码提示又寄了\n网上搜索了一番，大概总结了3种可能的问题\n\u0026lt;0x01\u0026gt; Python: Default Interpreter Path的问题\r如图写上自己的 python 安装目录即可\n\u0026lt;0x02\u0026gt; python.autoComplete.extraPaths的问题\r如图搜索，然后点击 Edit in setting.json\n按自己的安装路径填上图片里的那些就可以\n\u0026lt;0x03\u0026gt; python.languageServer的问题\r如图,换成 Jedi 就好\n碎碎念\r还是Pychram好用😅，一站式解决所有的问题\n(@ 24-07-19) 现在vscode写python体验很不错了，这种问题之后也没遇到过了\n","date":"2023-06-05T00:16:03Z","permalink":"https://mlacookie.github.io/article/posts/python%E5%9C%A8vscode%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/","title":"Python在VSCode中代码提示异常问题"},{"content":"\u0026lt;0x00\u0026gt; 为啥不用Cmake了\r怎么说呢，Cmake 确实不是很好用，虽然说我还是稍微懂点 shell 命令的，但用着就是感觉很怪\n虽然 Cmake 很强大，而且经过这么多年的发展，Cmake 的社区支持也非常丰富\n但对于初学者，Cmake 的各种函数还是显得略微晦涩难懂\n而且 Cmake 在 VS Code 的环境下报错代码会很日怪 (也可能是我没装好对应的插件，反正看报错挺费脑子的)\n\u0026lt;0x01\u0026gt; 为什么使用Xmake\rXmake 使用 lua 作为脚本语言，整体看着能更好理解，并且更加语句更少\n我常用的 Cmake 配置文件\n# CMakeLists.txt cmake_minimum_required(VERSION 3.0.0) project(Course VERSION 0.1.0) include(CTest) enable_testing() # 指定文件转编码为GBK set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -fexec-charset=GBK\u0026#34;) # 指定编译器和标准 set(CMAKE_CXX_COMPILER \u0026#34;g++\u0026#34;) set(CMAKE_CXX_STANDARD 17) # 添加include路径 include_directories(include) aux_source_directory(src SRC) set(CPACK_PROJECT_NAME ${PROJECT_NAME}) set(CPACK_PROJECT_VERSION ${PROJECT_VERSION}) add_executable(${PROJECT_NAME} ${SRC}) 换成 xmake.lua 的等价配置文件\n--xmake.lua add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) target(\u0026#34;xtest\u0026#34;) set_symbols(\u0026#34;debug\u0026#34;) --指定文件转编码为GBK add_cxxflags(\u0026#34;-fexec-charset=GBK\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) --指定C++标准 set_languages(\u0026#34;c++17\u0026#34;) --添加inlude路径 add_includedirs(\u0026#34;include\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) 是不是确实干净很多？而且更加易懂？\n所以说嘛，人不能折磨自己，如果刚刚打算跑 C++ 的多文件编译，我强烈推荐用 Xmake\n在文档中提到，Xmake 的构建效率可以达到 ninja 的水平，这个在我的使用中似乎并未体现\n(可能是我的项目相对比较小) 总之 Xmake 更现代，对很多东西都有很好的原生支持，具体可以看项目文档\n\u0026lt;0x02\u0026gt; 安装Xmake\r如果有配置 winget 可以直接敲下面的命令\nwinget install xmake (强烈安利 winget，先挖个在 win10 LTSC 下安装 winget 的坑)\n也可以去 Github-xmake项目 下载安装包\n直接安装就可以了，全默认就可以\n\u0026lt;0x03\u0026gt; VS Code的配置\rVS Code 的配置也很简单，仅需安装一个叫 Xmake 的插件\n安装上就行了\n\u0026lt;0x04\u0026gt; 由Xmake创建项目\r先新建个文件夹，作为存放项目代码的文件夹\n在 VS Code 中打开这个文件夹\n快捷键 Ctrl+Shift+P 打开命令窗口，输入 Xmake\n选择 XMake: CreateProject 这个选项\n选择后一般右下角会有个窗口，提示没有 xmake.lua 文件，询问是否创建，创建就是了\n然后按你需要的选择配置，我通常选择 C++ 的命令行应用\n之后，项目的文件夹结构就创建好了\n里面的 xmake.lua 就是配置文件，里面已经写好了基本的配置\n如果有 include 的文件，创建个文件夹放然后在配置文件指明就好\n可以直接参考[\u0026lt;0x01\u0026gt;](#\u0026lt;0x01\u0026gt; 为什么使用Xmake)部分的配置文件\n之后创建新项目就按这个方法就可以了，轻松加愉快\n编译时按下面的 Build 或者 ▶ 就可以\n调试就是打完断点，然后按下面的 🐞 图标\n","date":"2023-06-02T19:45:28Z","permalink":"https://mlacookie.github.io/article/posts/%E4%BB%8Ecmake%E6%8D%A2%E5%88%B0xmake/","title":"从Cmake换到Xmake"},{"content":"终于通过所有备案了\r所以之后会慢慢在这个小站上分享我的见闻\n虽然不知道有没有人看，但还是很感谢正在看这个页面的你\n关于备案流程\r其实主要就是等\n要做ICP备案和公安备案\n我的服务器和域名都是阿里云的，所以ICP备案通过阿里云代办。公安备案自己填填就可以了\n首先是ICP备案，阿里云的ICP备案说得很详细了\n主要的问题就是在拍自己照片的时候要找面白墙\n其他的东西仔细填写就好\n提交完材料后会有人打电话跟你确认，顺便说一下提交的材料有什么问题\n有问题的话都会指出，然后邮箱发给他们就好\n然后再是工信部的短信验证，跟着流程就行 接下来就是等了，一般10天左右\n一切顺利的话ICP备案就下来了\n之后就是公安备案，这个比较容易，就是登入网页然后填填表就行\n一般第二天就能备案下来\n里面有个业务类型，如果只是跟我一样搭个博客的话不要勾选交互服务，然后选www服务就好\n据说选了交互服务要线下确认，所以能少一事就少一事\n最后记得在页面下面挂备案号。\n","date":"2023-05-18T14:35:25Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E5%BA%86%E7%A5%9D%E4%B8%8B%E5%A4%87%E6%A1%88%E5%85%A8%E9%80%9A%E8%BF%87%E4%BA%86/","title":"庆祝下备案全通过了"},{"content":"搭个博客嘛，肯定要加点个人的一些账号。然后呢，我想加个B站的链接，但是在 Anatolo 的模板里没有，这下只能自己动手了。\n一些约定的符号\r./ 表示 hexo 博客的根目录\n\u0026lt;0x00\u0026gt; 分析\r我先是在 ./themes/Anatolo/source/images 里找，发现里面只有网站的 icon 和主要图标，没有那些社交媒体的图标 (比如这样的图标，B站的图标原来是没有的)\n然后就又去找 ./themes/Anatolo/layout/partial 下面的各种文件，发现有个叫 sidebar.pug 和 social_links.pug 这两个文件。问题来了，.pub 是啥文件啊(之前真没接触过)。百度了以下，这是个排版引擎的语言。行吧，直接在线学习。\n然后打开了 sidebar.pug 简单分析下，感觉关系不大。打开 social_links.pug\n// social_links.pug ul.social-links if theme.github li a(href= theme.github) i.fa.fa-github if theme.mail li //- a(href= \u0026#34;javascript:alert(\\\u0026#34;\u0026#34; + theme.mail +\u0026#34;\\\u0026#34;)\u0026#34; ) a(href= \u0026#34;mailto:\u0026#34; + theme.mail ) i.fa.fa-envelope if theme.QQ li a(href= \u0026#34;http://sighttp.qq.com/authd?IDKEY=\u0026#34; + theme.QQ) i.fa.fa-qq if theme.zhihu li a(href= theme.zhihu) i.fa.fa-mortar-board if theme.twitter li a(href= theme.twitter) i.fa.fa-twitter if theme.instagram li a(href= theme.instagram) i.fa.fa-instagram if theme.rss li a(href= url_for(theme.rss)) i.fa.fa-rss if theme.weibo li a(href= theme.weibo) i.fa.fa-weibo if theme.facebook li a(href= theme.facebook) i.fa.fa-facebook 感觉很有关系\n\u0026lt;0x01\u0026gt; 简单的尝试\r于是我就直接很粗暴的在 social_links.pug 里加上这个\nif theme.bilibili li a(href= theme.bilibili) i.fa.fa-bilibili 还有在 ./themes/Anatolo/_config.yml 里加上这个\nbilibili: https://space.bilibili.com/13629146 一编译，一部署，一看，果不其然，直接是空白。 然后看看开发者工具，发现在对应地方的 html 代码里多了这些\n\u0026lt;li\u0026gt; \u0026lt;a target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; href=\u0026#34;https://space.bilibili.com/13629146\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-bilibili\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; 也就是说，其实添加是添加进去了，但就是没有对应的图标而已\n问题来了，\u0026lt;i class=\u0026quot;fa fa-bilibili\u0026quot;\u0026gt; 里面的 fa 指的是什么呢?\n\u0026lt;0x02\u0026gt; 二度分析\r搜索了一下，fa 指的是 Font awesome，是有各种常见图标的字体。找的官网，看了看图标列表，果然没有B站\n这下不得不自己做字体了(如果直接插入图片会更简单倒是)\n翻了翻 ./themes/Anatolo/source/fonts 果然有 FontAwesome 的字体文件\n(有 .otf .eot .svg .ttf .woff .woff2)\n\u0026lt;0x03\u0026gt; 制作图标\r首先需要一个工具网站，用来做字体。然后还需要一个矢量图编辑器。\n网站是 icomoon.io 直接点击右上角的 IcoMoon App 即可\n矢量图编辑器随意，我这里用的是 inkscape\n进入 IcoMoon App 后，点击左上角 Import Icons，选择 .svg 文件\n左上角选择铅笔，然后随便选一个图标，点击 Download(SVG) 下载这个图标的 .svg 文件。\n然后在本地用矢量图编辑器打开，把原来的图清掉，然后再在上面画矢量图就可以了。\n画的时候注意不要用描边，要用填充来构成图形。如果不小心用描边构成了图形，那么也可以选中路径，然后找到这个\n点一下就会自动转换成填充了\n画的时候要尽可能把画布填满，如果上下留白很多的话可以适当减小。\n画布大小可以在文件→文档属性里修改\n如果贝塞尔曲线画不好的话可以先用有理B样条来画，后者好画一点，但画出来就是比较圆润。 用贝塞尔曲线画的画，尽可能让每个节点的手柄要么水平，要么垂直，这样画会相对简单一点\n如果图标有一定的对称性，那么节点要对称，而且手柄的长度也要对称\n我的成果供大家参考。\n然后，保存文件，回到之前的网页。导入我们制作的 .svg 文件。\n然后选择右上角移动工具\n把我们的图标移到列表的最后一个。\n最后选择 Generate Font 生成字体文件。下载前找到我们新制作的图标，可以先检查下有没有什么问题。\n\u0026lt;0x04\u0026gt; 替换原有字体\r下载后解压缩，里面有个 demo.html 可以用来查看字体和字体编号(字体编号很重要)，还有 fonts 文件夹，里面就是我们生成的字体了。\n打开 demo.html，找到我们的图标，记下图标的编号(这个编号在字体生成里也能改)，比如我的字体编号是 f2e1。\n把 fonts 文件下的文件复制到 ./themes/Anatolo/source/fonts\n在 ./themes/Anatolo/source/css 里找到 font-awesome.css 和 font-awesome.min.css (建议每个复制一个作备份)，打开。\n在 font-awesome.css 修改\n/*原来的*/ @font-face { font-family: \u0026#39;FontAwesome\u0026#39;; src: url(\u0026#39;../fonts/fontawesome-webfont.eot?v=4.7.0\u0026#39;); src: url(\u0026#39;../fonts/fontawesome-webfont.eot?#iefix\u0026amp;v=4.7.0\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff2?v=4.7.0\u0026#39;) format(\u0026#39;woff2\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff?v=4.7.0\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.ttf?v=4.7.0\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular\u0026#39;) format(\u0026#39;svg\u0026#39;); font-weight: normal; font-style: normal; } /*修改为*/ @font-face { font-family: \u0026#39;FontAwesome\u0026#39;; src: url(\u0026#39;../fonts/fontawesome-webfont.eot\u0026#39;); src: url(\u0026#39;../fonts/fontawesome-webfont.eot\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.svg\u0026#39;) format(\u0026#39;svg\u0026#39;); font-weight: normal; font-style: normal; } 我这里的字体名还是 fontawesome-webfont 这里名字按自己的来\n然后加上这些\n.fa-bilibili-alt:before { content: \u0026#34;\\f2e1\u0026#34;; } 反正有很多长差不多的，加在那里面就可以。\n\\f2e1 这里要看你的编号填，.fa-bilibili-alt 这个算是给图标起个名字，随意就好。\nfont-awesome.min.css 就是 font-awesome.css 去掉所有缩进的版本，也要加上并修改些东西，在这里就不讲了。\n\u0026lt;0x05\u0026gt; 部署试试\r(记得加上\u0026lt;0x02\u0026gt;的多出来的代码)\n编译，部署。访问下网页看看有没有新图标出现。如果没有，清除或禁用网页缓存后再试试。理论上自己加入的图标就会出现。\n就像这样。\n搞定，下班\r","date":"2023-04-26T21:59:57Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E7%BB%99%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%8A%A0%E4%B8%AAb%E7%AB%99%E5%9B%BE%E6%A0%87/","title":"给侧边栏加个B站图标"},{"content":"适用于HP Prime的绘图软件\r(@ 24-02-09)\n原本的服务器已经不续费了，现在只有Github的了\ngithub链接\n使用教程(B站)\n之后应该不更新了，手头没机子测试了\n","date":"2023-04-26T21:53:36Z","permalink":"https://mlacookie.github.io/article/posts/hp-primepaint-v1.0/","title":"HP-PrimePaint-V1.0"},{"content":"\u0026lt;0x01\u0026gt; 如何实现\r思路是本地多写几份 config 文件\n在部署时切换就可以\n\u0026lt;0x02\u0026gt; 开搞\r首先先新建几个 config 文件\n建议直接复制原来的_config.yml\n复制的文件名字随意 我们只需要修改最下面的deploy部分就好\n比如我在 hexo 目录建了两个文件\n分别是_GitPageConfig.yml与_ServerConfig.yml\n# _GitPageConfig.yml的部分 deploy: type: git repo: git@github.com:{github用户名}/{github用户名}.github.io.git branch: gh-pages # _ServerConfig.yml的部分 deploy: type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master 然后新建一个脚本文件\n这里用 windows 配置，所以新建了个 powershell 脚本\n# deploy.ps1 copy _ServerConfig.yml _config.yml hexo g -d del _config.yml copy _GitPageConfig.yml _config.yml hexo g -d del _config.yml 如果要部署到更多的git仓库，以此类推 之后部署只需要执行deploy.ps1即可\n\u0026lt;0x03\u0026gt; 为什么不单文件解决\r(@ 23-07-07)\n经过我的实际测试，确实也可以直接单文件搞定\n# _config.yml deploy: - type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master - type: git repo: git@github.com:{github用户名}/{github用户名}.github.io.git branch: gh-pages 这样写也可以，hexo会按从上到下的顺序依次部署\n但这样写会导致一个问题，就是网址的根域名会对不上\n# _config.yml # 部署到我自己的网站 url: http://mlacookie.top/ # 部署到GitHubPage url: https://MLAcookie.github.io/ 如果仅靠单一文件的话，两个部署的根域名会是一样的\n这样可能会造成一些小问题\n靠powershell还可以顺便做部署前的一些操作，挺方便的\n","date":"2023-04-23T16:35:19Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E5%A6%82%E4%BD%95%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%A4%9Agit/","title":"如何一个hexo博客同时部署多git"},{"content":"\u0026lt;0x00\u0026gt; 为什么要用gitea + hexo\r很简单，gitea 太好用了(才不是因为 git 配置太麻烦)\n而且 hexo 的博客就是静态网页，基本不怎么耗费服务器资源\n如此再搭个 gitea 正好还能当个代码仓库，岂不美哉\n\u0026lt;0x01\u0026gt; 整体运行架构\r就是 gitea 跑 git 仓库\n然后利用 git hook 功能将仓库内容同步到服务器的另一个文件夹\nhexo 的界面靠 nginx 反代 本地写完靠 hexo 的配置脚本通过 git 同步到服务器\n(其实用 gitea 的话也可以通过插件实现 GitHub Page 的功能的)\n\u0026lt;0x02\u0026gt; 先安装些组件\r#安装nginx sudo apt update \u0026amp;\u0026amp; sudo apt upgrade sudo apt install nginx gitea 的安装在这就不赘述了\n(我之前有从零搭建的教程)\n\u0026lt;0x03\u0026gt; 配置git hook\rgit hook 其实就是一个自动化脚本\n简单理解就是 git 到服务器上后服务器要干的事\n首先，在 gitea 里创建一个仓库，名字随意\n#进入对应仓库的hook配置目录 cd /var/lib/gitea/data/gitea-repositories/${gitea用户名}/${仓库名}.git/hooks/ (${gitea用户名}和${仓库名}都是按照自己的设置填的) 这里是 git 的各种 hook，别的现在用不大到\n#进入需要编辑的hook目录 cd post-receive.d/ #创建我们自己的hook，名字随意 vim hexo 在 hexo 文件中，输入以下内容\n#!/bin/bash sss=/var/lib/gitea/data/gitea-repositories/${gitea用户名}/${仓库名}.git ttt=/var/www/blog rm -rf ${ttt} git clone ${sss} ${ttt} 其中/var/www/blog是你希望存储网页的地址，可以改成别的\n#给这个hook添加可执行权限 chmod a+x hexo 现在，理论上当你用 hexo 一键配置脚本的时候，那些网页文件会出现在那个位置\n\u0026lt;0x04\u0026gt; 配置存储地址和nginx\r#进入你希望存网页的位置 cd /var/www/ mkdir blog #为第一次git用户删除提供权限 chmod -R 777 ./ #进入nginx的目录 cd /etc/nginx/ cd sites-enabled/ vim default 需要注意的是，这里的nginx版本可能比较新，所以需要修改/etc/nginx/sites-enabled/default\n如果你在/etc/nginx/nginx.conf中能看到在http{}中有server{}\n那么直接在/etc/nginx/nginx.conf就行\n在server{}中，把root的值改为存储网页的位置\n在这里是改为root /var/www/blog 再在index后加入index.html (有了就不用加)\n#重启nginx服务 nginx -s reload 现在，理论上访问服务器 ip 后就是博客首页了\n\u0026lt;0x05\u0026gt; 本地的一些修改\r打开_config.yml\ndeploy: type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master 现在，当你运行hexo deploy，网页内容将同步到git仓库并且也会同步到网页存储位置\n","date":"2023-04-23T15:50:19Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E6%90%AD%E5%BB%BAhexo+gitea%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%AB%99/","title":"搭建hexo+gitea的博客站"},{"content":"找到gitea的配置文件\n一般在/etc/gitea中(如果按官方文档配置的话)\n#打开gitea配置文件 cd /etc/gitea vim app.ini 然后往下翻 找到 DISABLE_REGISTRATION\n把 false 改成 true 就可以了\n然后记得重启gitea服务\n#如果已经配置了linux服务 systemctl restart gitea ","date":"2023-04-23T15:40:43Z","permalink":"https://mlacookie.github.io/article/posts/%E5%85%B3%E9%97%ADgitea%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/","title":"关闭gitea注册功能"},{"content":"\u0026lt;0x00\u0026gt; 安装组件\r首先肯定要有台服务器嘛，系统倒问题不大，我用的是debian 11\n#安装各种包前先更新是好文明 sudo apt update sudo apt upgrade #安装git sudo apt install git #安装mysql wget https://dev.mysql.com/get/mysql-apt-config_0.8.22-1_all.deb sudo dpkg -i mysql-apt-config_0.8.22-1_all.deb #这里可能会跳出个界面，直接选最后的ok就可以 rm mysql-apt-config_0.8.22-1_all.deb sudo apt update sudo apt-get install mysql-server 安装mysql的时候会要求你设置数据库 root 账户密码的\n\u0026lt;0x01\u0026gt; 配置mysql\r在/etc/mysql/mysql.conf.d/mysqld.cnf中加入bind-address = 127.0.0.1 这个配置文件的位置看版本，我这里的 mysql 版本是8.0.33 这个bind-address是控制 mysql 数据库允许远程访问的\n#先进入mysql控制台 mysql -u root -p` #输入你设置的root账户密码 #配置gitea的数据库 CREATE USER \u0026#39;gitea\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; #这里写的‘密码’是你想设置的密码 CREATE DATABASE giteadb CHARACTER SET \u0026#39;utf8mb4\u0026#39; COLLATE \u0026#39;utf8mb4_unicode_ci\u0026#39;; GRANT ALL PRIVILEGES ON giteadb.* TO \u0026#39;gitea\u0026#39;; FLUSH PRIVILEGES; exit \u0026lt;0x02\u0026gt; 配置 gitea 和 git 账户\r#下载git安装包 wget -O gitea https://dl.gitea.com/gitea/1.19.0/gitea-1.19.0-linux-amd64 chmod +x gitea #添加git用户并修改权限 adduser git mkdir -p /var/lib/gitea/{custom,data,log} chown -R git:git /var/lib/gitea/ chmod -R 750 /var/lib/gitea/ mkdir /etc/gitea chown root:git /etc/gitea chmod 770 /etc/gitea 手动将下列语句加入/etc/profile文件 export GITEA_WORK_DIR=/var/lib/gitea/ (导出个全局变量)\n#一些剩下的操作 cp gitea /usr/local/bin/gitea sudo vim /etc/systemd/system/gitea.service #将gitea.service的内容复制进去，并取消一些服务的注释，如mysql的 sudo systemctl enable gitea sudo systemctl start gitea 现在访问(你的ip):3000应该是能看到gitea的网页了\n\u0026lt;0x03\u0026gt; 网页配置\r在网页的安装界面，你需要设置你的数据库用户和用户密码\n然后指定数据库名字\n#本次配置的值 数据库用户：gitea 用户密码：(之前给gitea设置的密码) 数据库名称：giteadb 记得在网页最后那里设置管理员账户\n(不在这配置也行，理论上第一个创建的账户就是管理员)\n创建新用户后记得绑定 sshkey，这样就可以用 ssh 的 clone 地址了\n\u0026lt;0x04\u0026gt; 收尾配置\r#最后记得把一些权限修改回来 chmod 750 /etc/gitea chmod 640 /etc/gitea/app.ini 附录：git.service\r用什么数据库就取消注释哪一行\n# git.service [Unit] Description=Gitea (Git with a cup of tea) After=syslog.target After=network.target ### # Don\u0026#39;t forget to add the database service dependencies ### # #Wants=mysql.service #After=mysql.service # #Wants=mariadb.service #After=mariadb.service # #Wants=postgresql.service #After=postgresql.service # #Wants=memcached.service #After=memcached.service # #Wants=redis.service #After=redis.service # ### # If using socket activation for main http/s ### # #After=gitea.main.socket #Requires=gitea.main.socket # ### # (You can also provide gitea an http fallback and/or ssh socket too) # # An example of /etc/systemd/system/gitea.main.socket ### ## ## [Unit] ## Description=Gitea Web Socket ## PartOf=gitea.service ## ## [Socket] ## Service=gitea.service ## ListenStream=\u0026lt;some_port\u0026gt; ## NoDelay=true ## ## [Install] ## WantedBy=sockets.target ## ### [Service] # Uncomment the next line if you have repos with lots of files and get a HTTP 500 error because of that # LimitNOFILE=524288:524288 RestartSec=2s Type=simple User=git Group=git WorkingDirectory=/var/lib/gitea/ # If using Unix socket: tells systemd to create the /run/gitea folder, which will contain the gitea.sock file # (manually creating /run/gitea doesn\u0026#39;t work, because it would not persist across reboots) #RuntimeDirectory=gitea ExecStart=/usr/local/bin/gitea web --config /etc/gitea/app.ini Restart=always Environment=USER=git HOME=/home/git GITEA_WORK_DIR=/var/lib/gitea # If you install Git to directory prefix other than default PATH (which happens # for example if you install other versions of Git side-to-side with # distribution version), uncomment below line and add that prefix to PATH # Don\u0026#39;t forget to place git-lfs binary on the PATH below if you want to enable # Git LFS support #Environment=PATH=/path/to/git/bin:/bin:/sbin:/usr/bin:/usr/sbin # If you want to bind Gitea to a port below 1024, uncomment # the two values below, or use socket activation to pass Gitea its ports as above ### #CapabilityBoundingSet=CAP_NET_BIND_SERVICE #AmbientCapabilities=CAP_NET_BIND_SERVICE ### # In some cases, when using CapabilityBoundingSet and AmbientCapabilities option, you may want to # set the following value to false to allow capabilities to be applied on gitea process. The following # value if set to true sandboxes gitea service and prevent any processes from running with privileges # in the host user namespace. ### #PrivateUsers=false ### [Install] WantedBy=multi-user.target 从gitea文档扒的\n","date":"2023-04-20T23:05:44Z","permalink":"https://mlacookie.github.io/article/posts/%E4%BB%8E0%E6%90%AD%E5%BB%BAgitea/","title":"从零搭建一个gitea"}]