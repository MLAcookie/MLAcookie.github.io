[{"content":"\u0026lt;0x00\u0026gt; 前言\rWPF开发中，总是会有些创建自定义控件的需求\n毕竟原生的控件总是不够用的\n\u0026lt;0x01\u0026gt; 原理\rWPF使用xaml作为设计语言\n而xaml负责的可以简单理解成将控件实例化到对应的布局上，然后设定控件的一些属性\n既然是实例化，那么本质上就是创建了一个新的对象\n\u0026lt;!--随便定义一个按钮--\u0026gt; \u0026lt;button Content=\u0026#34;123\u0026#34;/\u0026gt; 其实在编译器看来，就相当于这样\nButton b = new(); 所以我们自定义控件，首先需要有一个类定义控件的属性，然后用xaml去描述控件行为\n那么怎么用xaml描述控件行为呢\n在修改控件的style的时候，我们可以把自己定义的style写到一个ResourceDictionary中\n然后通过合并ResourceDictionary来将自己style应用到不同的地方\nxaml描述控件行为其实也就是写一个style，所以可以采用一样的思路\n\u0026lt;0x02\u0026gt; 示例：带标签的文本输入框\r这个感觉还是很常见的需求，有些时候需要文本输入框前面带一个标签，表示输入的是什么\n也就是说，我们要做的控件跟下面xaml代码效果是等价的\n\u0026lt;Grid Margin=\u0026#34;0,4\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;TextBlock Grid.Column=\u0026#34;0\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; /\u0026gt; \u0026lt;TextBox Grid.Column=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; 定义控件\r首先需要定义一个类，表示我们的类与其他类的不同\n// Controls/TextBoxWithLable/TextBoxWithLable.cs using System.Windows.Controls; namespace XamlTest.Controls; public class TextBoxWithLable : Control { // 后面还有别的代码，但这里先不需要 } 这样就可以了\n描述控件\r然后创建一个资源字典，用来描述我们的控件\n\u0026lt;!-- Controls/TextBoxWithLable/TextBoxWithLable.xaml --\u0026gt; \u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:controls=\u0026#34;clr-namespace:XamlTest.Controls\u0026#34;\u0026gt; \u0026lt;Style x:Key=\u0026#34;Default_TextBoxWithLableStyle\u0026#34; TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34;\u0026gt; \u0026lt;Grid Margin=\u0026#34;0,4\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;TextBlock Grid.Column=\u0026#34;0\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; /\u0026gt; \u0026lt;TextBox Grid.Column=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;Style BasedOn=\u0026#34;{StaticResource Default_TextBoxWithLableStyle}\u0026#34; TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34; /\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; 就像前面说的，通过style的模板来让xaml知道需要实例化什么控件\n这里先是定义了一个Default_TextBoxWithLableStyle的style，然后再写全局应用\n这样写的话万一用户想再基于默认样式自定义的话就比较方便了\n合并资源字典\r上面的写好之后，如果直接使用会发现还是显示不了的\n这是因为我们还没有合并资源字典\n这里我建议在控件的文件夹中加一个文件，其中去合并所有控件的资源字典\n然后再在app.xaml中合并这个整合的资源字典文件\n毕竟控件开发一般会开发很多，全写app.xaml会很乱\n\u0026lt;!-- Controls/ControlsDictionary.xaml --\u0026gt; \u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34;\u0026gt; \u0026lt;ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;ResourceDictionary Source=\u0026#34;pack://application:,,,/Controls/TextBoxWithLable/TextBoxWithLable.xaml\u0026#34; /\u0026gt; \u0026lt;/ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; 然后在app.xaml中合并\n\u0026lt;!-- app.xaml --\u0026gt; \u0026lt;Application x:Class=\u0026#34;XamlTest.App\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:controls=\u0026#34;clr-namespace:XamlTest.Controls\u0026#34; xmlns:local=\u0026#34;clr-namespace:XamlTest\u0026#34; StartupUri=\u0026#34;MainWindow.xaml\u0026#34;\u0026gt; \u0026lt;Application.Resources\u0026gt; \u0026lt;ResourceDictionary\u0026gt; \u0026lt;ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;ResourceDictionary Source=\u0026#34;pack://application:,,,/Controls/ControlsDictionary.xaml\u0026#34; /\u0026gt; \u0026lt;/ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; \u0026lt;/Application.Resources\u0026gt; \u0026lt;/Application\u0026gt; 这里的source属性出现的很像网址的东西是资源url，我暂时没研究的这么全\n为控件创建属性\r现在控件有了，但是如果在控件中输入文字我们是很难获取到的\n而且我们也修改不了文本框前面的lable部分 这是因为我们还没有为控件创建属性，这时候就需要修改TextBoxWithLable.cs文件了\n我们需要为我们的控件添加依赖属性\n// Controls/TextBoxWithLable/TextBoxWithLable.cs using System.Windows; using System.Windows.Controls; namespace XamlTest.Controls; public class TextBoxWithLable : Control { #region LableText_propdp public string LableText { get { return (string)GetValue(LableTextProperty); } set { SetValue(LableTextProperty, value); } } public static readonly DependencyProperty LableTextProperty = DependencyProperty.Register(\u0026#34;LableText\u0026#34;, typeof(string), typeof(TextBoxWithLable), new PropertyMetadata(null)); #endregion LableText_propdp #region InputText_propdp public string InputText { get { return (string)GetValue(InputTextProperty); } set { SetValue(InputTextProperty, value); } } public static readonly DependencyProperty InputTextProperty = DependencyProperty.Register(\u0026#34;InputText\u0026#34;, typeof(string), typeof(TextBoxWithLable), new PropertyMetadata(null)); #endregion InputText_propdp } 这里讲一个小技巧 创建依赖属性的代码确实多，但也挺公式的\n所以vs提供了一个模板，只要输入propdp然后敲两下tab就可以插入模板\n然后逐个替换即可\n然后修改TextBoxWithLable.xaml，绑定我们的依赖属性\n\u0026lt;!-- Controls/TextBoxWithLable/TextBoxWithLable.xaml --\u0026gt; \u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:controls=\u0026#34;clr-namespace:XamlTest.Controls\u0026#34;\u0026gt; \u0026lt;Style x:Key=\u0026#34;Default_TextBoxWithLableStyle\u0026#34; TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34;\u0026gt; \u0026lt;Grid Margin=\u0026#34;0,4\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;TextBlock Grid.Column=\u0026#34;0\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; Text=\u0026#34;{TemplateBinding LableText}\u0026#34; /\u0026gt; \u0026lt;TextBox Grid.Column=\u0026#34;1\u0026#34; Text=\u0026#34;{Binding RelativeSource={RelativeSource Mode=TemplatedParent}, Path=InputText, Mode=TwoWay}\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;Style BasedOn=\u0026#34;{StaticResource Default_TextBoxWithLableStyle}\u0026#34; TargetType=\u0026#34;{x:Type controls:TextBoxWithLable}\u0026#34; /\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; 这里需要注意的是，TemplateBinding是单向绑定\n也就是相当于只能绑定源-\u0026gt;控件，这对TextBlock是没啥问题的\n但对于TextBox，我们希望里面的内容也可以传回来，这时候就不能只靠TemplateBinding\n所以TextBox这里的绑定就写得很长，主要就是要写一个Mode\n（TemplateBinding本身就是一种简写）\n然后这个控件就创建完成了\n","date":"2024-10-25T02:17:15+08:00","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/","title":"WPF中怎么自定义控件"},{"content":"所以，不出意外地，我还是换回Windows了\n具体为什么呢，主要还是linux对高分屏的支持不佳\n（虽然Windows也不是很好就是）\n具体来说，是对2K这个分辨率支持不是很好\n一般来说，1080P的缩放是100%\n那么4K屏是200%，2K屏是150%\nlinux在100%和200%缩放都是不错的，但偏偏在150%缩放下工作就不是很好\n为什么呢，这就要谈到linux的图形化后端的问题了\n现在linux的图形化后端主要有两个，x11和wayland\nx11老，wayland新，然后wayland为了兼容老的还有xwayland\nwayland在150%缩放下工作的很好\n所以在前面的一些文章中，我会提到启用Wayland的问题\nx11在100%和200%缩放下可以说没啥问题，但在150%缩放下，字体会很糊\n这个是xwayland很难解决的问题\n不过很多基于x11且很难改后端的软件也意识到了这个问题，于是会在软件内内置缩放\n这样的话150%缩放下显示也是正常的\n不过总有个别软件，基于x11而且也没有写缩放\n这里点名Unity\nlinux中的Unity的图形后端是x11，而且我找了半天，我也找不到哪里改UI缩放\n（真的没有UI Scaling这个选项）\n于是Unity中控件字体非常小，需要放大镜看\n这样的例子还有很多\n所以，我也理解了为啥很多用linux的根本不用图形化\nlinux的图形化有些时候是不可靠的，我总算是认识到这点\nlinux，还是命令行来得靠谱\n我也想不到linux中使用Windows的最佳实践\nWindows下倒是有使用linux的最佳实际，也就是WSL\n而且像Unity这样的软件我还是要用的，所以我还是换回了Windows了\n顺便说下win11LTSC的体验吧\n我觉得还是很舒服的，LTSC非常干净，基本没啥怪东西\n而且不像win10LTSC，没有删除vclib140这种依赖，都不用自己再装\n总的来说只有Windows传奇兼容性导致四世同堂的UI问题了\n要是Windows能彻底重构一下就好了\n","date":"2024-10-25T02:16:14+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E6%8D%A2%E5%9B%9Ewin11%E4%BA%86/","title":"换回Win11了"},{"content":"这篇文章总的就是我图一乐，别当真\n最近在研究内存占用相关的问题\n（总觉得16GRam不是很够用）\n而经过一些探索后，发现内存占用这个值并不能表现内存使用情况\n内存本身就是用来缓存的，也就是说占满是正常的事情\n现代操作系统会智能地调度物理内存和虚拟内存\n像mac都能说出8GRam可以做到windows16GRam的体验\n我的平板，6GRam，空闲内存只有2G不到，但也不影响多开应用\n在mac上与linux上，有基于内存回收失败数得出的内存压力值\n而windows上，我没有找到类似的值，我也不知道有什么api可以统计出这个值\nwindows中，内存分为正在使用、已修改、备用、可用四个部分\n正在使用是正在活跃的内存，是程序频繁使用的内存页\n已修改是刚从活跃内存变为不活跃内存的内存页，需要windows调度到虚拟内存\n备用是windows将部分空闲的物理内存当作虚拟内存，这部分会看情况调度到硬盘上的虚拟内存中\n可用是真的闲的内存页\n为了缓解我的内存焦虑，我想出了一个简单的计算方法\n计算内存压力，应当考虑活跃内存、物理内存与调度方式对内存的等效放大效果\n前两个不难理解，调度方式对内存的等效放大指的是操作系统调度内存方式使得内存具有相对大的物理内存效果\n比如说，windows中，系统会自己压缩部分内存，我观察下来压缩率在30%左右，效率很高\n（在任务管理器内存部分，已使用后面跟着的已压缩，只是内存压缩策略不是很激进）\n而合理调度虚拟内存，也有这种等效放大效果\n所以我们计算内存压力，或者说计算内存占用，不应该以物理内存大小做为分母\n计算公式为\n$$内存压力=\\frac{活跃内存}{等效物理内存}$$ 并且我们也定义，当内存压力为100%时，物理内存中都是活跃内存\n这时候操作系统需要非常频繁得跟虚拟内存交互，系统不至于不能用，但会用着很难受\n现在应该思考怎么计算这个等效物理内存了\n等效物理内存中，包括活跃内存部分，暂时先不考虑压缩内存的问题，这个是用多少就是多少的\n剩下的就算非活跃内存，交给系统让它自己调度即可\n所以一个简单的算法就出来了\n$$内存压力=\\frac{活跃内存}{非活跃内存*非活跃内存等效放大参数+活跃内存}$$ 这里只要选择一个合适的非活跃内存等效放大参数即可，我感觉可以选择2作为参数\n这就相当于认为所有的非活跃内存都会移动到虚拟内存中\n根据公式，一台安装16GRam的电脑在活跃内存为10.6G的时候，内存压力为50%\n这个公式优化空间挺大的，并没有考虑多样的内存管理方法，仅采用一个经验参数计算\n实际计算的值也是比较保守的，计算出50%的内存压力体感上应该是42%左右\n不过无所谓了，自己闲着没事随便想想的，或许之后会自己写个小工具玩玩\n总之，我之前一直有严重的内存焦虑，总觉得内存占满了就不行了，所以我一直有手动清理后台的习惯\n（这跟我以前常年使用低端机有关系）\n现在内存虽然不至于很大，但不至于像以前不肯给内存，加上现代操作系统也能自己调度内存，内存大小一般不是大问题\n但内存占用一直居高不下也不是办法，看着确实难受，所以还是需要一个指标来衡量内存的压力，给开发者也好判断\n","date":"2024-10-25T02:15:03+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B%E7%9A%84%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/","title":"一个内存压力的简单算法"},{"content":"这篇文章主要是记录命令的，所以没啥原理讲解\n\u0026lt;0x01\u0026gt; 安装zsh与插件\r# Debian系 sudo apt install zsh sudo apt install zsh-autosuggestions zsh-syntax-highlighting # Arch系 sudo pacman -S zsh sudo pacman -S zsh-autosuggestions zsh-syntax-highlighting \u0026lt;0x02\u0026gt; 设置为默认shell\rchsh -s /usr/bin/zsh 重新shell进入zsh的初始配置界面\n\u0026lt;0x03\u0026gt; 配置主题\r通过git下载\r找个地方放这个主题\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git # github访问不上的话 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git 修改zsh启动行为\nnano ~/.zshrc 然后把这些复制到最后\nsource [git下来的文件的目录]/powerlevel10k/powerlevel10k.zsh-theme 通过yay安装\ryay zsh-theme-powerlevel10k 然后把这些复制到.zshrc最后\nnano ~/.zshrc source /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme \u0026lt;0x04\u0026gt; 配置插件\rapt和pacman的安装路径不同，导致需要添加的文本不同 都是在.zshrc最后添加\n# Debian系 source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh # Arch系 source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 配置完重新启动下会话，应该就生效了\n","date":"2024-10-24T08:47:43+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AEzsh/","title":"简单配置zsh"},{"content":"因为学校的操作系统课程设计要用这玩意，所以就要配置这个玩意\n（看之后能说的东西多不多，多的话单开一个分类）\n配置这玩意相对还是快的，但我也走了点弯路\n我的环境是WSL的Debian\n\u0026lt;0x00\u0026gt; 前置\r需要配置WSL，然后安装Debian\n然后需要git和稳定的维图诺·普莱维特·奈特沃克\n\u0026lt;0x01\u0026gt; 拉取pintos仓库\rgit clone git://pintos-os.org/pintos-anon --depth=1 需要提前配置下git的proxy，不然可能会很慢\n\u0026lt;0x02\u0026gt; 配置Debian需要的软件包\r# 编译环境 sudo apt install make build-essential # qemu模拟器 sudo apt install qemu-system \u0026lt;0x03\u0026gt; 简单配置\r修改./src/threads/Make.vars中的SIMULATOR\nSIMULATOR = --qemu 新版本Linux不包含stropts.h，我们创建一个空的就可以了\nsudo nano /usr/include/stropts.h 然后修改./src/utils/squish-pty.c，注释下面的代码，大概在288行\n// 注释这些代码 if (isastream (slave)) { if (ioctl (slave, I_PUSH, \u0026#34;ptem\u0026#34;) \u0026lt; 0 || ioctl (slave, I_PUSH, \u0026#34;ldterm\u0026#34;) \u0026lt; 0) fail_io (\u0026#34;ioctl\u0026#34;); } 这样就可以了\n（网上说的其他修改貌似都不是很关键）\n\u0026lt;0x04\u0026gt; 尝试运行\r在工作路径./src下面一条条执行\n# 编译utils的文件 cd ./utils make # 回到./src cd .. # 编译内核 cd ./threads make # 进入编译好的内核文件夹 cd ./build # 通过提供的脚本运行pintos ../../utils/pintos -- run alarm-multiple 理论上pintos就会运行了\n不要用Arch编译这个东西\r如果使用Arch编译这个东西的话会发现loader.bin的大小有128M\n而不是正常的512字节\n不只是WSL中Arch会出现这个问题，物理机Manjaro也会这样\n具体原因不是很清楚，我怀疑是gcc版本问题\n我测试过Ubuntu22的gcc11和Debian12的gcc12，这两个都可以成功编译\n但Arch的是gcc14，可能较高的gcc版本导致编译行为不符合预期\n不过我暂时还没尝试在Arch中使用gcc11编译过\n（源码安装gcc11，编译就要几个小时，先摸了）\n","date":"2024-10-24T00:40:35+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEpintos/","title":"如何配置pintos"},{"content":"这几天折腾了一些obsidian的插件\n利用这些插件，优化了博客的发布流程\n\u0026lt;0x01\u0026gt; Hide Folders\r我原本的obsidian的工作目录是在content的\n为什么不设置在博客的根目录呢，因为这样做会显示很多多余的文件夹\n这样会很乱\n通过Hide Folders，就可以把这些不需要的文件夹隐藏\n这样就干净多了\n\u0026lt;0x02\u0026gt; Terminal\r一个快速启动终端的插件\n主要是我为博客写了很多脚本，这样的话我管理就会很灵活\n所以我就需要这样的一个启动终端的插件\n其实obsidian也有能跑python脚本的插件，或许那个也挺合适的\n（但我从powershell迁移的成本有点大）\n\u0026lt;0x03\u0026gt; Git\r这个可以说很经典了\n通过git，可以同步博客的所有设置，可以在任何设备写博客了\n删除hugo主题里面的.git\rhugo这里的话需要注意的是主题问题\n跟着教程配置主题会让你把需要的主题git clone下来\n这会导致在根目录初始化git的时候会将这个主题识别为子模块\n然后主题里面的配置就不会跟着同步了\n这不好，hugo的主题本身就有很多的配置选项\n所以我们需要将主题文件夹里面的.git删掉，这样就可以同步主题配置了\n如果之后要更新主题，那只能自己手动把新文件复制进去或者写脚本了\n创建.gitignore\r在git的时候，我们其实不必同步整个文件夹\n其中的有些文件是hugo运行后会自己生成的\n把这些文件添加到.gitignore，让git忽略这些文件，减轻同步压力\n在博客根目录创建.gitignore\npublic/ resources/_gen 然后在./.obsidian里面创建.gitignore\nworkspace.json 前两个是hugo本身会生成的\n最后一个是obsidian界面布局文件，可以不同步\ngit初始化\r然后就可以git初始化同步到远程仓库了\n","date":"2024-10-23T13:49:51+08:00","permalink":"https://mlacookie.github.io/article/categories/blog/%E4%BC%98%E5%8C%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/","title":"优化博客的发布流程"},{"content":"xmake对于个人项目来说，构建比cmake简单太多，少折腾太多\n但在我之前测试的时候，发现xmake链接glfw库的时候会出链接错误\n这个问题是xmake在获取包时，倾向使用静态的库\n这就导致部分包在链接时会无法解析符号之类的问题\n（有些包反过来，使用静态库会无法解析符号，这次的例子也有）\n至于为什么，我目前也不是很清楚\n总之，打开xmake.lua\nadd_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) add_requires(\u0026#34;glad\u0026#34;) add_requires(\u0026#34;glfw3\u0026#34;, {configs = {shared = true}}) target(\u0026#34;XmakeTest\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) set_languages(\u0026#34;cxx17\u0026#34;) set_warnings(\u0026#34;all\u0026#34;) add_packages(\u0026#34;glad\u0026#34;) add_packages(\u0026#34;glfw3\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) set_toolchains(\u0026#34;clang\u0026#34;) 别的不重要，关键是这两句add_requires()\n对于glad，xmake默认会使用静态库，并且经过测试，使用动态库会报错\n对于glfw3，通过{configs = {shared = true}}，指定使用动态库\n这样之后，编译就不会找不到符号了\n下面做一些进阶一些的开发，经典做imgui的开发\n测试代码在之前这篇博客有写\n不过xmake.lua还是有点坑的，这里贴一下\nadd_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) add_requires(\u0026#34;fmt\u0026#34;) add_requires(\u0026#34;glad\u0026#34;) add_requires(\u0026#34;glfw3\u0026#34;, {configs = {shared = true}}) add_requires(\u0026#34;vcpkg::imgui\u0026#34;,{ configs = { features = { \u0026#34;opengl3-binding\u0026#34;, \u0026#34;glfw-binding\u0026#34;, \u0026#34;docking-experimental\u0026#34; }, shared = true } }) target(\u0026#34;XmakeTest\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) set_languages(\u0026#34;cxx17\u0026#34;) set_warnings(\u0026#34;all\u0026#34;) add_packages(\u0026#34;fmt\u0026#34;) add_packages(\u0026#34;glad\u0026#34;) add_packages(\u0026#34;glfw3\u0026#34;) add_packages(\u0026#34;vcpkg::imgui\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) set_toolchains(\u0026#34;clang\u0026#34;) 使用vcpkg来获取imgui库，然后通过清单指定特性，还要指定动态库\n一切正常的话结果应该是这样的\n","date":"2024-08-31T21:31:55+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/xmake%E5%81%9Aopengl%E5%BC%80%E5%8F%91%E6%97%B6%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%AC%A6%E5%8F%B7/","title":"xmake做opengl开发时无法解析符号"},{"content":"考虑到C++主流还是用CMake做构建，最近也稍微折腾了下CMake\n然后C++的话还是要用些包管理的，不然手动管理太抽象了\n所以还需要配置下vcpkg的东西\n虽然微软这确实有文档讲怎么配，不过讲得不是很清楚\n\u0026lt;0x00\u0026gt; 前置准备\r系统方面\rCMake\r既然是CMake配置，所以系统里肯定要安装CMake的\n命令行敲cmake能找到就行，我这里采用scoop安装\nscoop install cmake vcpkg\r然后是包管理器vcpkg\n网上很多教程是下载源码的，我这里也是采用scoop安装\nscoop install vcpkg 采用scoop安装的话会自动添加VCPKG_ROOT的环境变量，指向的就是安装路径\n虽然这个主要是方便MSBuild找vcpkg的，跟这篇博客没关系\n（自己下载源码的话手动添加一个就可以了）\nVSCode方面\r主要是C/C++ Extension Pack和CMake Tools\n\u0026lt;0x01\u0026gt; CMake工程配置\r首先新建一个文件夹，相当于是工程文件夹了\n快速创建CMake工程\rVSCode中Ctrl+Shift+P调出命令面板\n输入CMake: Quick Start后回车\n在输入完名字之类的东西之后，会让你设置一个preset\n这个比较关键，选择最后从编译器创建\n（windows平台下貌似直接绑定MSVC，选别的编译器也会换成MSVC）\n这时候会创建一些文件，先不管\n初始化vcpkg\r打开终端窗口，输入下面的命令\nvcpkg new --application 这时候也会创建一些文件，也不需要管\n让CMake认识vcpkg\r打开CMakePresets.json，里面可以看到一些配置\n{ \u0026#34;version\u0026#34;: 8, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;clang\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Clang 18.1.8 x86_64-pc-windows-msvc\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Using compilers: C = C:\\\\Users\\\\cookie\\\\scoop\\\\apps\\\\llvm\\\\current\\\\bin\\\\clang.exe, CXX = C:\\\\Users\\\\cookie\\\\scoop\\\\apps\\\\llvm\\\\current\\\\bin\\\\clang++.exe\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/out/build/${presetName}\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_INSTALL_PREFIX\u0026#34;: \u0026#34;${sourceDir}/out/install/${presetName}\u0026#34;, \u0026#34;CMAKE_C_COMPILER\u0026#34;: \u0026#34;C:/Users/cookie/scoop/apps/llvm/current/bin/clang.exe\u0026#34;, \u0026#34;CMAKE_CXX_COMPILER\u0026#34;: \u0026#34;C:/Users/cookie/scoop/apps/llvm/current/bin/clang++.exe\u0026#34;, \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34; } } ] } （这里贴出我的结果，指定为clang）\n这时候，CMake其实不知道vcpkg在哪里，我们需要让它知道vcpkg在哪\n我先贴出最后的结果\n{ \u0026#34;version\u0026#34;: 8, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/out/build\u0026#34;, // 添加的环境变量 \u0026#34;environment\u0026#34;: { // 这里写上vcpkg的安装路径 \u0026#34;VCPKG_ROOT\u0026#34;: \u0026#34;C:\\\\Users\\\\cookie\\\\scoop\\\\apps\\\\vcpkg\\\\current\u0026#34;, // 魔法上网的话 \u0026#34;HTTP_PROXY\u0026#34;: \u0026#34;127.0.0.1:1000\u0026#34;, \u0026#34;HTTPS_PROXY\u0026#34;: \u0026#34;127.0.0.1:1000\u0026#34; }, \u0026#34;cacheVariables\u0026#34;: { // 让CMake可以找到vcpkg，一般这样写就可以 \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;: \u0026#34;$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34;, \u0026#34;CMAKE_INSTALL_PREFIX\u0026#34;: \u0026#34;${sourceDir}/out/install/${presetName}\u0026#34;, // 因为windows下vcpkg自己会覆盖编译器设置为MSVC，所以也可以不指定 \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34; } } ] } 已经通过注释指出需要添加的部分，写完就好了，顺便删点不需要的\n这里相当于是一个虚拟环境，如果有其他要用到的环境变量的话也要写进environment里\n\u0026lt;0x02\u0026gt; 实战测试\r这里做一个简单的opengl开发演示\nvcpkg中添加需要的包\r打开终端，指定vcpkg需要glfw3和glad这两个包\nvcpkg add port glfw3 vcpkg add port glad CMake中引用并链接包\r然后，打开CMakeLists.txt\ncmake_minimum_required(VERSION 3.10) project(CmakeTest) add_executable(CmakeTest main.cpp) # 引用包 find_package(glad CONFIG REQUIRED) find_package(glfw3 CONFIG REQUIRED) # 链接包 target_link_libraries(CmakeTest PRIVATE glfw) target_link_libraries(CmakeTest PRIVATE glad::glad) 在代码中使用\r最后，打开main.cpp\n#include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;iostream\u0026gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \u0026#34;LearnOpenGL\u0026#34;, NULL, NULL); if (window == NULL) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to create GLFW window\u0026#34; \u0026lt;\u0026lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to initialize GLAD\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } while (!glfwWindowShouldClose(window)) { processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0; } void processInput(GLFWwindow *window) { if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } void framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } （这段代码是Learn OpenGL的代码，直接复制就能跑，所以就删注释了）\n编译成功并运行的话应该是这样的\n一切正常的话，恭喜完成配置，之后这样配置也能用\n\u0026lt;0x03\u0026gt; 进阶设置\r如果使用的包有可选特性\r在vcpkg中，有一些包是有可选特性的\n比如说imgui这个库，有很多可选特性，比如docking，opengl3，win32等等\n比方说做opengl的开发，添加包的时候可以这么写\nvcpkg add port imgui[opengl3-binding,glfw-binding,docking-experimental] 然后修改CMakeLists.txt部分，加上下面的东西\nfind_package(imgui CONFIG REQUIRED) # example改成自己的项目 target_link_libraries(example PRIVATE imgui::imgui) 然后打开main.cpp测试下\n#include \u0026#34;imgui.h\u0026#34; #include \u0026#34;imgui_impl_glfw.h\u0026#34; #include \u0026#34;imgui_impl_opengl3.h\u0026#34; #include \u0026lt;fmt/core.h\u0026gt; #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; // glfw错误回调 static void glfw_error_callback(int error, const char *description) { fmt::println(\u0026#34;GLFW Error {}: {}\u0026#34;, error, description); } int main(int, char **) { glfwSetErrorCallback(glfw_error_callback); if (!glfwInit()) { return -1; } // 设定opengl版本 const char *glsl_version = \u0026#34;#version 130\u0026#34;; glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); // 创建窗口 GLFWwindow *window = glfwCreateWindow(1280, 720, \u0026#34;ImGui GLFW+OpenGL3 with docking example\u0026#34;, nullptr, nullptr); if (window == nullptr) { return -1; } glfwMakeContextCurrent(window); glfwSwapInterval(1); // 初始化glad if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { fmt::println(\u0026#34;Failed to initialize GLAD\u0026#34;); return -1; } // 初始化imgui IMGUI_CHECKVERSION(); ImGui::CreateContext(); ImGuiIO \u0026amp;io = ImGui::GetIO(); (void)io; io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // 启用docking io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; ImGui::StyleColorsDark(); // 启用docking的后处理 ImGuiStyle\u0026amp; style = ImGui::GetStyle(); if (io.ConfigFlags \u0026amp; ImGuiConfigFlags_ViewportsEnable) { style.WindowRounding = 0.0f; style.Colors[ImGuiCol_WindowBg].w = 1.0f; } ImGui_ImplGlfw_InitForOpenGL(window, true); ImGui_ImplOpenGL3_Init(glsl_version); // 渲染循环 while (!glfwWindowShouldClose(window)) { // 初始化渲染 glfwPollEvents(); ImGui_ImplOpenGL3_NewFrame(); ImGui_ImplGlfw_NewFrame(); ImGui::NewFrame(); // 渲染demo窗口 ImGui::ShowDemoWindow(); // 真正开始渲染 ImGui::Render(); int display_w, display_h; glfwGetFramebufferSize(window, \u0026amp;display_w, \u0026amp;display_h); glViewport(0, 0, display_w, display_h); glClearColor(.1f, .1f, .1f, 1); glClear(GL_COLOR_BUFFER_BIT); ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData()); // docking处理 if (io.ConfigFlags \u0026amp; ImGuiConfigFlags_ViewportsEnable) { GLFWwindow* backup_current_context = glfwGetCurrentContext(); ImGui::UpdatePlatformWindows(); ImGui::RenderPlatformWindowsDefault(); glfwMakeContextCurrent(backup_current_context); } glfwSwapBuffers(window); } // 退出的处理 ImGui_ImplOpenGL3_Shutdown(); ImGui_ImplGlfw_Shutdown(); ImGui::DestroyContext(); glfwDestroyWindow(window); glfwTerminate(); return 0; } （稍微修改了imgui给的示例，使用了glad和fmt）\n对于多人开发的情况\r前面提到，我们可以用CMakePresets.json来统一设定CMake的变量\n但对于多人开发的情况，这个方式有一些弊端\n比如，windows下，不同人编译器的位置一般是不一样的\n（谁叫windows就没什么标准路径）\n这时候，可以引入CMakeUserPresets.json文件做具体的设定\n比方说接着上面的配置，我们可以把CMakePresets.json改造成这样\n{ \u0026#34;version\u0026#34;: 8, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/out/build\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;: \u0026#34;$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34;, \u0026#34;CMAKE_INSTALL_PREFIX\u0026#34;: \u0026#34;${sourceDir}/out/install/${presetName}\u0026#34;, \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34; } } ] } 加上CMakeUserPresets.json，内容为\n{ \u0026#34;version\u0026#34;: 8, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;My default\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;environment\u0026#34;: { \u0026#34;SCOOP_ROOT\u0026#34;: \u0026#34;C:/Users/cookie/scoop\u0026#34;, \u0026#34;VCPKG_ROOT\u0026#34;: \u0026#34;$env{SCOOP_ROOT}/apps/vcpkg/current\u0026#34;, \u0026#34;HTTP_PROXY\u0026#34;: \u0026#34;127.0.0.1:1000\u0026#34;, \u0026#34;HTTPS_PROXY\u0026#34;: \u0026#34;127.0.0.1:1000\u0026#34; } } ] } CMakePresets.json定义总体的框架，CMakeUserPresets.json定义具体的位置\n在git设置中，排除CMakeUserPresets.json就可以了\n","date":"2024-08-29T21:17:56+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8cmake+vcpkg/","title":"在vscode中使用cmake+vcpkg"},{"content":"我的vscode其中一个配置是xmake+clangd的配置\n因为要写OpenGL相关的代码，clangd中默认头文件排序就很头疼\n找了半天方法，虽然没找到直接配置clangd.arguments之类的方法\n但也是有相对简单的方法解决这个问题\n在项目根目录新建.clang-format文件\n输入下面的内容\nBasedOnStyle: Microsoft SortIncludes: Never 因为我之前就是使用clangd自带的Microsoft配置\n这里的BasedOnStyle相当于继承这个配置\n下面的一句是关闭头文件排序\n","date":"2024-08-26T16:04:41+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E5%85%B3%E9%97%ADclangd%E5%A4%B4%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/","title":"关闭clangd头文件排序"},{"content":"emmmm\n之前在笔记本上安装了Manjaro\n基本上所有需要的软件都有了解决方案\n甚至打游戏都不是很大的问题\n结果没想到败在了游戏加速器上\nLinux没有现成的游戏加速器，而且我不会配网卡类型的代理\n（就算配起来我也没有游戏优化的代理服务器）\n所以没办法，又要用Windows了\n不过我又不想放弃Linux的轻量精简\n于是我就给笔记本做了个双系统\n（因为在物理机上安装，所以目前没什么图，有机会再补吧）\n\u0026lt;0x00\u0026gt; 前置准备\r首先需要一个U盘，做系统安装盘\n这次仍然使用Ventoy做系统引导\nVentoy的使用就不说了，基本上就是软件打开选择U盘安装即可 然后需要准备需要的Windows镜像和Manjaro镜像\n还需要一个WinPE的镜像，我的建议是用微PE工具生成一个\n我们需要使用这个PE来提前给硬盘分区\n\u0026lt;0x01\u0026gt; PE中的操作\rPE中，我们主要是给系统进行分盘\n如果你会在Windows安装器中分盘的话可以跳过\nVentoy引导进PE的iso\n一般PE中会带一个分区工具，有啥用啥，我使用的是DG\n里面有个快速分区工具，使用这个分两个盘，大小随意\n分出来都是NTFS格式的，删除希望安装Manjaro的分区，等之后用Manjaro安装工具分区\n分好区后，保存更改，就可以退出PE系统了\n为什么要提前分盘\r现在我们安装系统都是将硬盘做成GPT分区格式\n里面有一个EFI分区，里面会放系统的引导\n如果用Windows安装器在没有任何分区的硬盘上安装\n它会自动创建一个100MB的EFI分区\n但对Linux来说，这100MB的EFI分区太小了，Linux建议大于300MB\n而DG的快速分区可以在分出两个大小的分区的同时，自动创建300MB的EFI分区\n正好满足我们的需求\n\u0026lt;0x02\u0026gt; 安装Windows\rVentoy引导进Windows的iso\nWindows安装在之前分的你希望的位置\n基本上就按照安装器指引即可\n\u0026lt;0x03\u0026gt; 安装Manjaro\rVentoy引导进Manjaro的iso\n在安装中，需要选择最下面的手动分区\n对于300MB的EFI分区，我们需要编辑，设置挂载点为/boot/efi，下面的标记别动\n这个很关键，将影响我们能否引导进系统\n对于希望安装Manjaro的位置，首先新建分区，我选择的是ext4\n然后编辑分区，设置挂载点为/，选择标记为boot 剩下的挂载点我看别人是有配置的，不过这样配置两个挂载点就够了\n剩下就让安装器折腾就可以了\n安装后进入BIOS，设置硬盘的启动项，这时候里面会有一个Manjaro的选项\n（注意不是启动项，是硬盘的启动项，管理一个硬盘里面的启动项）\n这样之后，理论上启动后默认进入Manjaro的grub界面\n","date":"2024-08-22T22:04:25+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E9%85%8D%E7%BD%AEwindows+manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F/","title":"配置Windows+Manjaro双系统"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：小A点菜\r洛谷的P1164\n题目背景\ruim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。\nuim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。\n题目描述\r不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \\le 10000)$。\n餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \\le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \\le 1000)$\n由于是很低端的餐馆，所以每种菜只有一份。\n小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完\n他想知道有多少种点菜方法。\n由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。\n输入格式\r第一行是两个数字，表示 $N$ 和 $M$。\n第二行起 $N$ 个正数 $a_i$（可以有相同的数字，每个数字均在 $1000$ 以内）。\n输出格式\r一个正整数，表示点菜方案数，保证答案的范围在 int 之内。\n样例\r样例输入\r4 4 1 1 2 2 样例输出\r3 \u0026lt;0x01\u0026gt; 分析\r一道简单的计数dp的题，逻辑上跟之前的摆花差不多\n需要解决的是怎么把点菜方式统计转换为一个递推的关系\n以样例举例\n根据之前的经验，状态转移方程大概长这样$f(i,j)$\n其中$i$表示处理了前$i$个数据，$j$表示花了$j$元钱\n其中，$i\\in[0,n-1],j\\in[0,m]$，因为花了0元也算花钱\n然后先把每个情况的值都列出来，再看看有什么规律\ni→ j * 1 1 2 2 ↓ 0 1 1 1 1 1 1 2 2 2 2 0 1 2 3 3 0 0 2 4 4 0 0 1 3 不难发现，状态转移方程是$f(i,j)=f(i-1,j-a_i)+f(i-1,j)$\n如果$j-a_i\u0026lt;0$那么$f(i-1,j-a_i)=0$\n怎么理解这个方程呢\n假设此时遍历到了最后一个2，我们要计算花了3元的情况\n这时候，对于前面花了1元的情况，只要再点这个2元的菜就凑够了3元\n对于前面已经花了3元的情况，不点这个菜也够了3元\n所以这两个的值相加就是此时花3元的方法总数\n因为遍历过程中，仅考虑了$i$和$i-1$的情况，所以可以省略$i$这个维度\n可以进一步压缩空间，但要注意遍历顺序\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入 int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; list(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; list[i]; } // 初始化第一个状态 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; dp(n, std::vector\u0026lt;int\u0026gt;(m + 1)); dp[0][0] = 1; dp[0][list[0]] = 1; // 开始dp for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= m; j++) { if (j - list[i] \u0026gt;= 0) { dp[i][j] = dp[i - 1][j - list[i]] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } // 输出最后一个值 std::cout \u0026lt;\u0026lt; dp[n - 1][m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-08-14T11:14:35+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9216-%E5%B0%8Fa%E7%82%B9%E8%8F%9C/","title":"算法康复计划16 小A点菜"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：滑雪\r洛谷的P1434\n题目描述\rMichael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激\n可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你\nMichael 想知道在一个区域中最长的滑坡\n区域由一个二维数组给出。数组的每个数字代表点的高度\n下面是一个例子：\n1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小\n在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）\n当然 $25-24-23-\\ldots-3-2-1$ 更长。事实上，这是最长的一条。\n输入格式\r输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$\n下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。\n输出格式\r输出区域中最长滑坡的长度。\n样例\r样例输入\r5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 样例输出\r25 数据规模与约定\r对于 $100%$ 的数据，$1\\leq R,C\\leq 100$。\n\u0026lt;0x01\u0026gt; 分析\r还是动态规划的题，这次就不想状态转移方程了\n来试试记忆化搜索\n记忆化搜索本质上就是遇到搜索过的地方就直接返回搜索的结果\n对于搜索过程中遇到更好的情况也对之前的结果进行更新\n一般思路是先写出正常的DFS过程\n然后用某种数据结构做记忆化，配合一些条件做结果更新\n这样就完成了记忆化搜索的改造\n记忆化搜索也是可以转换为状态转移方程的\n但状态转移方程不一定能转换成记忆化搜索的\n而且一般情况下两个方法的时间空间复杂度差不多\n对于这道题，主要就是记忆化搜索的过程\n需要注意的是，二维矩阵需要默认初始化为1\n因为对于每一段路，长度都是1，默认为0的话就加不出来了\n\u0026lt;0x02\u0026gt; 代码\r// 带各种封装，所以代码量大 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 点的封装 struct Point { public: int x; int y; Point() { x = 0; y = 0; } Point(int x, int y) { this-\u0026gt;x = x; this-\u0026gt;y = y; } Point(const Point \u0026amp;c) { x = c.x; y = c.y; } }; // 二维矩阵的封装 class Map { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; _map; public: int X; int Y; Map(int x, int y) { X = x; Y = y; _map.resize(y, std::vector\u0026lt;int\u0026gt;(x, 1)); } Map(const Map \u0026amp;c) { X = c.X; Y = c.Y; _map.resize(c.Y, std::vector\u0026lt;int\u0026gt;(c.X)); for (int i = 0; i \u0026lt; Y; i++) { for (int j = 0; j \u0026lt; X; j++) { _map[i][j] = c._map[i][j]; } } } int \u0026amp;At(int x, int y) { return _map[y][x]; } int \u0026amp;At(Point \u0026amp;p) { return _map[p.y][p.x]; } }; // DFS搜索的封装 class DFS { // 记忆化矩阵 Map _mem; int dfs(Map \u0026amp;m, Point p) { // 如果已经搜索过就返回 if (_mem.At(p) != 1) { return _mem.At(p); } // 4方向遍历 int dx[] = {1, -1, 0, 0}; int dy[] = {0, 0, 1, -1}; for (int i = 0; i \u0026lt; 4; i++) { int tx = p.x + dx[i]; int ty = p.y + dy[i]; // 出界判断 if (tx \u0026lt; 0 || ty \u0026lt; 0) { continue; } if (tx \u0026gt;= _mem.X || ty \u0026gt;= _mem.Y) { continue; } // 条件判断 if (m.At(p) \u0026gt; m.At(tx, ty)) { // 取最大值 _mem.At(p) = std::max(_mem.At(p), dfs(m, Point(tx, ty)) + 1); } } // 更新全局最大值 max = std::max(max, _mem.At(p)); return _mem.At(p); } public: int max = 0; DFS(Map \u0026amp;m) : _mem(m.X, m.Y) { // 遍历所有起始点 for (int i = 0; i \u0026lt; m.X; i++) { for (int j = 0; j \u0026lt; m.Y; j++) { dfs(m, Point(i, j)); } } } }; int main() { // 读入 int r, c; std::cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; Map map(c, r); for (int i = 0; i \u0026lt; r; i++) { for (int j = 0; j \u0026lt; c; j++) { std::cin \u0026gt;\u0026gt; map.At(j, i); } } // 计算 DFS ans(map); // 输出 std::cout \u0026lt;\u0026lt; ans.max \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r有笨比最后没有遍历所有起点，导致Debug半天\n因为有可能会分多个区域，一次遍历是不够的\n","date":"2024-08-13T22:31:55+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9215-%E6%BB%91%E9%9B%AA/","title":"算法康复计划15 滑雪"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：最大子段和\r洛谷的P1115\n题目描述\r给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n输入格式\r第一行是一个整数，表示序列的长度 $n$。\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。\n输出格式\r输出一行一个整数表示答案。\n样例\r样例输入\r7 2 -4 3 -1 2 -4 3 样例输出\r4 样例解释\r选取 $[3, 5]$ 子段 ${3, -1, 2}$，其和为 $4$。\n数据规模与约定\r对于 $40%$ 的数据，保证 $n \\leq 2 \\times 10^3$。 对于 $100%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。 \u0026lt;0x01\u0026gt; 分析\r这道题需要贪心+dp的思路\n对于样例的数据\n从2开始，$2+(-4)=-2\u0026lt;2$\n这意味着如果答案包含-4，那么也一定包含前面的2，不如就很难把数字撑大\n接着加，$(-2)+3=1\u0026lt;3$，这意味着如果答案包含-4，那么也会包含这个3\n而且会发现，接着这条链不如新开一条链，因为前面的数字相当于累赘\n所以从3开始加，$3+(-1)=2\u0026gt;-1$，$2+2=4\u0026gt;2$，$4+(-4)=0\u0026gt;-4$，$0+3=3=3$\n这里也发现一个问题，之前写的动态规划的题一般最后的状态就是答案\n但这里的答案在过程中间，所以需要一个存储最大值的变量\n所以最后的状态转移方程是$f(i)=max(a_i,f(i-1)+a_i)$\n其中，$i$表示已处理前$i$个数据，$a_i$是输入的数组\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入 int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;long long\u0026gt; list(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; list[i]; } // 初始化第一个状态 std::vector\u0026lt;long long\u0026gt; map(n); map[0] = list[0]; long long ans = INT_MIN; for (int i = 1; i \u0026lt; n; i++) { // 如果前面加上的还不如新开一条的话就丢弃 map[i] = std::max(list[i], map[i - 1] + list[i]); // 更新答案 ans = std::max(ans, map[i]); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r一开始想不到贪心+dp的思路\n所以是看了题解后才会的题\n","date":"2024-08-12T23:22:58+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9214-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/","title":"算法康复计划14 最大子段和"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：5倍经验日\r洛谷的P1802\n题目背景\r现在乐斗有活动了！每打一个人可以获得 5 倍经验！\nabsi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。\n题目描述\r现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。\n由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。\n悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。\n例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。\n现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。\n要求求出最大经验 $s$，输出 $5s$。\n输入格式\r第一行两个数，$n$ 和 $x$\n后面 $n$ 行每行三个数，分别表示失败时获得的经验 $\\mathit{lose}_i$\n胜利时获得的经验 $\\mathit{win}_i$ 和打过要至少使用的药数量 $\\mathit{use}_i$。\n输出格式\r一个整数，最多获得的经验的五倍。\n样例\r样例输入\r6 8 21 52 1 21 70 5 21 48 2 14 38 3 14 36 1 14 36 2 样例输出\r1060 提示\r【Hint】\n五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。\n【题目来源】\nfight.pet.qq.com\nabsi2011 授权题目\n数据规模与约定\r对于 $10%$ 的数据，保证 $x=0$。 对于 $30%$ 的数据，保证 $0\\le n\\le 10$，$0\\le x\\le 20$。 对于 $60%$ 的数据，保证 $0\\le n,x\\le 100$， $10\u0026lt;lose_i,win_i\\le 100$，$0\\le use_i\\le 5$。 对于 $100%$ 的数据，保证 $0\\le n,x\\le 10^3$，$0\u0026lt;lose_i\\le win_i\\le 10^6$，$0\\le use_i\\le 10^3$。 \u0026lt;0x01\u0026gt; 分析\r嗯，动态规划，我们都知道\n但是怎么动态规划呢\n看到这样的题，首先要去想状态转移方程会是怎么样的\n根据之前的经验，大概是这样$f(i,j)$\n其中$i$表示处理前$i$个数据，$j$表示已经用了$j$瓶药\n那总体的逻辑就很像背包dp了\n但这个也不同于经典背包dp，还需要处理输了的情况\n这就导致状态转移不止一个式子，我这里写不明白就不写了\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 封装一个敌人类 class Enemy { public: int lose; int win; int use; Enemy(int lose, int win, int use) { this-\u0026gt;lose = lose; this-\u0026gt;win = win; this-\u0026gt;use = use; } }; int main() { // 读入 int n, x; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; std::vector\u0026lt;Enemy\u0026gt; list; for (int i = 0; i \u0026lt; n; i++) { int a, b, c; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; list.push_back(Enemy(a, b, c)); } // 初始化第一个状态 std::vector\u0026lt;size_t\u0026gt; map(x + 1); map[0] = list[0].lose; if (list[0].use \u0026lt;= x) { map[list[0].use] = list[0].win; } // 开始dp for (int i = 1; i \u0026lt; n; i++) { // 注意循环方向 for (int j = x; j \u0026gt;= 0; j--) { if (map[j] == 0) { continue; } // 处理剩下的药够嗑的情况 if (j + list[i].use \u0026lt;= x) { map[j + list[i].use] = std::max(map[j + list[i].use], map[j] + list[i].win); } // 处理不需要嗑药的情况 if (list[i].use != 0) { map[j] += list[i].lose; } } } // 遍历最大值 size_t ans = 0; for (auto i : map) { ans = std::max(ans, i); } // 乘5输出 std::cout \u0026lt;\u0026lt; ans * 5 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r因为省略状态转移方程的第一个参数，所以要注意循环方向\n还有就是当某个敌人不需要嗑药也能打过的时候需要特殊处理\n如果不处理会导致赢了和输了都计算一遍\n","date":"2024-08-12T01:00:02+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9213-5%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/","title":"算法康复计划13 5倍经验日"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：摆花\r洛谷的P1077\n题目描述\r小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆\n通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号\n为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆\n摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。\n试编程计算，一共有多少种不同的摆花方案。\n输入格式\r第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。\n第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \\cdots ,a_n$。\n输出格式\r一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。\n样例\r样例输入\r2 4 3 2 样例输出\r2 数据规模与约定\r对于 $20%$ 数据，有 $0\u0026lt;n \\le 8,0\u0026lt;m \\le 8,0 \\le a_i \\le 8$。\n对于 $50%$ 数据，有 $0\u0026lt;n \\le 20,0\u0026lt;m \\le 20,0 \\le a_i \\le 20$。\n对于 $100%$ 数据，有 $0\u0026lt;n \\le 100,0\u0026lt;m \\le 100,0 \\le a_i \\le 100$。\n\u0026lt;0x01\u0026gt; 分析\r（也可以用记忆化搜索，不过考虑到练dp这里就不使用）\n这是一道动态规划题\n虽然看着不像是动态规划，倒是挺像递推的题\n属于是计数dp的类型，思路上确实接近递推\n定义状态转移方程$f(i,j)=\\sum_{t=0}^{a_i}f(i-1,j-t)$\n其中$i$表示前$i$种花，$j$表示已经放了$j$盆花\n怎么理解这个状态转移方程呢\n因为题目的限制，我们只需要考虑每种花要摆几盆即可\n对于每次递推，我们可以想象成给一串珠子再串一个珠子的过程\n假设前面已有的接法有$x$种，要到目标盆数$y$，则还需要$y-x$盆这个数是固定的\n也就是前面有$x$种可能，后面只有1种可能，那么直接加$x$即可\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入 int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; list(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; list[i]; } // 初始化，注意map的第二维需要多一个空间 std::vector\u0026lt;std::vector\u0026lt;size_t\u0026gt;\u0026gt; map; map.resize(n, std::vector\u0026lt;size_t\u0026gt;(m + 1)); // 初始化第一种花的情况 for (int i = 0; i \u0026lt;= list[0]; i++) { map[0][i] = 1; } // 开始dp for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= m; j++) { map[i][j] = 0; for (int t = 0; j - t \u0026gt;= 0 \u0026amp;\u0026amp; t \u0026lt;= list[i]; t++) { map[i][j] += map[i - 1][j - t]; map[i][j] %= 1000007; } } } // 输出最后的结果 std::cout \u0026lt;\u0026lt; map[n - 1][m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-08-10T00:04:15+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9212-%E6%91%86%E8%8A%B1/","title":"算法康复计划12 摆花"},{"content":"这几天有别的事情忙，所以算法练习就搁置了几天\n\u0026lt;0x00\u0026gt; 今日题目：最大食物链计数\r洛谷的P4017\n题目背景\r你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了\n因为她总是重复数了几条或漏掉了几条 于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。\n题目描述\r给你一个食物网，你要求出这个食物网中最大食物链的数量。\n（这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。）\nDelia 非常急，所以你只有 $1$ 秒的时间。\n由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。\n输入格式\r第一行，两个正整数 $n、m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。\n接下来 $m$ 行，每行两个正整数，表示被吃的生物A和吃A的生物B。\n输出格式\r一行一个整数，为最大食物链数量模上 $80112002$ 的结果。\n样例\r样例输入\r5 7 1 2 1 3 2 3 3 5 2 5 4 5 3 4 样例输出\r5 数据规模与约定\r数据中不会出现环，满足生物学的要求。\n\u0026lt;0x01\u0026gt; 分析\r这道题的关键在于拓扑排序\n拓扑排序的概念可以看OI Wiki的介绍\n为什么要拓扑排序呢，因为对于这种很像之前写的过河卒的题目\n递推公式可以是这样$f(v)=\\sum_{i是可以到达v的顶点}(f(i))$\n拓扑排序可以获得这样的顺序，保证我们在计算某节点时，需要的数据都已经计算过\n得到顺序之后还需要获得原图的逆转图\n因为我们需要可以到达某顶点的信息，如果遍历全图去找的化开销太大\n还不如直接从逆转图中获取\n最后根据递推公式计算出到达终点的路径总数\n因为题目没说只有一个终点，所以还需要把所有终点的值加起来\n记得按要求取模，答案也就出来了\n\u0026lt;0x02\u0026gt; 代码\r// 因为带各种封装，所以代码就有点长 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; // 表示图的类 class Graph { // 存储图的数据，采用邻接表数组表示 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; _list; // 记录每个顶点的出度 std::vector\u0026lt;int\u0026gt; _out; // 顶点总数 int _vertexCount; public: Graph(int num) { _vertexCount = num; _list.resize(num); _in.resize(num, 0); _out.resize(num, 0); } int VertexCount() const { return _vertexCount; } // 添加边 void AddEdge(int v, int w) { for (auto i : _list[v]) { if (i == w) { return; } } _list[v].push_back(w); _out[v]++; } // 获取出度为0的顶点 std::vector\u0026lt;int\u0026gt; GetEnd() { std::vector\u0026lt;int\u0026gt; ans; for (int i = 0; i \u0026lt; _out.size(); i++) { if (_out[i] == 0) { ans.push_back(i); } } return ans; } // 获取从该顶点的可到达的下一个顶点 std::vector\u0026lt;int\u0026gt; AdjoinVertex(int v) const { return std::vector\u0026lt;int\u0026gt;(_list[v]); } // 获取反向的图 Graph InverseGraph(const Graph \u0026amp;G) { int length = G._vertexCount; Graph ans(length); for (int v = 0; v \u0026lt; length; v++) { for (auto w : _list[v]) { ans.AddEdge(w, v); } } return ans; } }; // 拓扑排序的类 class Topological { // 记录逆后续 std::stack\u0026lt;int\u0026gt; _reversePost; // 记录答案 std::vector\u0026lt;int\u0026gt; _list; // 标记是否走过 std::vector\u0026lt;bool\u0026gt; _marked; // 通过DFS法获得拓扑排序 void DFS(const Graph \u0026amp;G, int v) { _marked[v] = true; std::vector\u0026lt;int\u0026gt; temp = G.AdjoinVertex(v); for (auto w : temp) { if (!_marked[w]) { DFS(G, w); } } _reversePost.push(v); } public: // 构造函数中就完成拓扑排序 Topological(const Graph \u0026amp;G) { int length = G.VertexCount(); _marked.resize(length, false); for (int i = 0; i \u0026lt; length; i++) { if (!_marked[i]) { DFS(G, i); } } // DFS结束后保存结果 while (!_reversePost.empty()) { _list.push_back(_reversePost.top()); _reversePost.pop(); } } std::vector\u0026lt;int\u0026gt; GetAns() { return _list; } }; int main() { // 读入 int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Graph g(n); int v, w; for (int i = 0; i \u0026lt; m; i++) { std::cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; // 记得减一 g.AddEdge(v - 1, w - 1); } // 求出拓扑排序 Topological topo(g); auto order = topo.GetAns(); Graph ig = g.InverseGraph(g); // 初始化递推 std::vector\u0026lt;size_t\u0026gt; ans; ans.resize(n, 0); for (auto i : order) { std::vector\u0026lt;int\u0026gt; temp = ig.AdjoinVertex(i); if (temp.size() == 0) { ans[i] = 1; continue; } for (auto j : temp) { ans[i] += ans[j]; } ans[i] %= 80112002; } size_t o = 0; // 因为题目没说只有一个终点，所以还要这样遍历一下 for (auto i : g.GetEnd()) { o += ans[i]; o %= 80112002; } std::cout \u0026lt;\u0026lt; o \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-08-08T23:44:57+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9211-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/","title":"算法康复计划11 最大食物链计数"},{"content":"暑假经典节目，与Linux大战300回合\n这次我打算好好配置下Linux并作为日常使用\n发行版的话我使用Manjaro，因为比Arch好配置，也有AUR的便捷\n笔记本是机革的无界14+\n因为是在笔记本上装，就没啥截图了\n\u0026lt;0x00\u0026gt; 安装准备\r简单来说，找个U盘，用Ventoy做启动盘，然后把Manjaro的ISO放进去就可以\n选择你的桌面环境\rManjaroISO\n选哪个桌面环境呢，我最后选择了KDE的版本\n经过更新后，KDE的设计总算跟上时代了，颜值不错\n并且KDE环境可设置选项也挺多的，自带很多实用小工具\n其他的不是说不好，但确实不合适\nGnome一些习惯我适应不了，xfce不是很适合高分屏，其他的没试过\n用Ventoy做引导\rVentoy可以直接引导ISO启动，然后通过ISO本身装系统\n加上ISO格式的PE，完全可以当成PE用，并且装系统也很方便\n如果有装Scoop或Winget，直接敲命令安装\n# Scoop scoop install ventoy # Winget winget install Ventoy.Ventoy 没有的话就自己下载吧\nVentoy下载\n下载完后，找个U盘，打开Ventoy，安装即可\n安装好后，把下载好的ISO拖进U盘就可以\n\u0026lt;0x01\u0026gt; 安装Manjaro\rU盘插上笔记本，开机，狂按那几个进BIOS的键\n（ESC，F1，F2，F3，F10，F11，F12，DEL）\n进BIOS后，选择U盘启动\n会进入Ventoy的引导界面，选择之前导入的ISO\n然后系统会从ISO启动，进入Manjaro的启动界面\n这里它默认会使用开源驱动启动（Boot with open source drivers）\n我建议是按↓方向键，选择使用专有驱动启动（Boot with proprietary drivers）\n这样的话之后安装的也是专有驱动，遇到的驱动问题会少点\nManjaro安装环境正式启动后，你可以先试试看这个系统\n如果发现系统元素很小，而且调整系统缩放会导致比例很奇怪\n这个没什么办法，因为安装环境下使用的窗口服务是X11，对高分辨率支持不是很好\n不过安装后就可以用新的Wayland启动了，这个对高分辨率支持不错的\n确定要安装后，就可以双击安装器进行安装，这个跟着安装器指引就可以\n安装完重启，就可以进入Manjaro系统了\n\u0026lt;0x02\u0026gt; 安装完要干的事\r配置速度快的源\rManjaro内置自动配置快速软件源的工具\n打开终端\nsudo pacman-mirrors -g 执行即可，就是因为要把世界上所有源都试一遍，所以等待时间会有点久\n更新所有的包\r可以通过升级/删除软件包用图形化界面更新所有的包\n也可以敲命令\nsudo pacman -Syyu 顺便也可以看看前面配置的源的速度\n安装yay\ryay是AUR的管理器，需要注意的是，AUR并非Arch官方维护，需要自己甄别软件的安全性\n不过也正是这样，通过AUR可以非常轻松地获取其他软件\nsudo pacman -S yay base-devel 因为AUR的软件需要从源码编译，需要安装base-devel提供一些基础的工具链\nyay在安装软件时，会优先检索pacman中的内容，并且语法上跟pacman是一致的\n所以之后软件的安装/升级/删除都可以交给yay\n需要注意的是yay安装软件时不需要sudo，在需要权限提升时，它会要求输入密码的\n然后安装软件的时候，如果后缀有带bin的，一般说明是二进制版本，优先选择这个\n这样的话就不用从源代码编译了，安装会快很多\n配置fcitx5\rfcitx5是一个输入法框架，装上后再配置下就可以输入中文了\nsudo pacman -S fcitx5 fcitx5-configtool fcitx5-breeze fcitx5-chinese-addons fcitx5-gtk fcitx5-qt 安装好后，在系统设置内会多一个输入法的页面，先启动下输入法\n然后在系统设置\u0026gt;\u0026gt;键盘\u0026gt;\u0026gt;虚拟键盘中选择fcitx5即可\n再在输入法\u0026gt;\u0026gt;配置附加组件中稍微配置配置些主题之类的就可以了\n为非Wayland应用配置输入法\r目前的配置只能在使用Wayland的窗口中使用输入法\n而Linux中仍有许多软件是跑在X11上的\n对于这些软件我们需要通过环境变量让它们识别输入法\n我这里是把环境变量写到/etc/profile的方式实现\nManjaro的/etc/profile实际上是遍历运行/etc/profile.d文件夹的内容\n所以最好是在/etc/profile.d中新建文件，在里面写上环境变量\ncd /etc/profile.d nano set-fcitx5.sh 在文件中输入\nexport XMODIFIERS=@im=fcitx 保存退出后，重启系统，这块就配置好了\n现在对于大部分运行在x11中的应用是处理完了\n但对于部分软件，可能仍无法使用输入法，这就需要对软件单独配置环境变量\n# 如果软件使用QT框架 QT_IM_MODULE=fcitx # 如果软件使用GTK框架 GTK_IM_MODULE=fcitx 这两句虽然是可以直接塞在前面的配置文件中当全局变量，但官方不推荐\n\u0026lt;0x03\u0026gt; 安装其他的软件\rVS Code\r经常用的开发环境\nyay visual-studio-code-bin 安装完修改启动参数来启用wayland\n--enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime Edge\r目前我的大部分浏览器数据在Edge上\nyay microsoft-edge-stable-bin 安装完修改启动参数来启用wayland，参数跟上面的VS Code一样\nhiddify\r魔法学，不细讲\nyay hiddify-next-bin \u0026lt;0x04\u0026gt; 其他实用命令\r删除不需要的依赖\ryay -Rns $(yay -Qdt) 查看窗口运行服务\r对于高分屏，wayland的支持是好得多的\n即使KDE跑x11应用时，由于允许应用自行缩放，所以大部分情况下还是清晰的\n但跑在wayland下可以杜绝大部分控件缩放问题\n# qdbus可能不存在，改为qdbus6 qdbus org.kde.KWin /KWin org.kde.KWin.showDebugConsole 运行后会跳出一个小工具，用来查看所有窗口运行在哪个服务上\n\u0026lt;0x05\u0026gt; 遇到的奇怪闪屏问题\r不知道为什么，我安装完系统后发现系统总会有奇怪的闪屏\n换了其他桌面系统后多少都会有点\n在折腾了很多包之后，我大概定位到是AMD的2D驱动问题\nAMD的显卡驱动很散，OpenGL驱动和Vulkan驱动都是分开装的\nManjaro默认不会装Xorg的2D加速驱动，这可能是导致奇怪闪屏的原因\n安装的话很简单\nyay -S xf86-video-amdgpu 安装上之后，闪屏遇到的少了，但不能根除\n不排除Vulkan驱动的问题，AMDGPU的节能选项的问题\n","date":"2024-07-28T12:47:37+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E6%9C%BA%E9%9D%A9%E6%9C%AC%E6%9C%AC%E8%A3%85linux/","title":"机革本本装Linux"},{"content":"不知不觉写了10天了，目前只能说C++没之前这么手生了\n算法的话也算稍微接触了下动态规划，学到了很多\n\u0026lt;0x00\u0026gt; 今日题目：过河卒\r洛谷的P1002\n题目描述\r棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点\n卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点\n因此称之为“马拦过河卒”。\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的\n达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步\n输入格式\r一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n输出格式\r一个整数，表示所有的路径条数。\n样例\r样例输入\r6 6 3 3 样例输出\r6 数据规模与约定\r对于 $100 %$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\u0026lt;0x01\u0026gt; 分析\r可以当成动态规划题目来看\n因为只能往下/往右走，不存在回头的可能\n所以可以将问题分解成到上一格怎么走，上上格怎么走\n比方说(0,0)→(3,2)就可以分解成(0,0)→(2,2)+(3,1)→(3,2)，以此类推\n这样就很像之前写的数楼梯的题了\n记(0,0)→(0,0)的路径数为1\n那么可以写出状态转移方程$f(x,y)=f(x-1,y)+f(x,y-1),f(0,0)=1$\n这样的话遍历一遍整个地图就可以了\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 我习惯封装一个地图 class Map { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; mat; public: Map(int n) { mat.resize(n); for (int i = 0; i \u0026lt; n; i++) { mat[i].resize(n, 0); } } int \u0026amp;At(int x, int y) { return mat[y][x]; } void Set(int x, int y, int num) { if (x \u0026lt; 0 || y \u0026lt; 0) { return; } if (x \u0026gt;= mat.size() || y \u0026gt;= mat.size()) { return; } mat[y][x] = num; } int Length() { return mat.size(); } }; Map map(22); int ex, ey; size_t dp[22][22]; int main() { int hx, hy; std::cin \u0026gt;\u0026gt; ex \u0026gt;\u0026gt; ey \u0026gt;\u0026gt; hx \u0026gt;\u0026gt; hy; // 这样方便算递推 dp[1][1] = 1; ex++; ey++; hx++; hy++; map.At(hx, hy) = 1; // 设置马的8个方向 map.Set(hx - 1, hy - 2, 1); map.Set(hx + 1, hy - 2, 1); map.Set(hx + 2, hy - 1, 1); map.Set(hx + 2, hy + 1, 1); map.Set(hx - 1, hy + 2, 1); map.Set(hx + 1, hy + 2, 1); map.Set(hx - 2, hy - 1, 1); map.Set(hx - 2, hy + 1, 1); // 开始递推 for (int i = 1; i \u0026lt;= ex; i++) { for (int j = 1; j \u0026lt;= ey; j++) { // 跳过第一个点 if (i == 1 \u0026amp;\u0026amp; j == 1) { continue; } if (map.At(i, j) != 1) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } std::cout \u0026lt;\u0026lt; dp[ex][ey] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r我最开始看到这道题我以为问题不大\n所以就直接拿出DFS了，DFS也算递归嘛\n然后就有两个数据点没过\n后来一想就发现问题了，既然不要求路径，那也没必要用DFS，直接递推就可以了\n","date":"2024-07-27T23:47:27+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9210-%E8%BF%87%E6%B2%B3%E5%8D%92/","title":"算法康复计划10 过河卒"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：挖地雷\r洛谷的P2196\n题目描述\r在一个地图上有 $N\\ (N \\le 20)$ 个地窖，每个地窖中埋有一定数量的地雷\n同时，给出地窖之间的连接路径\n当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径）\n当无连接时挖地雷工作结束\n设计一个挖地雷的方案，使某人能挖到最多的地雷\n输入格式\r有若干行。\n第 $1$ 行只有一个数字，表示地窖的个数 $N$\n第 $2$ 行有 $N$ 个数，分别表示每个地窖中的地雷个数\n第 $3$ 行至第 $N+1$ 行表示地窖之间的连接情况：\n第 $3$ 行有 $n-1$ 个数（$0$ 或 $1$），表示第一个地窖至第 $2$ 个、第 $3$ 个 $\\dots$ 第 $n$ 个地窖有否路径连接\n如第 $3$ 行为 $11000\\cdots 0$，则表示第 $1$ 个地窖至第 $2$ 个地窖有路径，至第 $3$ 个地窖有路径，至第 $4$ 个地窖、第 $5$ 个 $\\dots$ 第 $n$ 个地窖没有路径\n第 $4$ 行有 $n-2$ 个数，表示第二个地窖至第 $3$ 个、第 $4$ 个 $\\dots$ 第 $n$ 个地窖有否路径连接\n……\n第 $n+1$ 行有 $1$ 个数，表示第 $n-1$ 个地窖至第 $n$ 个地窖有否路径连接\n（为 $0$ 表示没有路径，为 $1$ 表示有路径）\n输出格式\r第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格\n第二行只有一个数，表示能挖到的最多地雷数\n样例\r样例输入\r5 10 8 4 7 6 1 1 1 0 0 0 0 1 1 1 样例输出\r1 3 4 5 27 \u0026lt;0x01\u0026gt; 分析\r貌似可以用DFS过（题解也有人说能），但为了练动态规划就没去用\n怎么动态规划呢，关键还是状态转移方程\n令状态转移方程为$f(i)$，$i$表示到下标为$i$的地窖停止\n令下标为$i$的地窖有地雷$a_i$个\n所以状态转移方程为$f(i)=a_i+max(a_1,\u0026hellip;,a_{i-1})$\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int n; std::vector\u0026lt;int\u0026gt; nums; // 定义搜索信息类 class SearchInfo { std::vector\u0026lt;int\u0026gt; searchList; int count = 0; public: SearchInfo() { searchList.clear(); } SearchInfo(int index) { searchList.push_back(index); count += nums[index]; } SearchInfo(const SearchInfo \u0026amp;c) { searchList.assign(c.searchList.begin(), c.searchList.end()); count = c.count; } void Println() { for (auto \u0026amp;i : searchList) { std::cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } bool operator\u0026gt;(const SearchInfo \u0026amp;r) const { return count \u0026gt; r.count; } bool operator\u0026lt;(const SearchInfo \u0026amp;r) const { return count \u0026lt; r.count; } SearchInfo Append(int index) { SearchInfo ans(*this); ans.searchList.push_back(index); ans.count += nums[index]; return ans; } static SearchInfo Max(SearchInfo a, SearchInfo b) { return a \u0026gt; b ? a : b; } }; std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; map; std::vector\u0026lt;SearchInfo\u0026gt; dp; int main() { std::cin \u0026gt;\u0026gt; n; nums.resize(n); map.resize(n); dp.resize(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; nums[i]; map[i].resize(n, false); } for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int temp; std::cin \u0026gt;\u0026gt; temp; map[i][j] = temp == 0 ? false : true; map[j][i] = temp == 0 ? false : true; } } dp[0] = SearchInfo(0); // 关键DP方程 for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { // 有路的时候 if (map[i][j]) { dp[i] = SearchInfo::Max(dp[i], dp[j]); } } // 附加上 dp[i] = dp[i].Append(i); } SearchInfo max; for (int i = 0; i \u0026lt; n; i++) { if (dp[i] \u0026gt; max) { max = dp[i]; } } max.Println(); return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r经验不足，想状态转移方程方向出了点问题\n我原本是认为是定义$f(i,j)$其中$i$表示扫了几个房间的雷，$j$表示从哪个房间开始\n没想出来。所以稍微看了眼题解的状态转移方程，恍然大悟\n这个也没啥办法，动态规划只是一种思想，要熟练得多练\n还有，这题貌似是单向的搜索，因为按照代码的思路，是得不出1 3 2 5 4这样的路径的\n这里给出测试样例\n5 1 2 3 4 5 0 1 0 0 1 0 1 0 0 1 按道理挖雷最大化路径就是1 3 2 5 4，但代码会给出4 5\n考虑到洛谷那边确实是过了，那应该是我之前的理解也有问题\n我默认当成是一笔画问题去考虑，想状态方程也是重点往这方面想，一直也想不出来\n估计做这题还是记忆化搜索保险，要真是一笔画思路的话这样写就过不了了\n","date":"2024-07-27T01:10:32+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9209-%E6%8C%96%E5%9C%B0%E9%9B%B7/","title":"算法康复计划09 挖地雷"},{"content":"急着看今晚的OW比赛，所以就随便写个前缀和的题目\n（OA猛）\n\u0026lt;0x00\u0026gt; 今日题目：求区间和\r洛谷的P8218\n题目描述\r给定 $n$ 个正整数组成的数列 $a_1, a_2, \\cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和\n对于所有测试数据，$n,m\\le10^5,a_i\\le 10^4$\n输入格式\r第一行，为一个正整数 $n$\n第二行，为 $n$ 个正整数 $a_1,a_2, \\cdots ,a_n$\n第三行，为一个正整数 $m$\n接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\\le l_i\\le r_i\\le n$\n输出格式\r共 $m$ 行\n第 $i$ 行为第 $i$ 组答案的询问\n样例\r样例输入\r4 4 3 2 1 2 1 4 2 3 样例输出\r10 5 数据规模与约定\r对于 $50 %$ 的数据：$n,m\\le 1000$；\n对于 $100 %$ 的数据：$1 \\le n, m\\le 10^5$，$1 \\le a_i\\le 10^4$\n\u0026lt;0x01\u0026gt; 分析\r数据输入后没有更改行为，所以可以直接维护一个到当前位置的和\n相当于数组内容是$[0,i]$的总和\n查询的话对应位置相减即可\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入数据数 int n; std::cin \u0026gt;\u0026gt; n; // 初始化与扩容 std::vector\u0026lt;size_t\u0026gt; list; list.resize(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { int temp; std::cin \u0026gt;\u0026gt; temp; // 维护[0,i]得和 list[i] = list[i - 1] + temp; } // 读入查询数 int m; std::cin \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // 相减即可 std::cout \u0026lt;\u0026lt; list[b] - list[a - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } ","date":"2024-07-25T21:33:45+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9208-%E6%B1%82%E5%8C%BA%E9%97%B4%E5%92%8C/","title":"算法康复计划08 求区间和"},{"content":"今天挑一道经典题目来学学动态规划\n\u0026lt;0x00\u0026gt; 今日题目：采药\r洛谷的P1048\n题目描述\r辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师\n为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题\n医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是辰辰，你能完成这个任务吗？\n输入格式\r第一行有 $2$ 个整数 $T$（$1 \\le T \\le 1000$）和 $M$（$1 \\le M \\le 100$）\n用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目\n接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数\n分别表示采摘某株草药的时间和这株草药的价值。\n输出格式\r输出在规定的时间内可以采到的草药的最大总价值。\n样例\r样例输入\r70 3 71 100 69 1 1 2 样例输出\r3 数据规模与约定\r对于 $30%$ 的数据，$M \\le 10$； 对于全部的数据，$M \\le 100$。 \u0026lt;0x01\u0026gt; 分析\r背包DP的经典题目，关键在于理解什么是动态规划\n如果采用暴力枚举的方式，那么时间复杂度是在$O(2^{T})$，这是完全不能接受的\n如果采用贪心呢，貌似可以先选择单位价值高的，但由于草药不能无限细分，这样不能保证总体最优\n而动态规划的思路可以保证总体最优解\n动态规划有点像贪心，都是先将问题拆解，然后看子问题怎么解决\n但贪心的思路通常是一条路顺下来的，通常不会判断会不会有更好的解法\n而动态规划将一个个子问题视为一个个状态，将问题求解看作子问题之间的转移\n所以一般动态规划的题关键是想出那个状态转移方程\n这道题的话，我们令状态转移方程为$f(i,j)$\n其中$i$表示已经处理了前$i$个草药数据，$j$表示背包还能装$j$重量的草药\n那么，这个状态转移方程就是$f(i,j)=max(f(i-1,j),f(i-1,j-w)+v)$\n$f(i-1,j)$表示不放进去，$f(i-1,j-w)+v$表示放进去，$w$表示加入草药的重量，$v$表示加入草药的价值\n并且由于处理下一个草药数据时，完全不会用到之前状态的数据，所以可以把第一维省略\n这时候状态转移方程就变成了$f(j)=max(f(j),f(j-w)+v)$\n有这个方程之后只要写好遍历就可以了\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 定义草药的数据 class Herb { public: int weight; int value; Herb(int weight, int value) { this-\u0026gt;weight = weight; this-\u0026gt;value = value; } }; // 解题 int main() { // 解题 int t, m; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m; // 草药列表和dp表 std::vector\u0026lt;Herb\u0026gt; list; std::vector\u0026lt;int\u0026gt; dp; dp.resize(t + 1, 0); for (int i = 0; i \u0026lt; m; i++) { int tw, tv; std::cin \u0026gt;\u0026gt; tw \u0026gt;\u0026gt; tv; list.push_back(Herb(tw, tv)); } // 通过状态转移方程计算最佳解法 for (int index = 0; index \u0026lt; m; index++) { for (int l = t; l \u0026gt;= list[index].weight; l--) { dp[l] = std::max(dp[l], dp[l - list[index].weight] + list[index].value); } } // 最后再遍历一遍取最大值 int ans = 0; for (auto \u0026amp;i : dp) { ans = std::max(ans, i); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-07-25T14:52:18+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9207-%E9%87%87%E8%8D%AF/","title":"算法康复计划07 采药"},{"content":"今天别的事情多，所以就挑一道简单的题写写\n\u0026lt;0x00\u0026gt; 今日题目：跳跳！\r洛谷的P4995\n题目描述\r你是一只小跳蛙，你特别擅长在各种地方跳来跳去。\n这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头\n其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0 = 0$\n你估计着，从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i - h_j) ^ 2$，从地面跳到第 $i$ 块石头耗费的体力值是 $(h_i) ^ 2$\n为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次\n并最终停在任意一块石头上，并且小跳蛙想耗费尽可能多的体力值\n当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现\n不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。\n那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！\n输入格式\r输入一行一个正整数 $n$，表示石头个数。\n输入第二行 $n$ 个正整数，表示第 $i$ 块石头的高度 $h_i$。\n输出格式\r输出一行一个正整数，表示你可以耗费的体力值的最大值。\n样例 #1\r样例输入 #1\r2 2 1 样例输出 #1\r5 样例 #2\r样例输入 #2\r3 6 3 5 样例输出 #2\r49 提示\r样例解释\r两个样例按照输入给定的顺序依次跳上去就可以得到最优方案之一。\n数据规模与约定\r对于 $1 \\leq i \\leq n$，有 $0 \u0026lt; h_i \\leq 10 ^ 4$，且保证 $h_i$ 互不相同。\n对于 $10%$ 的数据，$n \\leq 3$；\n对于 $20%$ 的数据，$n \\leq 10$；\n对于 $50%$ 的数据，$n \\leq 20$；\n对于 $80%$ 的数据，$n \\leq 50$；\n对于 $100%$ 的数据，$n \\leq 300$。\n\u0026lt;0x01\u0026gt; 分析\r既然是要求可消耗的体力最大值，那就是怎么麻烦怎么来\n因为对于两块石头间的体力消耗，是用差的平方算的\n所以高度相差越大越好\n那最好的办法是从低跳到最高的，从高的跳到最低的\n由于输入的石头高度序列是无序的，并且保证高度互不相同\n所以采用计数排序的思路标flag，速度最快\n\u0026lt;0x02\u0026gt; 代码\r// 因为一遍过了，所以代码逻辑挺乱的 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 保存是否有这个高度 std::vector\u0026lt;bool\u0026gt; isExist; int max = 0; int min = 0; // 找下一个最大值 void FindNextMax() { max--; while (!isExist[max]) { max--; } } // 找下一个最小值 void FindNextMin() { min++; while (!isExist[min]) { min++; } } // 算平方 size_t Sqr(size_t n) { return n * n; } // 算差 size_t DiffSqr(size_t a, size_t b) { if (a \u0026gt; b) { return Sqr(a - b); } else { return Sqr(b - a); } } // 解题 int main() { // 初始化 isExist.resize(10001, false); // 从平地跳算高度0 isExist[0] = true; // 读入 int n; std::cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int temp; std::cin \u0026gt;\u0026gt; temp; isExist[temp] = true; // 更新最大值 if (temp \u0026gt; max) { max = temp; } } size_t ans = 0; // 从高度0开始 int p = min; bool isFindMin = false; while (min \u0026lt;= max) { if (isFindMin) { ans += DiffSqr(p, min); p = min; FindNextMax(); isFindMin = false; } else { ans += DiffSqr(p, max); p = max; FindNextMin(); isFindMin = true; } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-07-24T00:23:00+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9206-%E8%B7%B3%E8%B7%B3/","title":"算法康复计划06 跳跳！"},{"content":"数字图像处理我们主要是讲OpenCV的（虽然实际上代码讲的不多）\n然后作为期末的课程设计，要求我们写一个OpenCV的程序\n主要就是用OpenCV去解决一些现实中的问题，然后要带图形界面\n允许组队，而且在学期初就要定课设的题目\n\u0026lt;0x00\u0026gt; 我们做了什么\r本来打算做一个用OpenCV做相机反求，Godot做渲染的AR项目\n（所以前面有几篇研究怎么用C#做OpenCV开发）\n引擎这块基本都搭完完了，然后估计了下感觉写不完了\n（C#写OpenCV的代码参考太少了，很多代码都是试出来的，开发效率太低了）\n好在我们还有一个Plan B，就是参考MIT的运动放大的论文去写一个应用\n（主要是看了Steve Mould的视频）\n这样的话，语言也干脆换成了参考够多的Python，效率高了不少\n问题也有，就是我们Python都不熟，但比起没代码参考好太多了\n项目地址\n\u0026lt;0x0\u0026gt; 整体架构\r我们采用dearpygui来构建整个图形界面\n使用numpy和scipy来做一些数据的处理\n\u0026lt;0x0\u0026gt; EVM原理\r具体看MIT EVM的介绍，这里就只做大致的讲解\n\u0026lt;0x0\u0026gt; 一些感想\r关于知识\r首先就是确实感觉知道的东西多反而是一种诅咒\n为什么这么说呢，知道的东西多了之后，遇到新的问题总是会用自己知道的知识解决\n这道是正常的，毕竟这也是学习的目的\n但问题是，当知道的东西多了之后，我总是觉得这个问题用已知知识是能解决的\n然后就这样去开发，走一半，会发现这个项目按原计划开发会遇到非常多的问题\n两个选择，要么花很多时间去解决，要么项目推倒重来重新设计架构\n这两个选择都是痛苦的\n像这个课设，我就犯这样的错误\n一开始我是打算用C#做Opencv开发，然后WPF做前端\n因为Opencv在C#的实现我还是熟的，WPF我也是熟的\n开发到后来发现，EVM需要用到傅里叶变换，Opencv中肯定是不带这种东西的\n这时候其实可以考虑切换到python开发，但我并没有这么做，我选择来了花时间解决\n然而，在我头铁写完了傅里叶变换的流程后，我发现整个算法的运行效率低得很\n（中间的类型转换太多了，我对Mat类型了解也不够）\n这时候又遇到一个抉择，推到重来换python还是花时间研究C#操作Mat类型\n好在这次我选择了推到重来换python，最后完成开发\n这个问题其实说到底，还是知道的不够多，毕竟这种开发中的问题懂的多了之后，是可以在开发前预知到的\n但还是有一个矛盾，对一块知识，究竟了解到什么程度才能算懂得够多，我不知道\n学的东西多了，确实是能比别人看到更远的东西，但也比别人看到更少的东西\n如果我是新手，这个项目我肯定就用python开发了，哪还要折腾C#啊\n就是因为我了解C#，我才一开始用C#开发\n关于团队\r这个课设虽然可以组队，但这个项目基本是我一个人完成的\n那我的队友在干什么呢？他们在做别的可以组队的项目，并且是一人一个项目\n我发现，对于计算机的学生来说，可能最好的合作方式就是一人一个项目\n程序开发不是人越多越快的\n如果说有n个人，那么单位时间内代码量是$O(n)$，但沟通成本是$O(n^2)$\n因为程序员开发软件需要的是连贯的思路，脑中需要保存所有代码的逻辑结构\n对于别人写的代码，自己看是很花时间的，只有说问原来的开发者代码功能才是最快的\n更何况程序有BUG，命名规范等等之类的增加沟通成本的问题\n这方面可以看下《人月神话》这本书\n一个人一个项目，整个项目都在一个人的掌握之中，这样的效率是更高的\n当然，这样的合作方式不是适合所有队伍的\n你需要确保你的队友没有摆子，并且队每个人都可以分到适合其水平的项目\n最重要的，足够的信任，在队友没请求帮助前就尽量不插手队友的工作\n否则还是正常合作吧，这样起码可以保证项目可以写完\n关于python\r最后这个课设用python完成的\n我在这个课设之前，可以说我是看不起python的\n总觉得这个语言效率低，语法过于抽象\n虽然我看习惯了传统的C系代码，看python这种靠tab分隔层次的语言确实需要时间适应\n但挺过阵痛期后，我发现python还挺好用 整个语言的设计完全是为解决问题去的\n通过丰富的包，让很多问题几行代码就搞定了\n不过还是有一些小问题的，但这也不是python的问题，应该说是弱类型语言的问题\n因为弱类型，导致很多问题不能在编译期查出\n虽然是可以给变量打注解，但问题也是编译期不检查这个\n所有实际开发中经常出现传参类型出问题，排查好一会儿\n总之，python这门语言感觉就像是共享单车，解决的是程序最后怎么运行的问题\n当脚本语言是非常合适的\n所以说，没有最好的语言，只有最适合的语言\n","date":"2024-07-23T12:23:45+08:00","permalink":"https://mlacookie.github.io/article/categories/opencv/%E6%B5%99%E5%B7%A5%E5%A4%A7%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/","title":"浙工大数字图像处理课设记录"},{"content":"这道题我想的太抽象了，导致我在复杂的方向上花了很多时间\n（因为那个思路确实不能说错吧，毕竟确实是能解决问题的）\n\u0026lt;0x00\u0026gt; 今日题目：逛画展\r洛谷的P1638\n题目描述\r博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。\n游客在购买门票时必须说明两个数字，$a$ 和 $b$\n代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。\nSept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。\n请求出他购买门票时应选择的 $a,b$，数据保证一定有解。\n若存在多组解，输出 $a$ 最小的那组。\n输入格式\r第一行两个整数 $n,m$，分别表示博览馆内的图画总数及这些图画是由多少位名师的画所绘画的。\n第二行包含 $n$ 个整数 $a_i$，代表画第 $i$ 幅画的名师的编号。\n输出格式\r一行两个整数 $a,b$。\n样例\r样例输入\r12 5 2 5 3 1 3 2 4 1 1 5 4 3 样例输出\r2 7 数据规模与约定\r对于 $30%$ 的数据，有 $n\\le200$，$m\\le20$。 对于 $60%$ 的数据，有 $n\\le10^5$，$m\\le10^3$。 对于 $100%$ 的数据，有 $1\\leq n\\le10^6$，$1 \\leq a_i \\leq m\\le2\\times10^3$。 \u0026lt;0x01\u0026gt; 分析\r这里先讲正确的思路\n首先先看看怎么求最小的区间\n这个可以用贪心的方式\n我们可以维护一个某大师的画最后出现位置的数组\n那么，对于一个固定的end\n最小区间的start一定小于等于所有最后出现位置并且尽可能大的\nend可以从1开始遍历，然后计算start的值\n后面就是看哪个短就取哪段了\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { int n, m; int count = 0; int ansLength = 1e7; int ansStart = -1; int ansEnd = -1; // 读入 std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; // 初始化 std::vector\u0026lt;int\u0026gt; nums; nums.resize(n + 1); std::vector\u0026lt;int\u0026gt; positions; positions.resize(m + 1, -1); int start = 1; for (int end = 1; end \u0026lt;= n; end++) { int temp; std::cin \u0026gt;\u0026gt; temp; nums[end] = temp; // 如果这个大师的画还没出现过 if (positions[temp] == -1) { count++; } positions[temp] = end; // 计算当前位置为尾部的最小解 while (start \u0026lt; end \u0026amp;\u0026amp; start \u0026lt; positions[nums[start]]) { start++; } // 有新的最小解就更新 if (count == m \u0026amp;\u0026amp; end - start \u0026lt; ansLength) { ansLength = end - start; ansStart = start; ansEnd = end; } } std::cout \u0026lt;\u0026lt; ansStart \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ansEnd \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r一开始这个临时的start我是放在while里面的\n这导致start每次都是从1开始遍历，浪费了很多时间\n因为都是找新的解，start没必要从1开始，放while外面就行\n\u0026lt;0x04\u0026gt; 我的神秘前缀和思路\r因为最近也在看一些前缀和相关的东西，所以这道题就往前缀和的思路去想了\n而且确实能想出来怎么用前缀和去解这道题\n这里用样例的数据解释\n12 5 2 5 3 1 3 2 4 1 1 5 4 3 对于每个数字，我们可以附加一个list表示前面不同的画出现了几次\n对于这个输入，得到的list是这样的\nindex list num 1 0 1 0 0 0 2 2 0 1 0 0 1 5 3 0 1 1 0 1 3 4 1 1 1 0 1 1 5 1 1 2 0 1 3 6 1 2 2 0 1 2 7 1 2 2 1 1 4 8 2 2 2 1 1 1 9 3 2 2 1 1 1 10 3 2 2 1 2 5 11 3 2 2 2 2 4 12 3 2 3 2 2 3 然后就可以选取start和end，end的list减去start的list，如果没有0，那就是满足要求的\n比如说2 7这对，对应选start = 1和end = 7，相减的结果就是1 1 2 1 1没有零\n算法开始时，先从index = 1开始遍历，先去搜第一个解\n搜到第一个解后，也得到了第一个解的长度length\n后面只要直接检查某个index的list和index-length的list的差是否有0就行\n没有0的话就求出这个最小解然后替换长度之类的\n总的算下来时间复杂度大概是O(n)，我想是没问题的\n（不考虑空间复杂度的后果）\n然后就丢洛谷去跑了，发现爆内存了\n经过优化变量类型之类的操作，能过的数据点多了几个但没AC\n发现代码运行时间还行，就开始用时间换空间\n原来是缓存全部的list，最后改成了每30个缓存一个，其他的靠现场计算\n结果是只剩最后一个数据点没过，超时并且内存也差点超限(1.2s/127MB)\n到这我才反应过来思路有点问题\n主要也确实不甘心，鬼知道算法题原本的思路是什么，况且这样写的代码还真能过大部分数据点\n我就以为是我优化没做好，不会是思路本身出了问题\n最后没办法，看了看题解，发现完全是我想复杂了\n代码如下，稍微有点长，毕竟我习惯封装\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;vector\u0026gt; // 设置缓存频数 int bufferSlice = 30; // 封装的画出现次数的类型 class SumInfo { std::vector\u0026lt;uint16_t\u0026gt; count; public: SumInfo(const SumInfo \u0026amp;c) { count.assign(c.count.begin(), c.count.end()); } SumInfo(int length) { count.resize(length, 0); } SumInfo(const SumInfo \u0026amp;c, int index) { count.assign(c.count.begin(), c.count.end()); count[index]++; } // 判断开始结束位置是否满足要求 static bool Judge(const SumInfo \u0026amp;start, const SumInfo \u0026amp;end) { int length = end.count.size(); for (int i = 0; i \u0026lt; length; i++) { if (end.count[i] - start.count[i] \u0026lt; 1) { return false; } } return true; } // 判断是否所有画都出现过 static bool Check(const SumInfo \u0026amp;sum) { for (auto \u0026amp;i : sum.count) { if (i \u0026lt; 1) { return false; } } return true; } }; std::vector\u0026lt;SumInfo\u0026gt; frontSum; std::vector\u0026lt;uint16_t\u0026gt; input; // 获取缓存或计算的函数 SumInfo GetSumInfo(int index) { if (index % bufferSlice == 0) { return frontSum[index / bufferSlice]; } else { return SumInfo(GetSumInfo(index - 1), input[index] - 1); } } int main() { // 读入 int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; SumInfo tempSum(m); input.push_back(0); frontSum.push_back(tempSum); for (int i = 1; i \u0026lt;= n; i++) { uint16_t num; std::cin \u0026gt;\u0026gt; num; input.push_back(num); tempSum = SumInfo(tempSum, num - 1); // 做频数缓存 if (i % bufferSlice == 0) { frontSum.push_back(SumInfo(tempSum)); } } int index = 1; int ansStart = -1; int ansEnd = -1; int ansLength = -1; while (index \u0026lt; input.size()) { // 搜索第一个解 if (ansEnd == -1) { // 找到首次所有大师的画都出现的情况 if (SumInfo::Check(GetSumInfo(index))) { ansEnd = index; for (int i = 0; i \u0026lt; index; i++) { if (!SumInfo::Judge(GetSumInfo(i), GetSumInfo(ansEnd))) { ansStart = i; break; } } ansLength = ansEnd - ansStart; } } // 遍历剩下的，看看有没有别的解 else { // 发现有长度更小的解 if (SumInfo::Judge(GetSumInfo(index - ansLength), GetSumInfo(index))) { // 求解 ansEnd = index; int tempStart = index - ansLength; for (int i = tempStart; i \u0026lt; index; i++) { if (!SumInfo::Judge(GetSumInfo(i), GetSumInfo(ansEnd))) { ansStart = i; break; } } ansLength = ansEnd - ansStart; } } if (ansLength + 1 == m) { break; } index++; } std::cout \u0026lt;\u0026lt; ansStart \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ansEnd; return 0; } ","date":"2024-07-23T01:51:37+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9205-%E9%80%9B%E7%94%BB%E5%B1%95/","title":"算法康复计划05 逛画展"},{"content":"偶然发现居然有道很久之前写的题没有AC，那就写这题了\n\u0026lt;0x00\u0026gt; 今日题目：数楼梯\r洛谷的P1255\n题目描述\r楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。\n编一个程序，计算共有多少种不同的走法。\n输入格式\r一个数字，楼梯数。\n输出格式\r输出走的方式总数。\n样例\r样例输入\r4 样例输出\r5 数据规模与约定\r对于 $60%$ 的数据，$N \\leq 50$； 对于 $100%$ 的数据，$1 \\le N \\leq 5000$。 \u0026lt;0x01\u0026gt; 分析\r思路应该是不难的\n现在有4层楼梯，每次上一层或者两层\n那先走个一层，这样还有3层楼梯\n3层也能上一层或者两层，那这次上两层\u0026hellip;\n如此类推，我们可以得到一个决策树\n4 ├── 3 | ├── 2 | | ├── 1 ── 0 | | └── 0 | └── 1 ── 0 └── 2 ├── 1 ── 0 └── 0 我们可以发现存在一些相同的子树\n这些相同的子树带来的走法是一样的\n所以要求4层楼梯有几种走法，可以先求3层有几种，2层有几种\u0026hellip;\n求到最后就是只有1层楼梯和2层楼梯有几种走法，这两种情况的答案是显然的\n更进一步，我们可以得到一个递推式：$f(n) = f(n-1) + f(n-2), f(1) = 1, f(2) = 2$\n对于这样的递推式，一般可以用递归的方式来解决\n因为$f(n)$的值仅与$n$有关，所以对于每次求值，没必要完整计算一遍整个递推式\n我们可以用一个list去暂存我们已经计算好的值\n在计算新的值的过程中，如果发现有些值已经计算过了，直接用就可以\n这样可以大大提高运行速度\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 数据量会非常大，所以要有高精度计算 class BigInteger { public: BigInteger() : digits(1, 0) { } BigInteger(const std::string \u0026amp;number) { for (int i = number.size() - 1; i \u0026gt;= 0; --i) { if (isdigit(number[i])) { digits.push_back(number[i] - \u0026#39;0\u0026#39;); } } } // 有加法就够了 BigInteger operator+(const BigInteger \u0026amp;other) const { BigInteger result; result.digits.clear(); int carry = 0; size_t maxSize = std::max(digits.size(), other.digits.size()); for (size_t i = 0; i \u0026lt; maxSize || carry; ++i) { int sum = carry; if (i \u0026lt; digits.size()) sum += digits[i]; if (i \u0026lt; other.digits.size()) sum += other.digits[i]; result.digits.push_back(sum % 10); carry = sum / 10; } return result; } // 重载输出流 friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const BigInteger \u0026amp;number) { for (int i = number.digits.size() - 1; i \u0026gt;= 0; --i) { os \u0026lt;\u0026lt; number.digits[i]; } return os; } // 判零用 bool IsZero() { if (digits.size() == 1) { return true; } return false; } private: std::vector\u0026lt;int\u0026gt; digits; }; // 初始化全局缓存的答案 BigInteger ans[5001] = {BigInteger()}; // 解题 BigInteger Step(int n) { // 边界条件 if (n == 1) { return BigInteger(\u0026#34;1\u0026#34;); } if (n == 2) { return BigInteger(\u0026#34;2\u0026#34;); } // 已经计算出来的就直接返回 if (!ans[n].IsZero()) { return ans[n]; } // 递归计算 return Step(n - 1) + Step(n - 2); } int main() { // 打表计算所有的答案 for (int i = 1; i \u0026lt; 5001; i++) { ans[i] = Step(i); } // 读入 int n; std::cin \u0026gt;\u0026gt; n; // 直接就能输出了 std::cout \u0026lt;\u0026lt; ans[n]; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r本来以为是没啥问题的题，很快就写出了算法\n然后跑评测，能过一半的数据\n我就纳闷啊，把输入输出下载下来一看，输入到没啥，输出倒是老长一串数字\n那这数字size_t都扛不住，要上高精度计算了\n所以这道题看似考递推递归，实际上考的是高精度计算\n然后本来想逃课用C#的BigIntager的，但不知道为什么，洛谷的评测机上面没有BigIntager这个类\n所以最后就写了个高精度计算，也就用到个加法，问题不大\n","date":"2024-07-22T12:59:04+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9204-%E6%95%B0%E6%A5%BC%E6%A2%AF/","title":"算法康复计划04 数楼梯"},{"content":"\u0026lt;0x00\u0026gt; 今日题目：A-B 数对\r洛谷的P1102\n题目背景\r出题是一件痛苦的事情！ 相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！\n题目描述\r给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。\n输入格式\r输入共两行。 第一行，两个正整数 $N,C$。 第二行，$N$ 个正整数，作为要求处理的那串数。\n输出格式\r一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。\n样例\r样例输入\r4 1 1 1 2 3 样例输出\r3 数据规模与约定\r对于 $75%$ 的数据，$1 \\leq N \\leq 2000$。 对于 $100%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i \u0026lt;2^{30}$，$1 \\leq C \u0026lt; 2^{30}$。 2017/4/29 新添数据两组\n\u0026lt;0x01\u0026gt; 分析\r我的思路有点抽象，这道题是在二分的题单里的\n因为对于已知B的情况，则A=B+C，这个A是固定的\n本来我是打算对输入数列排序，然后求连续的B有几个\n通过二分求出A的位置上下界，然后上下界相减求出A有几个\n两个数字相乘加入到总的结果中，如此反复，最后求出答案\n然后我就想，既然这样，为什么不在输入时维护一个数组，保存某数有几个\n这种数据结构更进一步不就是哈希表嘛\n于是这个题就很简单了\n通过哈希表，建立键值对(数, 数的个数)\n然后就是每个B计算A=B+C，两个数的个数相乘即可\n唯一的坏处是没练习怎么写二分\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; int main() { // 读入 int n; size_t c; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; std::map\u0026lt;size_t, int\u0026gt; numInfo; // 处理 for (int i = 0; i \u0026lt; n; i++) { int t; std::cin \u0026gt;\u0026gt; t; numInfo[t]++; } // 解题 size_t ans = 0; for (auto \u0026amp;it : numInfo) { size_t temp = c + it.first; if (numInfo.find(temp) != numInfo.end()) { // 强转保平安 ans += (size_t)numInfo[temp] * (size_t)it.second; } } std::cout \u0026lt;\u0026lt; ans; } \u0026lt;0x03\u0026gt; 遇到的坑\r又是经典答案爆int范围了，但这里是在最后的乘法\n两个int相乘返回的也是int，如果乘出来的值超过范围，也是会爆的\n所以int强转size_t解决\n","date":"2024-07-21T22:27:25+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9203-a-b-%E6%95%B0%E5%AF%B9/","title":"算法康复计划03 A-B 数对"},{"content":"今天有人找我解决一些软件相关的问题，然后发现会牵扯到一些Win32的API\n一般调用Win32API都是用C++方便的，而且微软给的文档也是C++的\n我虽然对C++不是很熟，但对C#熟啊\n在C#中，我们可以通过P/Invoke去做动态库的互操作\n但对于Win32API，如果自己写P/Invoke，里面就有很多不确定的东西\n光是那个DllImport特性里面的参数就不是很好填\n那C#开发者是不是很难做Win32开发呢，那也不是\n在Nuget上有很多别的大佬包装好的Win32库，安装完可以直接调用\n但Win32中有超级多的API，这会导致代码提示里面会多出非常多东西，确实是有点干扰了\n但好在微软也提供了一个解决方案，CsWin32\n这个是基于C#源生成器的Win32API封装器\n就是需要什么API，它就去生成那些API的P/Invoke代码\n并且生成的质量还挺高的，保留原本的调用风格的同时，尽可能去迎合C#的开发体验\n\u0026lt;0x00\u0026gt; 安装CsWin32\r因为会用到C#的源生成器，所以最好使用VS2022并且相对新的版本，不然代码提示之类的会出问题\nVSCode的源生成器体验也是不错的，这个直接装C# kit插件就可以了\n直接在Nuget中搜索CsWin32，包名是Microsoft.Windows.CsWin32\n这个包最低支持到.net framework 4.5也即.NET Standard 2.0\n对于这个版本，还需要安装System.Memory\n如果是.NET Standard 2.1及以上，也即.net 5.0及以上的版本，那么就不需要安装\n（如果是新项目的话应该会用新版本的框架吧）\n\u0026lt;0x01\u0026gt; 如何使用\r添加需要的API\r首先是要告诉源生成器要生成哪些API的封装\n在项目根目录新建叫NativeMethods.txt的文件\n在里面可以添加你需要添加的Win32函数或者结构的名字\nPssCaptureSnapshot PssQuerySnapshot PSS_PROCESS_INFORMATION PSS_HANDLE_INFORMATION PSS_VA_CLONE_INFORMATION 这里的示例是Windows进程快照相关的API，使用的API也不多，仅做演示作用\n简单解释下使用的API\rPssCaptureSnapshot\r捕获目标进程的快照\nDWORD PssCaptureSnapshot( [in] HANDLE ProcessHandle, [in] PSS_CAPTURE_FLAGS CaptureFlags, [in, optional] DWORD ThreadContextFlags, [out] HPSS *SnapshotHandle ); ProcessHandle目标进程的句柄\nCaptureFlags指定要捕获的标志\nThreadContextFlags如果 CaptureFlags 指定线程上下文，则要捕获的 CONTEXT 记录标志\nSnapshotHandle返回此函数捕获的快照的句柄\n函数返回的是winerror.h中定义的错误代码，无错误是ERROR_SUCCESS\nPssQuerySnapshot\r查询捕获的快照的信息\nDWORD PssQuerySnapshot( [in] HPSS SnapshotHandle, [in] PSS_QUERY_INFORMATION_CLASS InformationClass, [out] void *Buffer, [in] DWORD BufferLength ); SnapshotHandle要查询的快照的句柄\nInformationClass用于选择要查询的信息\nBuffer此函数提供的信息，类型由InformationClass决定\nBufferLength缓冲区的大小（以字节为单位）\n函数返回的是winerror.h中定义的错误代码，无错误是ERROR_SUCCESS\n剩下的是一些结构，东西多就不细讲了，跟本文关系不大，具体就看文档吧\n在代码中使用Win32API\r这里做一个使用Win32API查询进程PID的示例\n（虽然C#的Process类对象本身就可以直接查询）\nusing System.Diagnostics; using Windows.Win32; using Windows.Win32.System.Diagnostics.ProcessSnapshotting; public class Program { public static void Main() { // 使用C#自带的Process类型获取记事本进程 Process test = Process.GetProcessesByName(\u0026#34;notepad\u0026#34;)[0]; // 声明一个查询flags PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS; // 使用Win32API来捕获进程快照 PInvoke.PssCaptureSnapshot( test.SafeHandle, flags, 0, out HPSS snapshotHandle); // 声明查询进程基本信息的变量 PSS_PROCESS_INFORMATION info; // 涉及到指针操作，所以要用unsafe块包装 unsafe { // 使用Win32API来查询进程快照信息 PInvoke.PssQuerySnapshot( snapshotHandle, PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION, \u0026amp;info, (uint)sizeof(PSS_PROCESS_INFORMATION)); } Console.WriteLine(info.ProcessId); } } 确实是获取到了记事本的PID\n而且观察代码，不难发现，CsWin32会非常智能地使用C#自带的类型\n比如说Process类型里面的SafeHandle属性，这个返回的是SafeProcessHandle\n这个虽然它的命名空间是Microsoft.Win32.SafeHandles，但确实是C#本身就有的\n对于C#不带的类型，只有使用的API需要这些类型传参，CsWin32才会去生成对应的代码\n\u0026lt;0x02\u0026gt; 一些不知道类型的枚举\r如果你需要使用某个枚举，但不知道是什么类型，CsWin32可以自动指出具体类型\n比如前面提到那两个API的返回值是winerror.h中定义的错误代码，但我们不知道这是什么类\n这时候可以在NativeMethods.txt里面直接加上ERROR_SUCCESS\nCsWin32会抛出警告：应该使用正确的声明\n最后也指出正确的声明是WIN32_ERROR，文件里改好就行\n这里对上面的代码稍作修改作为示例\nusing System.Diagnostics; using Windows.Win32; using Windows.Win32.Foundation; using Windows.Win32.System.Diagnostics.ProcessSnapshotting; public class Program { public static void Main() { Process test = Process.GetProcessesByName(\u0026#34;notepad\u0026#34;)[0]; PSS_CAPTURE_FLAGS flags = PSS_CAPTURE_FLAGS.PSS_CAPTURE_THREADS; PInvoke.PssCaptureSnapshot( test.SafeHandle, flags, 0, out HPSS snapshotHandle); PSS_PROCESS_INFORMATION info; // 添加错误码的声明 uint errorCode; unsafe { // 获取错误码返回值 errorCode = PInvoke.PssQuerySnapshot( snapshotHandle, PSS_QUERY_INFORMATION_CLASS.PSS_QUERY_PROCESS_INFORMATION, \u0026amp;info, (uint)sizeof(PSS_PROCESS_INFORMATION)); } Console.WriteLine(info.ProcessId); // 跟WIN32_ERROR.ERROR_SUCCESS做比较，返回True Console.WriteLine((WIN32_ERROR)errorCode == WIN32_ERROR.ERROR_SUCCESS); } } 当然头铁不改正确的声明也没关系，也是这样使用\n对于其他不知道怎么声明的枚举也可以这样让CsWin32去找\n","date":"2024-07-21T21:08:14+08:00","permalink":"https://mlacookie.github.io/article/posts/2024/%E7%9B%B8%E5%AF%B9%E4%BC%98%E9%9B%85%E5%BE%97csharp%E8%B0%83%E7%94%A8win32api/","title":"相对优雅得C#调用Win32API"},{"content":"刚开始几天打算先写点简单的\n\u0026lt;0x00\u0026gt; 今日题目：小A的糖果\r洛谷的P3817\n题目描述\r小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。 小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。\n输入格式\r输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。 第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。\n输出格式\r输出一行一个整数，代表最少要吃掉的糖果的数量。\n样例 #1\r样例输入 #1\r3 3 2 2 2 样例输出 #1\r1 样例 #2\r样例输入 #2\r6 1 1 6 1 2 0 4 样例输出 #2\r11 样例 #3\r样例输入 #3\r5 9 3 1 4 1 5 样例输出 #3\r0 提示\r样例输入输出 1 解释\r吃掉第 2 盒中的一个糖果即可。\n样例输入输出 2 解释\r第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。\n数据规模与约定\r对于 $30%$ 的数据，保证 $n \\leq 20$，$a_i, x \\leq 100$。 对于 $70%$ 的数据，保证 $n \\leq 10^3$，$a_i, x \\leq 10^5$。 对于 $100%$ 的数据，保证 $2 \\leq n \\leq 10^5$，$0 \\leq a_i, x \\leq 10^9$。 \u0026lt;0x01\u0026gt; 分析\r这是来着贪心题单的题，那么就是用贪心算法\n怎么贪心呢\n因为每次考虑的都是相邻的两个盒子，而且要用贪心\n所以应该每次就只用考虑这两个盒子就可以了\n每次计算中，只有第二个盒子会参与下一次的计算\n既然是要算吃得最少的数目，那么应该要先吃第二个盒子的糖\n这样就可以保证每个相邻的盒子中的糖满足条件且吃的糖的数量是最少的\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { // 读入 int n; int x; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; std::vector\u0026lt;int\u0026gt; list; list.resize(n); for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; list[i]; } // 解题 size_t ans = 0; for (int i = 0; i \u0026lt; n - 1; i++) { // 按前面分析的思路解题 int temp = list[i] + list[i + 1]; if (temp \u0026gt; x) { // 计算满足条件要吃几颗 int d = temp - x; ans += d; // 如果第二个盒子糖果不足 if (list[i + 1] \u0026lt; d) { list[i] -= d - list[i + 1]; list[i + 1] = 0; } // 否则就直接减去 else { list[i + 1] -= d; } } } std::cout \u0026lt;\u0026lt; ans; return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r经典最后答案爆数值范围了\n最开始ans是int类型，然后提交上去发现有两个数据点过不了\n下载下来一看输出就明白了，答案超21亿了\n于是把int改成size_t这样就过了\n(size_t在64位系统中是unsigned long long)\n","date":"2024-07-21T10:43:29+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9202-%E5%B0%8Fa%E7%9A%84%E7%B3%96%E6%9E%9C/","title":"算法康复计划02 小A的糖果"},{"content":"这两年，技术研究得越来越多，但算法基本是没学了\n让我本就不强的算法能力更是雪上加霜\n于是我就打算趁着暑假的时间，每天做一道算法题\n也不是为了比赛之类的，只是觉得现在确实缺算法方面的能力\n顺便也当练练C++了，我C++熟练度也不够\n需要写在前面的是，我的代码会有很多封装，这样性能肯定不是最佳的\n而且因为每天要干的事情也是挺多的，所以文章不会讲得很细，就当是个过程记录吧\n\u0026lt;0x00\u0026gt; 今日题目：马的遍历\r洛谷的P1443\n题目描述\r有一个 $n \\times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。\n输入格式\r输入只有一行四个整数，分别为 $n, m, x, y$。\n输出格式\r一个 $n \\times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。\n样例\r样例输入\r3 3 1 1 样例输出\r0 3 2 3 -1 1 2 1 4 数据规模与约定\r对于全部的测试点，保证 $1 \\leq x \\leq n \\leq 400$，$1 \\leq y \\leq m \\leq 400$。\n\u0026lt;0x01\u0026gt; 分析\r这个题目是一道搜索相关的题目\n搜索的话，基本上就是DFS深度优先和BFS广度优先\n本题需要计算马到棋盘的每一格最少需要走几步\n使用DFS的话马容易一条路走到黑，虽然也是能解决问题的\n而选择BFS的话，相当于同时放出好几匹马，更快得出最少步数\n因为走不到的地方要标-1，所以地图初始化所有标记为-1\n\u0026lt;0x02\u0026gt; 代码\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; // 为了更好的可读性，这里封装了一个Map类型 class Map { int n; int m; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; mat; public: // 负责访问内容 int \u0026amp;At(int x, int y) { return mat[y][x]; } // 运算符重载 std::vector\u0026lt;int\u0026gt; \u0026amp;operator[](int index) { return mat[index]; } void ShowMap() { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { std::cout \u0026lt;\u0026lt; mat[j][i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } // 复制构造函数，防止C++整花活 Map(const Map \u0026amp;c) { n = c.n; m = c.m; mat.resize(m); for (int i = 0; i \u0026lt; m; i++) { mat[i].resize(n); for (int j = 0; j \u0026lt; n; j++) { mat[i][j] = c.mat[i][j]; } } } // 正常的构造函数 Map(int n, int m) { this-\u0026gt;n = n; this-\u0026gt;m = m; mat.resize(m); for (int i = 0; i \u0026lt; m; i++) { mat[i].resize(n); for (int j = 0; j \u0026lt; n; j++) { mat[i][j] = -1; } } } }; // BSF状态结构 class State { public: int px; int py; int step = 0; State(int px, int py, int step, Map map) { this-\u0026gt;px = px; this-\u0026gt;py = py; this-\u0026gt;step = step; } }; // 马的移动 int dx[] = {-1, 1, 2, 2, -1, 1, -2, -2}; int dy[] = {-2, -2, -1, 1, 2, 2, -1, 1}; // 地图大小 int MaxX = 0; int MaxY = 0; // 出界判断 bool IsOutBorder(int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0) { return true; } if (x \u0026gt;= MaxX || y \u0026gt;= MaxY) { return true; } return false; } // BFS函数 void BFS(Map map, int x, int y) { // 使用std库中的队列来处理 std::queue\u0026lt;State\u0026gt; q; // 初始化第一个状态 map.At(x, y) = 0; q.push(State(x, y, 0, map)); // 进入BFS循环 while (!q.empty()) { // 获取队列顶部对象 State temp = q.front(); q.pop(); // 生成下面可能的8个状态 for (int i = 0; i \u0026lt; 8; i++) { // 临时的位置 int tx = temp.px + dx[i]; int ty = temp.py + dy[i]; // 判断是否出界 if (IsOutBorder(tx, ty)) { continue; } // 判断这个位置是否有马走过 if (map.At(tx, ty) != -1) { continue; } int ts = temp.step + 1; // 向全局地图中添加标记 map.At(tx, ty) = ts; // 向队列中添加新的状态 q.push(State(tx, ty, ts, map)); } } // 最后，输出答案 map.ShowMap(); } // main入口，负责读取与启动 int main(int argc, char **argv) { int x, y; std::cin \u0026gt;\u0026gt; MaxX \u0026gt;\u0026gt; MaxY \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; BFS(Map(MaxX, MaxY), x - 1, y - 1); return 0; } \u0026lt;0x03\u0026gt; 遇到的坑\r主要也就是最后输出的时候矩阵反了\n因为题目给的样例答案也是沿对角线对称的，一开始还真没发现\n","date":"2024-07-20T23:05:43+08:00","permalink":"https://mlacookie.github.io/article/categories/coderrecovery/%E7%AE%97%E6%B3%95%E5%BA%B7%E5%A4%8D%E8%AE%A1%E5%88%9201-%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86/","title":"算法康复计划01 马的遍历"},{"content":"嘶，总算是学校的事情忙完了，终于有点时间写写博客了\n这个学期感觉一直都在和时间赛跑，没啥时间写博客，自己的项目也基本都断了\n当然这些都是另外的话题了\n如果之前有看过我博客的人，应该会发现现在网页大变样了\n现在博客的框架从Hexo换到了Hugo\n中间切换花了我很多时间，里面也有很多能说道说道的\n需要注意的是，我的部署方案跟官方的不一样，所以部分配置会和官方文档有所出入\n\u0026lt;0x00\u0026gt; 为什么要换框架\r简单来说，也算是我闲着没事干\n当然，之前Hexo的流程不是很舒服，写博客的话图片很不好引用\n然后的话主题也不是很好看（我没时间去改主题）\n然后正好想尝试下新东西，然后就看到了Hugo，于是就试了试\n尝试之后发现这个框架使用体验确实舒适很多，于是就打算换框架了\n换了框架后，好处主要有以下几点：\n文章的图片资源可以更好的管理 Obsidian更好的融合 舒适的预览体验 \u0026lt;0x01\u0026gt; 安装Hugo与新建站点\r安装Hugo\r以windows为例，其他系统只能自己看资料了 安装Hugo是很简单的\n如果有安装scoop的话，可以直接敲命令安装\nscoop install hugo-extended 这里安装的是带扩展的版本，因为我使用的主题需要这个\n如果有安装winget，也可以直接敲命令安装\nwinget install Hugo.Hugo.Extended 如果上面两个包管理器都没安装，那么需要从Release中下载预构建的版本\n找到带windows的压缩包下载，里面会有一个hugo.exe\n然后丢到什么路径，添加到windows环境变量里面，这样就可以在命令行中调用了\n新建Hugo站点\r完成安装后，尝试新建站点来测试是否安装成功\n在希望存放站点内容的位置打开终端\nhugo new site TestBlog 这样会在这个位置创建叫TestBlog的文件夹，里面会包含hugo站点的结构\n以上就完成了Hugo站点的搭建\n\u0026lt;0x02\u0026gt; 配置Stack主题\r这里使用的主题是Stack，简洁好看\n路径约定\r./表示存放所有Hugo站点的路径\n所以./TestBlog就是存放TestBlog站点的路径\n本文后面所有的路径都将按此表示\n安装Stack主题\r./TestBlog/themes是存放所有主题的路径\n在此打开终端\ngit clone https://github.com/CaiJimmy/hugo-theme-stack.git 克隆主题仓库\n然后回到./TestBlog，里面有个hugo.toml\n将theme的值修改为'hugo-theme-stack'\n配置头像\r进入./TestBlog/themes/hugo-theme-stack\n这里是Stack主题的文件\n我们需要修改的头像在./TestBlog/themes/hugo-theme-stack/assets/img中\n那个avatar.png便是我们我修改的图像\n找自己的头像拖进去然后改名就可以了\n配置网站图标\r配置网站图标稍微麻烦点\n首先进入./TestBlog/themes/hugo-theme-stack\n创建叫static的文件夹，里面放入网站图标，这里取名favicon.webp\n然后回到./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n找到favicon，将值改为favicon.webp，也就是网站图标的文件名\n配置社交媒体菜单\r（指的是这个东西）\n在./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n在文件最后添加这些东西\nmenu: main: [] social: - identifier: github name: 起个名吧 url: GitHub链接 params: icon: brand-github - identifier: bilibili name: 起个名吧 url: bilibili链接 params: icon: brand-bilibili 但仅仅这样是不行的，如果构建网页会说没有brand-bilibili.svg\n所以我们需要添加这个svg\n进入./TestBlog/themes/hugo-theme-stack/assets/icons，里面是所有的图标文件\n新建一个文件，命名为brand-bilibili.svg，添加以下内容\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentcolor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili\u0026#34;\u0026gt; \u0026lt;path stroke=\u0026#34;none\u0026#34; d=\u0026#34;M0 0h24v24H0z\u0026#34; fill=\u0026#34;none\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M8 3l2 3\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M16 3l-2 3\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M9 13v-2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M15 11v2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; （从别人博客薅的）\n保存即可\n如果要添加其他网站图标也是这样\n\u0026lt;0x03\u0026gt; 文章路径与侧栏\rHugo的所有文章都是放在./TestBlog/content里面\nHugo支持页面包来对文章资源进行管理\n页面包就是按路径对文章进行打包，一个文章只能访问自己页面包内的内容\n这样就将每个文章独立开来，不像之前Hexo所有图片都在一个文件夹中\n（或许Hexo也有办法实现，但我不知道）\n修改默认文章目录\rStack主题默认指定./TestBlog/content/post为文章目录\n这里我改成了./TestBlog/content/article\n在./TestBlog/themes/hugo-theme-stack，打开文件config.yaml\n找到mainSections将值改为article即可\n侧栏部分\r这里的配置建议参考Stack主题给的exampleSite配置\n直接按page里面的结构配置即可\n文章路径参考\r我这的文章路径是这样的\ncontent ├── article | ├── posts | | ├── 随便起的文章名字 | | | ├── picture | | | | └── 1.png | | | └── index.md | | ├── ... | | └── ... | └── categories | ├── Blog | | ├── 随便起的文章名字 | | | ├── picture | | | | └── 1.png | | | └── index.md | | ├── ... | | └── ... | ├── ... | └── ... ├── page | ├── about | | └── index.md | ├── archives | | └── index.md | ├── links | | └── index.md | └── search | └── index.md └── _index.md \u0026lt;0x04\u0026gt; obsidian配置\r用obsidian在./TestBlog/content创建仓库\nobsidian里面需要配置的东西不多，主要是把链接设置为相对文件的路径\n这样配置就可以了\n由于使用页面包进行管理，所以所有的文章文件名都是index.md\n这个会导致obsidian节点视图之类的功能显示的都是index，我目前没有很好的办法\n\u0026lt;0x05\u0026gt; 部署到Github Page上\r虽然官方文档有讲，但他们采用的是将整个站点push到github上\n然后采用Github Action来在上面构建网页\n这样的话如果Action脚本有误可能导致github page行为和本地测试不一样\n我打算本地构建，然后将构建好的网页push到github上面，这样逻辑跟Hexo那套差不多\n但Hugo没有这样的自动部署配置，所以要自己来\n大致流程是在./TestBlog/public中初始化git仓库\n添加远程git仓库\n拉取后提交所有更改\n如果需要切换分支的话再切换分支\n之后只要构建后提交更改并上传即可\n具体命令参考下面的自动化脚本\n\u0026lt;0x06\u0026gt; 通过PowerShell实现自动化\r因为是在windows平台，所以这里采用PowerShell来实现一些自动化\n统一变量配置\r因为会有好几个脚本，所以需要一个统一的变量配置\n# configs.ps1 # 获取脚本文件夹路径 $global:ShellScriptDir = Get-Location # 主目录 Set-Location .. $global:SiteDir = Get-Location Set-Location $global:ShellScriptDir # 内容目录 $global:ContentDir = Join-Path -Path $global:SiteDir -ChildPath \u0026#34;content\u0026#34; # 文章目录 $global:ArticleDir = Join-Path -Path $global:ContentDir -ChildPath \u0026#34;article\u0026#34; # 一般文章目录 $global:PostsDir = Join-Path -Path $global:ArticleDir -ChildPath \u0026#34;posts\u0026#34; # 分类文章目录 $global:CategoriesDir = Join-Path -Path $global:ArticleDir -ChildPath \u0026#34;categories\u0026#34; # 基础URL $global:BaseURL = \u0026#34;[...]\u0026#34; # 远程Git仓库链接 $global:RemoteGitURL = \u0026#34;[...]\u0026#34; # 目标分支 $global:TargetBranch = \u0026#34;[...]\u0026#34; # 编辑器路径 $global:EditorPath = \u0026#34;[...]\u0026#34; 创建文章\r因为希望每次创建文章都会自动创建对应的页面包，所以也需要一个脚本\n# NewPost.ps1 param( [string] [ValidateNotNullOrEmpty()] $PostName, [string] $CategoryName, [bool] $IsStartServer = $false, [bool] $IsCreatePictureFolder = $false ) function ValidatedName { param ( [string] [ValidateNotNullOrEmpty()] $Name ) # 其他的特殊字符 $SpecialCharacters = [char[]]@( \u0026#34;` \u0026#34; \u0026#34;`!\u0026#34; \u0026#34;`$\u0026#34; \u0026#34;`%\u0026#34; \u0026#34;`\u0026amp;\u0026#34; \u0026#34;`\u0026#39;\u0026#34; \u0026#34;(\u0026#34; \u0026#34;)\u0026#34; \u0026#34;*\u0026#34; \u0026#34;,\u0026#34; \u0026#34;-\u0026#34; \u0026#34;/\u0026#34; \u0026#34;:\u0026#34; \u0026#34;;\u0026#34; \u0026#34;\u0026lt;\u0026#34; \u0026#34;=\u0026#34; \u0026#34;\u0026gt;\u0026#34; \u0026#34;?\u0026#34; \u0026#34;@\u0026#34; \u0026#34;[\u0026#34; \u0026#34;]\u0026#34; \u0026#34;^\u0026#34; \u0026#34;_\u0026#34; \u0026#34;``\u0026#34; \u0026#34;{\u0026#34; \u0026#34;|\u0026#34; \u0026#34;}\u0026#34; \u0026#34;~\u0026#34; ) # 因为我会写C#相关的文章，#有一些意义，对#做特殊替换 $Name = $Name.Replace(\u0026#34;`#\u0026#34;, \u0026#34;sharp\u0026#34;) # 先每个替换成- foreach ($Character in $SpecialCharacters) { $Name = $Name.Replace($Character, \u0026#34;-\u0026#34;) } # 返回时使用正则表达式匹配连续的-，并替换为单个- return $Name -Replace \u0026#39;([-])+\u0026#39;, \u0026#39;-\u0026#39; } # 保存当前的工作路径 $localDir = Get-Location # 导入配置变量 . .\\configs.ps1 # 切换工作路径 Set-Location $global:SiteDir # 合法化路径名，不然图片会出问题 $validPath = ValidatedName -Name $PostName # 普通文章创建 if ($CategoryName -eq \u0026#34;\u0026#34;) { # 新建Hugo文章 $newPostPath = Join-Path -Path \u0026#34;content\\article\\posts\u0026#34; -ChildPath (Get-Date -Format \u0026#34;yyyy\u0026#34;) $newPostPath = Join-Path -Path (Join-Path -Path $newPostPath -ChildPath $validPath) -ChildPath \u0026#34;index.md\u0026#34; hugo new $newPostPath # 生成图片文件夹路径 $newPostPicture = Join-Path -Path (Join-Path -Path $global:PostsDir -ChildPath $validPath) -ChildPath \u0026#34;picture\u0026#34; } # 需要分类的文章 else { # 新建Hugo文章 $categoryPath = Join-Path -Path \u0026#34;content\\article\\categories\u0026#34; -ChildPath $CategoryName $newPostPath = Join-Path -Path (Join-Path -Path $categoryPath -ChildPath $validPath) -ChildPath \u0026#34;index.md\u0026#34; hugo new $newPostPath # 生成图片文件夹路径 $categoryPath = Join-Path -Path $global:CategoriesDir -ChildPath $CategoryName $newPostPicture = Join-Path -Path (Join-Path -Path $categoryPath -ChildPath $validPath) -ChildPath \u0026#34;picture\u0026#34; } # 需要创建图片文件夹的话就创建 if ($IsCreatePictureFolder) { mkdir $newPostPicture } # 启动编辑器 # Start-Process $global:EditorPath # 是否开启服务器预览 if ($IsStartServer) { hugo server } # 返回之前的工作路径 Set-Location $localDir 使用示例\n# 创建一篇普通的文章 .\\NewPost.ps1 -PostName 从Hexo到Hugo-记录博客框架切换 # 创建一篇文章，并分类为Blog .\\NewPost.ps1 -PostName 从Hexo到Hugo-记录博客框架切换 -CategoryName Blog 运行后会创建对应的页面包\n发布\r这里涉及到两个文件，一个InitGit.ps1用来初始化git仓库，一个Deploy.ps1做推送\nInitGit.ps1如下\n# InitGit.ps1 param( [bool] $IsForcePush = $false ) # 保存当前的工作路径 $localDir = Get-Location # 导入配置变量 . .\\configs.ps1 # 切换工作路径 Set-Location (Join-Path -Path $global:SiteDir -ChildPath \u0026#34;public\u0026#34;) # 初始化git git init git remote add origin $global:RemoteGitURL git pull git add . git commit -m (\u0026#34;Init: \u0026#34; + (Get-Date -Format \u0026#34;yyMMdd-HH:mm\u0026#34;)) git branch -u $global:TargetBranch if ($IsForcePush) { git push origin HEAD:$global:TargetBranch --force } # 返回之前的工作路径 Set-Location $localDir Deploy.ps1如下\n# Deploy.ps1 param( [bool] $IsForcePush = $false, [bool] $IsClearDeploy = $false ) # 保存当前的工作路径 $localDir = Get-Location # 导入配置变量 . .\\configs.ps1 # 切换工作路径 Set-Location $global:SiteDir # 清除Hugo构建缓存 if ($IsClearDeploy) { # 递归删除所有文件 Remove-Item -Path (Join-Path -Path $global:PublicDir -ChildPath \u0026#34;*\u0026#34;) -Recurse } # 构建网页 hugo --gc --minify --baseURL $global:BaseURL # 准备推送 Set-Location $global:PublicDir # 没有初始化git的化就先初始化并强制推送 if (-not (Test-Path \u0026#34;.git\u0026#34;)) { . (Join-Path -Path $global:ShellScriptDir -ChildPath \u0026#34;InitGit.ps1\u0026#34;) -IsForcePush $true } else { git add . git commit -m (\u0026#34;Deploy: \u0026#34; + (Get-Date -Format \u0026#34;yyMMdd-HH:mm\u0026#34;)) # 是否强制推送 if ($IsForcePush) { git push origin HEAD:$global:TargetBranch --force } else { git push origin HEAD:$global:TargetBranch } } # 返回之前的工作路径 Set-Location $localDir 使用示例\n# 正常的发布 .\\Deploy.ps1 # 清空所有构建缓存发布 .\\Deploy.ps1 -IsClearDeploy 运行即可推送到GitHub Page上\n批量创建页面包路径结构\r因为之前使用的是hexo，里面都是单独的markdown文件\n如果自己手动一个一个移动并创建picture文件夹那就太累了\n所以还是要写一个脚本完成自动化\n# TransFromSingleFile.ps1 param( [string] [ValidateNotNullOrEmpty()] $postDir ) # 排除文件名单 $excludeList = \u0026#34;_index\u0026#34; Get-ChildItem -Path $postDir -File | ForEach-Object { if ($_.BaseName -notin $excludeList) { # 创建文件夹并移动 $destDir = Join-Path -Path $postDir -ChildPath $_.BaseName New-Item -ItemType Directory -Force -Path $destDir Move-Item -Path $_.FullName -Destination (Join-Path -Path $destDir -ChildPath \u0026#34;index$($_.Extension)\u0026#34;) # 创建对应的picture文件夹 $newPostPicture = Join-Path -Path $destDir -ChildPath \u0026#34;picture\u0026#34; mkdir $newPostPicture } } 使用示例\n.\\TransFromSingleFile.ps1 [某个路径] 运行可以为路径内所有文件创建同名文件夹，并将文件移动至对应文件夹后重命名为index.md\n里面也会创建picture文件夹\n","date":"2024-07-20T15:02:34+08:00","permalink":"https://mlacookie.github.io/article/categories/blog/%E4%BB%8Ehexo%E5%88%B0hugo-%E8%AE%B0%E5%BD%95%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E5%88%87%E6%8D%A2/","title":"从Hexo到Hugo 记录博客框架切换"},{"content":"（说实话我有点后悔用C#写Opencv了） 今天我们神秘的数字图像处理做实验了\n虽然东西是挺简单的，但因为我用的是C#，导致很多现成的代码都没法抄\n再加上虽然Opencvsharp4宣称是和C++的API是对应的\n但实际上的开发体验差别真挺大的，很多API的调用方法是不一样的\n（有些调用像C++，有些调用有自己的特色）\n基本上所有的代码都要自己去试，写着挺痛苦的\n所以还是讲讲我们做了啥吧\n\u0026lt;0x00\u0026gt;读取图像\r这个其实是简单的\n假设需要读取一个图片，比方说是D:/Test/1.png\n通过Cv2.ImRead()方法就可以读取为内置的矩阵类型了\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); 这个方法可以读取一般常见的图片格式\n然后，这个方法还可以传入第二个参数，用来控制读取的行为\n比方说我们希望获取的是图像的灰度图\nMat grayImage = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;, ImreadModes.Grayscale); ImreadModes是一个枚举类型，有很多常用的读取行为\n一般也就是这个ImreadModes.Grayscale获取灰度图用的多\nCv2.ImRead()这个参数的默认值是ImreadModes.Color，即默认读入带颜色的图像\n\u0026lt;0x01\u0026gt;将有色图转换为灰度图\r前面提到，我们可以指定读取图片时保存为灰度图\n那有没有别的在运行时从有色图转换为灰度图的方法呢？\n肯定是有的\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat grayImage = iamge.CvtColor(ColorConversionCodes.RGB2GRAY); 这样也完成了转换\n还有一个等价的写法\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat grayImage = new(); Cv2.CvtColor(image, grayImage, ColorConversionCodes.RGB2GRAY); 这样写也行\nCvtColor()方法中，传入的ColorConversionCodes也是个枚举类型\n里面也有很多常用的转换方式，有什么RGB2BGR之类的\n\u0026lt;0x02\u0026gt;图像按位取反\r这个在C#中的写法确实跟C++之类的挺像的\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat inversedImage = new(); Cv2.BitwiseNot(image, inversedImage); 当然也可以自己写对每个位的操作，但这样就太麻烦了\n\u0026lt;0x03\u0026gt;图像对比度增强\r关于图像对比度增强的办法有很多，我这里用的是限制对比度自适应直方图均衡化的办法\n（原理我也说不出来，没细学，还是看别的大佬的文章吧）\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat enhancedImage = new(); CLAHE clahe = Cv2.CreateCLAHE(3, new OpenCvSharp.Size(8, 8)); clahe.Apply(image, enhancedImage); 第一个参数表示像素出现的阈值，应该是百分比阈值，默认是40\n第二个参数表示重新分配的大小\n限制对比度自适应直方图均衡化的大体过程如下\n首先会统计每种像素的出现次数\n然后跟设置的阈值对比，如果超过阈值，会把多余的像素按设定的大小重新分配给别的类型的像素\n总之确实是能增强对比度（真说不大明白）\n\u0026lt;0x04\u0026gt;图像二值化\r所谓二值化算是极端化的灰度图，只有黑白两种颜色\n代码如下\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat binarizedImage = image.Threshold(127, 255, ThresholdTypes.Binary); 也有稍微麻烦点的写法\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat binarizedImage = new(); Cv2.Threshold(image, binarizedImage, 127, 255, ThresholdTypes.Binary); Threshold()第一个数字是阈值，第二个值算是默认值，具体行为看第三个参数\nThresholdTypes是一个枚举类型，表示如何处理图像\n二值化的时候这个值取ThresholdTypes.Binary，表示像素值大于阈值时用默认值，否则赋值0\n比方说在二值化的时候，某像素值为128\u0026gt;127，那么就会把它的值变为255\n其他的行为这里就不展开了\n\u0026lt;0x05\u0026gt;图片相加\r同大小图片相加\r这个其实很简单，毕竟在Opencv眼里，所有的图片都是矩阵，相加不是很简单嘛\nMat A = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat B = Cv2.ImRead(\u0026#34;D:/Test/2.png\u0026#34;); Mat addedImage = A + B; （就这样写就可以了）\n不嫌烦的话还有下面的写法\nMat addedImage = A.Add(B); Mat addedImage = new(); Cv2.Add(A, B, addedImage); 不同大小的图片相加\r这些Add()方法要求矩阵大小一致，相当于要求图片大小一致\n那如果我们就是要不同大小图片相加，就要多做些处理\n我的处理方式是\n先在比较大的图片中扣出跟小图片一样大小的部分\n抠出的图和小图片相加，然后再替换掉大图片扣掉的部分\n怎么抠出图像\rOpencvsharp4中有个Rect类型，可以用来划出需要的部分\n类型声明示例\nRect rect = new(0, 0, 100, 100); 前面表示起始位置，也即矩形的左上角的点坐标，后面两个参数表示矩形大小\n对于一个图像，假设我们需要在图像(100, 100)的地方扣出200*200大小的图片\n代码如下\nMat image = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat temp = image[new Rect(100, 100, 200, 200)]; 需要注意的是，这里的temp获取到的是image对应区域的引用\n对temp的所有修改也会反应到image上\n如果需要新建一个矩阵，需要用CopyTo()方法\n完整的代码\r有了上面的基础，现在给出完整的图片相加代码\nMat L = Cv2.ImRead(\u0026#34;D:/Test/1.png\u0026#34;); Mat S = Cv2.ImRead(\u0026#34;D:/Test/2.png\u0026#34;); //还需要注意框选的区域不能超过大图片的范围 Mat temp = image[new Rect(100, 100, S.Width, S.Height)]; temp = temp + s; 这样就可以了，至于图片相减也是差不多这样的代码\n","date":"2024-03-18T12:59:53Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-03/","title":"关于我用C#写Opencv这件事-03"},{"content":"这次来讲讲怎么在Godot中使用Opencv\n大体还是很简单的，因为Godot项目中是可以使用Nuget的 （Godot的C#后端比较新） 所以直接在项目中引用Opencvsharp4的包就好了 而且大体上的代码也是不变的 基本就是多一步转换成ImageTexture就可以\n还是以捕获摄像头为例 首先需要一个Sprite2D节点 创建一个脚本与之绑定 然后脚本代码如下\nusing Godot; using OpenCvSharp; public partial class CameraBehavior : Sprite2D { readonly VideoCapture camera; readonly Mat frame = new(); public override void _Ready() { camera = new VideoCapture(index, captureAPI); } public override void _Process(double delta) { //用_Process()代替了原来的while循环 camera.Read(frame); if (frame.Empty()) { Debug.WriteLine(\u0026#34;No Image\u0026#34;); return null; } var bytes = frame.ToBytes(); Image img = new(); img.LoadPngFromBuffer(bytes); Texture = ImageTexture.CreateFromImage(img); } } 这样，与之绑定的Sprite2D就可以显示摄像头捕获的画面了\n然后调整下摄像头捕获画面的大小和Sprite2D的位置\nOpencv中别的处理也可以用类似的方式实现 这样就相当于Godot负责前端的显示渲染，C#代码部分负责后端的逻辑算法处理\n（这篇写得比较水，下一篇来个大的）\n","date":"2024-03-17T02:19:35Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-02/","title":"关于我用C#写Opencv这件事-02"},{"content":"怎么突然要用Opencv了\r我们有一门神秘课程，课设要写一个Opencv的应用 我是不知道我们臭做游戏的学这个有啥用\n总之我要整这么一个Opencv的应用 最后我打算做一个基于Opencv的AR应用 （这样还算跟我的专业有点联系）\n大致的架构\r语言的话当然是我心爱的C# 然后配合Godot来渲染\n这样的好处就是语言是我熟悉的，大致的运行模型是有的 然后拜.net不断进化所赐，跨平台也好做 Godot本身也是跨平台的，到时候也能移植到安卓上 （虽然跨平台算是个添头）\n怎么用C#写Opencv\r现在大致的架构有了，怎么用C#做Opencv开发呢 这就要用到些Nuget包了\n在.net中做这种开发，需要用到opencvsharp4这个包 （或者说用EmguCV包，这个我没用过）\n需要注意的是，opencvsharp4这个包貌似不同版本的api不一样 （怎么跟之前的SharpPcap一样） 所以这里包括之后的代码不一定能在之后和之前的版本运行，就当个参考吧 我这用的版本是4.9.0\n这个包本质上就是原本的Opencv在C++的库做了封装 自己用在工程上还是要自己做一些封装的 虽然确实还是能照C++代码写出C#的代码 但会非常痛苦，会遇到包括但不限于名称对不上、神秘类型的问题\n如何捕获摄像头画面\r作为系列的第一篇博客，也讲讲我写的第一段关于Opencv的代码吧 Opencv中包含了一些捕获摄像头的功能， 这样就不需要别的库来做这个了\n先贴出代码\nusing OpenCvSharp; namespace OpenCVTest; public class Program { // 视频捕获设备 static VideoCapture camera = new(0); // 捕获的帧 static Mat frame = new(); public static void Main() { // 设置休眠时间 int sleepTime = (int)Math.Round(1000 / capture.Fps); while(true) { camera.Read(frame); if(frame.Empty()) { break; } // 显示 Cv2.imshow(\u0026#34;Test\u0026#34; , frame); Cv2.WaitKey(sleepTime); } } } 这样就完成了摄像头画面的捕获，其实还是挺简单的\n下面稍微解释下代码 VideoCapture类是Opencv库自带的视频捕获类型 它的构造函数里可以输入两个参数，第一个是捕获的设备标号，表示用哪个摄像头 第二个是捕获用的API，默认参数是Any，基本上不用动\nMat在Opencv中代表矩阵，具体的数据是交给C++的库处理的 Opencv中的几乎所有操作都是对矩阵的操作 关于Mat还有很多能说的，但这里说就要展开太多了，之后讲到再提\n下面的Cv2.imshow()就是一个通用的显示方法，可以显示图片之类的 Cv2.WaitKey()表示等待的时间\n","date":"2024-03-13T21:51:11Z","permalink":"https://mlacookie.github.io/article/categories/opencv/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8c%23%E5%86%99opencv%E8%BF%99%E4%BB%B6%E4%BA%8B-01/","title":"关于我用C#写Opencv这件事-01"},{"content":"最近在写一个WPF项目，然后今天遇到个非常神秘的问题 就是界面的InitializeComponent()莫名奇妙报错找不到方法了 我仔细检查代码，也没发现问题 而且最抽象的是，程序也能正常运行 我用ILSpy去看编译后的文件，发现InitializeComponent()也是有的\n但报错看着总是不舒服啊，还是要解决 参考网上的说法，进入项目的文件夹 然后把obj文件夹删掉，再在vs里面重新生成一下就好了 据说是因为分布类的问题，实际编译时生成的代码是正确的 但是IntelliCode依赖的文件可能没更新上 然后就开始误报找不到InitializeComponent()\n总之还是一个很神秘的问题\n","date":"2024-03-07T01:10:14Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADinitializecomponent-%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/","title":"WPF开发过程中InitializeComponent()神秘报错"},{"content":"闲着没事想着优化一下hexo的博客配置 我原来一直都是用vscode写markdown的，至于体验嘛，能写但不是很舒适 所以我就尝试换成了现在在用的obsidian，体验就好多了\n然后就按网上的教程，尝试配置更加优雅的流程 然后发现原来用的hexo框架有点老了，就干脆重装了 没想到啊，重装个hexo又出了很多问题 所以这篇博客就从hexo的安装开始讲吧\n\u0026lt;0x00\u0026gt; hexo的安装\r（一般情况下跟着hexo官方教程没啥问题） 首先是要有Node.js环境，这个随意，最好是最新的版本 还要安装git，这个直接网上找安装包安装就好了\nnpm换源\rnpm原本的国内连接不畅，所以要换源 一般是换成国内的淘宝源\n一般敲命令方法\rnpm config set registry https://registry.npm.taobao.org 通过nrm切换\rnrm是npm的源管理器，可以在不同的源中切换 如果没有什么特殊上网方式访问原本的源的话还是建议先手动切换源 （nrm也是靠npm下载的）\n# -g参数表示全局安装，这样的话可以在任何目录中使用nrm npm install -g nrm nrm use taobao # 查看其它可以用的源 nrm ls # 测试源 nrm test 安装hexo\r首先是安装hexo环境\nnpm install -g hexo-cli 然后挑一个空的文件夹，初始化 （这里取名叫HexoBlog了）\nhexo init ./HexoBlog 然后原本空的文件夹里面会生成一些文件 安装hexo依赖\ncd ./HexoBlog npm install 这样之后，hexo就搭建好了 但貌似hexo的依赖文件写的版本可能比较老了，最好还是更新一下\nnpm update \u0026lt;0x01\u0026gt; 安装Anatolo主题\r别的主题就看具体的安装说明了，我这里还是用Anatolo了\n首先是在HexoBlog文件夹\ngit clone https://gitee.com/Lhcfl/hexo-theme-anatolo.git themes/Anatolo npm install hexo-renderer-pug --save npm install hexo-renderer-stylus --save 然后进入HexoBlog/themes/Anatolo中，复制_config.example.yml为_config.yml 这个_config.yml是Anatolo的配置文件 这里还需要多做一步，这一步在原本的安装文件中没有说\nnpm install 需要在Anatolo中再安装一次依赖，如果没有这一步的话运行时会报错找不到模块 我的猜想是我们在安装hexo依赖时没有全局安装，所以要在这里再安装一次 （或者所有的npm都-g全局安装也行，但这样对C盘不友好，尤其是像我并不是专门做Nodejs开发的人）\n然后回到HexoBlog，修改_config.yml中的theme: Anatolo 这样主题也安装好了\n\u0026lt;0x02\u0026gt; 优化Hexo配置\r部署到Github Page上\r这个网上的教程足够多了，这边不细讲 就是记得安装hexo-deployer-git插件就好 在HexoBlog中\nnpm install hexo-deployer-git --save 更方便的分文件管理\rhexo的默认所有的博客文章都存放在HexoBlog/source/_posts下面 虽然可以在里面用文件夹归类不同的文章，但需要给这些博客手动写上categories属性 这就很麻烦了，手写麻烦还容易出错\n可以安装一个插件，hexo-auto-category 它可以在hexo生成网页时自动给每个博客打上对应的categories属性\n在HexoBlog中\nnpm install hexo-auto-category --save 修改_config.yml，添加下面的语句\nauto_category: enable: true depth: 这样就安装好并启用了\n\u0026lt;0x03\u0026gt; 使用obsidian作为编辑器\robsidian确实香，比起原本的vscode好多了，毕竟是专门的markdown编辑器 但要在hexo中使用obsidian作为编辑器，还需要做一些小优化\n仓库的话，用obsidian打开HexoBlog/source/_posts就可以了\n图片问题\rhexo在生成时，图片需要在HexoBlog/source下面 但由于obsidian打开的目录在HexoBlog/source/_posts，所以会检索不到图片\n我的解决方案是在HexoBlog/source下面新建picture文件夹来专门存图片 然后在HexoBlog/source/_posts下面添加picture软连接，让obsidian可以检索到\n添加软连接的命令在powershell下和cmd下面有所不同，但都需要管理员权限\n# powershell New-Item -ItemType SymbolicLink -Path $放的地方 -Name $名字 -Target $连接的目标 # cmd mklink /d $软连接存放路径 $连接的目标 然后就是在obsidian中编辑时，引用图片的格式应是![](/picture/...) 最好把obsidian的文件与链接\u0026gt; \u0026gt; 自动添加wiki引用关了，[[]]格式的连接hexo本身解析不了 （貌似有插件在解决这个问题，但我没试成功过）\n\u0026lt;0x04\u0026gt; 使用脚本做自动化\rhexo的生成和部署都还是靠cli命令的 所以可以写一些脚本来做一些自动化 这里的脚本都是powershell脚本\n新建博客文章并编辑\r# (@24-03-07) 优化脚本，增加去除URL特殊字符 param( [string] [ValidateNotNullOrEmpty()] $Name ) function ValidatedName { param ( [string] [ValidateNotNullOrEmpty()] $Name ) $SpecialCharacters = [char[]]@( \u0026#34;` \u0026#34; \u0026#34;`!\u0026#34; \u0026#34;`\u0026#34;\u0026#34; \u0026#34;`#\u0026#34; \u0026#34;`$\u0026#34; \u0026#34;`%\u0026#34; \u0026#34;`\u0026amp;\u0026#34; \u0026#34;`\u0026#39;\u0026#34; \u0026#34;(\u0026#34; \u0026#34;)\u0026#34; \u0026#34;*\u0026#34; \u0026#34;+\u0026#34; \u0026#34;,\u0026#34; \u0026#34;-\u0026#34; \u0026#34;.\u0026#34; \u0026#34;/\u0026#34; \u0026#34;:\u0026#34; \u0026#34;;\u0026#34; \u0026#34;\u0026lt;\u0026#34; \u0026#34;=\u0026#34; \u0026#34;\u0026gt; \u0026#34; \u0026#34;?\u0026#34; \u0026#34;@\u0026#34; \u0026#34;[\u0026#34; \u0026#34;\\\u0026#34; \u0026#34;]\u0026#34; \u0026#34;^\u0026#34; \u0026#34;_\u0026#34; \u0026#34;``\u0026#34; \u0026#34;{\u0026#34; \u0026#34;|\u0026#34; \u0026#34;}\u0026#34; \u0026#34;~\u0026#34; ) # 先每个替换成- foreach ($Character in $SpecialCharacters) { $Name = $Name.Replace($Character, \u0026#34;-\u0026#34;) } # 返回时使用正则表达式匹配连续的-，并替换为单个- return $Name -Replace \u0026#39;([-])+\u0026#39;, \u0026#39;-\u0026#39; } # 指定Obsidian目录 $ObsidianPath = \u0026#34;C:\\Users\\cookie\\scoop\\apps\\obsidian\\current\\Obsidian.exe\u0026#34; # 新建hexo博客 hexo new $Name # 去除URL特殊字符 $Name=ValidatedName -Name $Name # 创建图片文件夹 mkdir ./source/picture/$Name # 启动Obsidian Start-Process $ObsidianPath -ArgumentList ./source/_posts # cls Clear-Host 本地化部署测试\rparam( [Int16] $Port ) # 清理hexo缓存 hexo clean # hexo生成 hexo g # 启动本地hexo服务器 if ($Port -eq $null) { hexo server } else{ hexo server -p $Port } \u0026lt;0x05\u0026gt; 安装过程中可能的问题\rhexo的有些依赖可能已经已放弃维护了 比如说hexo-renderer-sass，这个非常容易报错 （貌似删了不影响整体运行） 可以替换成hexo-renderer-sass-next，这个稳定很多\n\u0026lt;0x06\u0026gt; 这套方案的问题\r不支持Obsidian的wiki链接解析 也没用上Obsidian自带的模板功能 文章之间相互引用也很麻烦，要知道文章的具体URL\n","date":"2024-03-03T13:24:40Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E6%88%91%E7%9A%84hexo%E9%85%8D%E5%90%88obsidian%E7%9A%84%E9%85%8D%E7%BD%AE/","title":"我的hexo配合obsidian的配置"},{"content":"我经常会开一堆网页，如果采用水平的标签页的话会经常找不到标签页\n而火狐又不像别的浏览器，起码到目前为止都没有官方的垂直标签页的支持\n经过一番探索，实际上是可以自己改出来的\n\u0026lt;0x00\u0026gt; 效果展示\r效果还是很不错的\n\u0026lt;0x01\u0026gt; 安装Tree Style Tab插件\r这是一个能在侧栏以树的形式管理标签页的插件，功能还挺多的\n这个插件在火狐的插件商店里就有\n别的类似的插件应该也有，但这里就用这个插件了\n建议先熟悉下这个插件的操作再做下面的操作\n\u0026lt;0x02\u0026gt; 打开about:config的一个选项\r首先要打开about:config的关于自定义界面的选项\n火狐会跳出提示，别动别的东西就好\n搜索toolkit.legacyUserProfileCustomizations.stylesheets，把值改成true即可 \u0026lt;0x03\u0026gt; 打开标题栏\r在火狐顶部右键，找到定制工具栏\n（图片右上角）\n然后打开左下角的标题栏\n这样做是为了在隐藏顶栏后还能做拖动窗口之类的操作\n\u0026lt;0x04\u0026gt; 找到用户的profile文件夹\r这个也简单，Win+R输入%APPDATA%\\Mozilla\\Firefox\\Profiles\\\n里面可能会有多个名字很乱的文件夹，问题不大，找到里面文件最多的文件夹\n那个就是存用户设置的地方\n（我这里是这样的）\n\u0026lt;0x05\u0026gt; 创建修改界面的文件\r在刚刚找到的文件夹里新建叫chrome的文件夹\n然后在chrome文件夹里面新建一个userChrome.css的文件\n打开编辑，输入下面的代码\n/*侧边栏头部是否显示，会影响书签侧栏之类的，可以不写*/ #sidebar-header { display: none !important; } /*隐藏顶栏，也就是原来的标签栏*/ #TabsToolbar { visibility: collapse !important; } 然后重启火狐理论上就生效了\n","date":"2024-01-02T21:34:53Z","permalink":"https://mlacookie.github.io/article/posts/2024/%E5%A6%82%E4%BD%95%E5%B0%86firefox%E6%94%B9%E6%88%90%E5%9E%82%E7%9B%B4%E6%A0%87%E7%AD%BE%E9%A1%B5/","title":"如何将Firefox改成垂直标签页"},{"content":"什么是SharpPcap\r最近嘛，要写各种课设，计网也要\n课设就算了，里面还有一个网络编程\n要求捕获些IP数据报，并输出些IP数据报里面的一些数据\n然后一看要求，霍，好家伙，能用C#，那就简单了\n说回正题，要了解什么是SharpPcap，就要先了解WinPcap\nWinPcap是在windows下抓包的工具集合，相当于一个抓包的api\n有了这个，我们就不需要直接与网卡打交道了，要抓包，直接调WinPcap提供的api\nSharpPcap就是把这些api打包成C#的形式，让我们可用在C#中方便的抓包\n安装\r这个就很简单了，直接到Nuget包管理器里面安装就是了\n(@ 24-01-11)\n其实应该用NPcap的，这个比较新，WinPcap有点老了\nWinPcap调用不了无线网卡 这两个SharpPcap都可以调用\nNPcap下载\n在写代码前，还要检查下又没有安装过WinPcap，没有的话会找不到捕获的设备\nWinPcap下载\n这个也是装上就完事了\n写代码\r需要注意的是，SharpPcap貌似重构过好多次，我看到的使用范例有好几版\n但都没用，最后还是靠我自己反编译看的\n(GitHub那里的范例也是不能直接用的)\n总之，我这里用的是6.2.5的版本，别的版本我不管\n丢一段代码，里面带着详细的注释(这段代码也是我计网课设网络编程的代码)\n(@ 24-01-11)\n稍微修改下，原来的代码在处理标识符的逻辑点问题\n(转成BitArray会出现高低位顺序的问题)\nusing System; using SharpPcap; using PacketDotNet; using System.Collections; namespace Test { public class Program { static void Main() { CaptureDeviceList devices = CaptureDeviceList.Instance;//获取所有可用的设备 if (devices.Count \u0026lt; 1) { Console.WriteLine(\u0026#34;No devices were found on this machine\u0026#34;); return; }//没有就直接退出了 Console.WriteLine(\u0026#34;\\nThe following devices are available on this machine:\u0026#34;); Console.WriteLine(\u0026#34;----------------------------------------------------\\n\u0026#34;); for (int i = 0; i \u0026lt; devices.Count; i++) { Console.WriteLine($\u0026#34;index:{i}|{devices[i].Description}\\n\u0026#34;); }//输出可用的设备及其编号 string num = Console.ReadLine();//获取用户输入的编号 ICaptureDevice device = devices[int.Parse(num)];//获取对应的设备对象 device.Open(DeviceModes.Promiscuous, 10000);//准备启动设备 string filter = \u0026#34;ip\u0026#34;; device.Filter = filter;//设置过滤器为ip数据报 device.OnPacketArrival += Device_OnPacketArrival;//设置收到包后的回调方法 device.StartCapture();//开始捕捉 Console.ReadLine(); device.StopCapture();//如果按下任意键，终止捕捉 device.Close();//释放设备 } private static void Device_OnPacketArrival(object sender, PacketCapture e) { var ip = e.GetPacket().GetPacket().Extract\u0026lt;IPPacket\u0026gt;();//把捕捉到的包转换成ip数据报 //因为库里没有处理标识符和片偏移的逻辑，这里要自己写处理逻辑 var s = new BitArray(new byte[] { ip.HeaderData[5], ip.HeaderData[4] });//获取第5第6字节的数据 var symbol = new BitArray(new byte[] { ip.HeaderData[7], ip.HeaderData[6] });//获取第7第8字节的数据 Console.WriteLine(); Console.WriteLine($\u0026#34;Version:\\t{ip.Version}\u0026#34;); Console.WriteLine($\u0026#34;Length:\\t\\t{ip.TotalLength}\u0026#34;); Console.WriteLine($\u0026#34;Serial:\\t\\t{BitArrayToInt(s, 0, 15)}\u0026#34;); Console.WriteLine($\u0026#34;DF:\\t\\t{symbol[14]}\u0026#34;); Console.WriteLine($\u0026#34;MF:\\t\\t{symbol[13]}\u0026#34;); Console.WriteLine($\u0026#34;Offest:\\t\\t{BitArrayToInt(symbol, 0, 12)}\u0026#34;); Console.WriteLine($\u0026#34;From:\\t\\t{ip.SourceAddress}\u0026#34;); Console.WriteLine($\u0026#34;To:\\t\\t{ip.DestinationAddress}\u0026#34;); Console.WriteLine($\u0026#34;Protocol:\\t{ip.Protocol}\u0026#34;); for (int i = 0; i \u0026lt; ip.HeaderData.Length; i++) { if (ip.HeaderData[i] \u0026lt; 16) { Console.Write(\u0026#34;0{0:X} \u0026#34;, ip.HeaderData[i]); } else { Console.Write(\u0026#34;{0:X} \u0026#34;, ip.HeaderData[i]); } if (i % 4 == 3) { Console.WriteLine(); } } Console.WriteLine(); } static int BitArrayToInt(BitArray bitArray, int head, int end)//只是个把二进制数组转换成数字的方法 { int a = 0; for (int i = head; i \u0026lt;= end; i++) { if (bitArray[i]) { a += 1; } a *= 2; } return a; } } } 实际上确实就这么一段代码就够了\n里面的注释也已经点明了具体的功能\n需要注意的是，这里通过事件机制来处理收到包的情况\n也就是这一句\ndevice.OnPacketArrival += Device_OnPacketArrival;//设置收到包后的回调方法 在device收到数据报后，会触发OnPacketArrival事件\n然后就可用用事件那一套机制来处理收到的包了，也就是这一段代码\nprivate static void Device_OnPacketArrival(object sender, PacketCapture e) { var ip = e.GetPacket().GetPacket().Extract\u0026lt;IPPacket\u0026gt;();//把捕捉到的包转换成ip数据报 //因为库里没有处理标识符和片偏移的逻辑，这里要自己写处理逻辑 var s = new BitArray(new byte[] { ip.HeaderData[5], ip.HeaderData[4] });//获取第5第6字节的数据 var symbol = new BitArray(new byte[] { ip.HeaderData[7], ip.HeaderData[6] });//获取第7第8字节的数据 Console.WriteLine(); Console.WriteLine($\u0026#34;Version:\\t{ip.Version}\u0026#34;); Console.WriteLine($\u0026#34;Length:\\t\\t{ip.TotalLength}\u0026#34;); Console.WriteLine($\u0026#34;Serial:\\t\\t{BitArrayToInt(s, 0, 15)}\u0026#34;); Console.WriteLine($\u0026#34;DF:\\t\\t{symbol[14]}\u0026#34;); Console.WriteLine($\u0026#34;MF:\\t\\t{symbol[13]}\u0026#34;); Console.WriteLine($\u0026#34;Offest:\\t\\t{BitArrayToInt(symbol, 0, 12)}\u0026#34;); Console.WriteLine($\u0026#34;From:\\t\\t{ip.SourceAddress}\u0026#34;); Console.WriteLine($\u0026#34;To:\\t\\t{ip.DestinationAddress}\u0026#34;); Console.WriteLine($\u0026#34;Protocol:\\t{ip.Protocol}\u0026#34;); for (int i = 0; i \u0026lt; ip.HeaderData.Length; i++) { if (ip.HeaderData[i] \u0026lt; 16) { Console.Write(\u0026#34;0{0:X} \u0026#34;, ip.HeaderData[i]); } else { Console.Write(\u0026#34;{0:X} \u0026#34;, ip.HeaderData[i]); } if (i % 4 == 3) { Console.WriteLine(); } } Console.WriteLine(); } 这里的e就是捕获到的包，然后就可用进行一系列的处理了\n","date":"2023-12-25T10:01:56Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E7%AE%80%E5%8D%95%E7%94%A8%E4%B8%8Bsharppcap/","title":"简单用下SharpPcap"},{"content":"问题\r最近入了台笔记本，7840HS的，CPU强核显也强\n（主要是没米了）\n然后毕竟是做游戏相关的，Blender总得装上吧\n然后发现，跑Cycles渲染器会报错\nHIP binary kernel for this graphics card compute capability (11.0) not found\n就会报这个错误\n解决办法\r从网站上下源码编译Blender就好\nBuild Blender On Windows\n需要安装\nVS2022的C++桌面开发工作负载 TortoiseSVN Git CMake perl python 然后就按官方文章讲的，在cmd里面运行make update和make就好\n（powershell也不是不行，改成./make，但没试过）\n问题分析\r就是这么个问题\nradeon780m对应得代码是gfx1103\n但是blender正常下载的版本还没有带对应这个代码的驱动文件\n在最新的代码中，已经包含了生成代号gfx1103的驱动文件的代码了\n（其实就是CMakeList里面加了个gfx1103）\n","date":"2023-11-29T22:39:09Z","permalink":"https://mlacookie.github.io/article/posts/2023/radeon780m%E6%A0%B8%E6%98%BE%E8%B7%91blender%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Radeon780m核显跑Blender相关的问题"},{"content":"\u0026lt;0x00\u0026gt; ListView是什么\r贴张图就好了\n就是类似这种一行一行展示信息的控件\n当然也不一定是像这种的类似表格的样子(这种后面会讲)\n但都是一行一行的以行为单位的显示一些集合类的显示控件\n\u0026lt;0x01\u0026gt; 先讲WPF里面自带的ListView\r先给个代码，做一个最简单的演示\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;/Window\u0026gt; //ViewModel.cs //常用引用 namespace WPFTest { internal class ViewModel { public List\u0026lt;string\u0026gt; SomeItems { get; set; } = new List\u0026lt;string\u0026gt;() { \u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;fff\u0026#34;, }; } } 演示的结果\n这个就是最简单的ListView，也是WPF默认的样式\n(从这期开始的图会多一点，以前的博文也会慢慢补图，感觉没图还是不好理解)\n我们可以先分析下这个控件需要什么，我们能得到什么\n首先就肯定是需要一个集合啦\n集合无所谓类型(应该都能用，看你怎么绑定)\n然后我们能得到一个这样的显示\n我们可以看到，在这个控件里面已经实现了页面滚动与子项的选择\n(可以说除了有点不符合当代审美之外都没啥问题)\n单项添加\r有时候可能也不是集合提供子项，可能本身就是写死的\n这时候就要自己写ListViewItem了\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;ListView SelectionMode=\u0026#34;Single\u0026#34;\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something1\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something2\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something3\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something4\u0026#34;/\u0026gt; \u0026lt;ListViewItem Content=\u0026#34;something5\u0026#34;/\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 每个ListViewItem也都能设置自己的Background之类的属性，这里就不多写了\n美化子项\r那我们还是要稍微美化一下的，虽然这样搞已经能用了\n我们有两种方式\n一个是操作ItemStyle，另一个是操作ItemTemplate\n操作ItemStyle\r\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;Red\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;Style.Triggers\u0026gt; \u0026lt;!--Trigger这里就偷懒了--\u0026gt; \u0026lt;/Style.Triggers\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 通过ListView.ItemContainerStyle里面设置ListViewItem的样式\n样式就按一般的方式走，这里就随便设置了下，Triggers也能设置，这里懒得写了\n操作ItemTemplate\r这里需要修改下ViewModel，为了更方便的绑定\n//ViewModel2.cs //常用引用 namespace WPFTest { internal class ViewModel2 { public List\u0026lt;TypicalItem\u0026gt; SomeItems { get; set; } = new List\u0026lt;TypicalItem\u0026gt;() { new TypicalItem(\u0026#34;aaa\u0026#34;, new SolidColorBrush(Color.FromRgb(82,114,248))), new TypicalItem(\u0026#34;bbb\u0026#34;, new SolidColorBrush(Color.FromRgb(72,137,217))), new TypicalItem(\u0026#34;ccc\u0026#34;, new SolidColorBrush(Color.FromRgb(91,199,240))), new TypicalItem(\u0026#34;ddd\u0026#34;, new SolidColorBrush(Color.FromRgb(72,214,217))), new TypicalItem(\u0026#34;eee\u0026#34;, new SolidColorBrush(Color.FromRgb(82,248,205))), }; } class TypicalItem { public string Name { get; set; } public Brush Color { get; set; } public TypicalItem(string name, Brush color) { Name = name; Color = color; } } } \u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 效果就差不多这样\n区别\r实际上两个的侧重点是不一样的\nItemContainerStyle重点在每个子项的样式设置\n比方说就是每个子项的背景，子项按下的动画效果之类的\nItemTemplate侧重在子项内部是怎么显示的\n比方说写了个数据类型，里面有好几条属性\n那么就可以用ItemTemplate来自定义这些属性怎么显示\n我怀疑ListViewItem里面就是包着自己的UI树的\n但可视化树没显示，也不敢说死\n这两个的效果肯定是能合并在一起的，毕竟这俩侧重点是完全不一样的\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;!--其实就加了这一个块--\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 和程序行为合并\r那下一步就是写选中子项的行为了\n我们可以通过设置SelectionChanged事件\n为了演示，先修改下前端代码，这里举选择子项切换Border背景颜色的例子\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;!--加了个Grid，上下分割--\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34; SelectionMode=\u0026#34;Single\u0026#34; SelectionChanged=\u0026#34;ListView_SelectionChanged\u0026#34;\u0026gt; \u0026lt;ListView.ItemContainerStyle\u0026gt; \u0026lt;Style TargetType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/ListView.ItemContainerStyle\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;ListViewItem\u0026#34;\u0026gt; \u0026lt;Border\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34; FontSize=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;!--用来显示子项切换的效果的Border--\u0026gt; \u0026lt;Border Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;MyBorder\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; //MainWindow.xaml.cs //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void ListView_SelectionChanged(object sender, SelectionChangedEventArgs e) { MyBorder.Background = (e.AddedItems[0] as TypicalItem).Color; } } } 这样就解决了\n.xaml的代码就不解释了，.cs的代码还是能讲一下的\n主要就是用e.AddedItems[0]拿到选中的TypicalItem对象\n(e.AddedItems[0]这个语法确实很怪，估计是主要是为了支持多个选中的情况)\n如果给ListView起了名字的话也可以这么写(这里起名是MyListView)\n//MainWindow.xaml.cs //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void MyListView_SelectionChanged(object sender, SelectionChangedEventArgs e) { MyBorder.Background = (MyListView.SelectedItem as TypicalItem).Color; } } } 一般来说这么访问选中的子项会多一点\n因为有些时候会去想双击的代码，这就要用MouseDoubleClick事件了\n但MouseDoubleClick是不带SelectionChangedEventArgs e的\n也就是说我们是不能靠传参变量e来获取选择了哪个子项的\n但靠MyListView.SelectedItem这种方式就方便很多，都能用了\n顺便在这里提一点，如果要定义多个鼠标事件，不能采用传统的.xaml写事件然后在.cs写\n因为这么写运行的时候这些MouseHandler会相互屏蔽而导致有些就触发不了\n比如按传统方式同时设置MouseDoubleClick和MouseRightButtonDown，只能触发前者\n要都能触发，应该在控件的初始化用代码初始化这些Handler\n.xaml里面可以按传统方法留一个，但别的都要靠代码方式添加\n//MainWindow.xaml.cs(随便举例的，与前面的代码无关) //引用 namespace WPFTest { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); //就是在这里自己添加 MyListView.AddHandler(MouseDoubleClickEvent, new MouseButtonEventHandler(this.MyListView_MouseDoubleClick), true); MyListView.AddHandler(MouseRightButtonDownEvent, new MouseButtonEventHandler(this.MyListView_MouseRightButtonDown), true); } private void MyListView_MouseDoubleClick(object sender, MouseButtonEventArgs e) { //处理代码 } private void MyListView_MouseRightButtonDown(object sender, MouseButtonEventArgs e) { //处理代码 } } } 还有就是我还没啥办法实现类似Button绑定ICommand的做法\n但其实可以把方法本体写在VM里，然后在.cs里用DataContext调命令，实现猴版的MVVM\n这里就不细讲了\n网格布局GridView\r博客最上面的图就是使用了GridView的效果\n(就是这张)\nGridView是嵌套在ListView里面的，具体代码如下\n(还是用得ViewModel2.cs)\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34;\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 这样就实现了类似前面那张图的效果了\n这里不难看出GridView是隶属于ListView的\n然后对于每一个格子，也是能自定义Template的\n最上面的是Header，也能自定义\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn\u0026gt; \u0026lt;!--就改了这里--\u0026gt; \u0026lt;GridViewColumnHeader\u0026gt; \u0026lt;TextBlock Text=\u0026#34;emm\u0026#34; Background=\u0026#34;BurlyWood\u0026#34;/\u0026gt; \u0026lt;/GridViewColumnHeader\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 简单写一下就是这样了\n前面讲的SelectionChanged和MouseDoubleClick之类的还是写在ListView的块里\n这样就可以实现表格化的效果了\n\u0026lt;0x02\u0026gt; 讲讲ModernWPF的ListView\r因为有自己的练手项目在用这个包，所以就顺便讲讲了\n(Nuget上有好多叫ModernWPF的包，我自己用的是这个)\n之前的博客也有讲过一点\n在ModernWPF的包里面有两种ListView实现\n一种是使用WPF原生的ListView但修改了Style来匹配风格\n另一种是包里面自己写的ListView\n前者就要求别去改Style，不然所有的样式又要自己写\n后者的化代码风格会更像UWP开发，有些写法确实挺新的\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;!--这里用的是最前面的ViewModel--\u0026gt; \u0026lt;local:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;ListView Grid.Row=\u0026#34;0\u0026#34; ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;ui:ListView Grid.Row=\u0026#34;1\u0026#34; ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; 这里演示了这个包里面的两种写法，效果上是一样的\n其余大部分都可以按WPF原生的写法写\n但如果要用GridView，那么只有原生的写法(这个包没自己写)\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 这里可以看得，如果用GridView的话，右边的滚动条时不会收纳的\n(准确来说自动从收纳状态变成展开状态)\n别的自定义之类的也和WPF原生写法一样，就是尽量别动Style\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window ... xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:ViewModel2/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;ListView ItemsSource=\u0026#34;{Binding SomeItems}\u0026#34;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Name\u0026#34; DisplayMemberBinding=\u0026#34;{Binding Name}\u0026#34;/\u0026gt; \u0026lt;GridViewColumn Header=\u0026#34;Color\u0026#34;\u0026gt; \u0026lt;GridViewColumn.CellTemplate\u0026gt; \u0026lt;DataTemplate DataType=\u0026#34;local:TypicalItem\u0026#34;\u0026gt; \u0026lt;Button Content=\u0026#34;{Binding Color}\u0026#34; Background=\u0026#34;{Binding Color}\u0026#34;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GridViewColumn.CellTemplate\u0026gt; \u0026lt;/GridViewColumn\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Window\u0026gt; 写这篇博客真的花了不少时间，大家看得开心就好\n","date":"2023-09-18T20:10:22Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006-%E5%85%B3%E4%BA%8Elistview/","title":"WPF学习笔记06-关于ListView"},{"content":"20周岁生日了，挺好的\r","date":"2023-09-16T20:55:27Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E5%9C%B0%E7%90%83online%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF20%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5/","title":"地球online在线时长20周年纪念"},{"content":"前言\r我在半年前已经将我的IPad出手了，所以这里写的体验都是基于半年前的IPadOS16.1\n为什么半年后还写这个呢，主要是想练练手，没怎么写过评测类的文章，顺便分享下我的体验\n\u0026lt;0x01\u0026gt; 为什么选择IPad\r这个小标题看着有些怪哈，但既然说放弃，那肯定有一开始选择的理由的\n好不容易考上了大学，总该为自己添置些设备\n当时的用的电脑还是老笔记本，但性能还够用，就先不换了\n但高中的时候啊，我发觉书和卷子实在是太多了\n平时就是一大堆书和卷子垒在桌子上，找书找卷子非常困难\n所以考上大学我就想买个平板，来做我的移动图书馆\n当时我的选择有IPad系列，小米平板5系列，OPPOPad系列还有就是二手板子\n当时看了好多评测，图稳选择了IPad系列\n因为它软件丰富笔好用，硬件强悍屏准确(IPad数字系列除外)\n\u0026lt;0x02\u0026gt; 错误的选择，为不存在的需求买单\r最开始我只是想买台IPad记笔记\n然后不断的增加可能的需求\n画画，开发，剪视频，修图还有打原神😅\n也没怎么考虑未来真的会不会干这些事情\n反正从原来打算收一台IPadAir5一路升级到买一台全新的IPadPro2022-1T\n还买了支笔(笔二手的，大概五百多)\n现在看来就挺离谱的，实际上我根本没有上述的刚需\n(画画有别的选择，开发用IPad基本没戏，剪视频修图更是不会用IPad，也就打原神了)\n但目前来看，有这样一台性能强劲的IPad，好好用个五六年也还好\n为啥最后放弃使用IPad呢？\n\u0026lt;0x03\u0026gt; IPadOS，使我放弃的根本\r到手后，我也是第一时间开始熟悉IPadOS\n我对IPad还是挺熟悉的，小学的时候用过IPadMini2(拆机尸体还在我架子上)\n激活后没一会儿，差不多就熟悉了\n买了Procrate、Goodnote5，差点也买了LumaFusion(还好没买)\n(但我现在还是吹爆Goodnote5，这是我用过最好用的笔记软件，体验非常好)\n装上苹果的库乐队，玩了好一会\n最后当然是装上原神，体验很流畅，就是掉电比我想象得快\n(原Bench果然名不虚传)\n正式进入了大学，这台IPad也陪伴了我一个学期，我也开始觉得这IPad并不能满足我需求\n正如苹果宣传的一样，\u0026quot;你的下一台电脑，何必是电脑\u0026quot;，我希望IPad能有电脑的能力\n也不是说有多强的性能，能码字，能写代码，满足外出工作需求就够了\n尤其是自从IPad搭载m1以来，一直有传言说IPad会搭载MacOS，我也一直有这不切实际的幻想吧\n(说真的，如果IPad能搭载MacOS，直接绝杀，所有轻薄本都不用混了，可惜不可能)\n于是我发现，在着上面搞开发几乎不可能，而我又是计算机系的学生\n(我知道可以搭CodeServer，但这样不是任何设备都能搞开发吗)\n本来想通过些别的办法解决，比方说UTM虚拟机跑Windows\n(人家开发者真的猛，都搞定了m1的GPU驱动)\n结果呢，发现完美解决要越狱，打开JIT加速才有比较好的性能\n而我手头的IPad本身系统版本就新，我还手贱升级到IPadOS16，莫得退路\n其实不越狱也能跑，就是靠开发者签名跑JIT加速，然后再跑UTM\n这个方法确实能跑，但要么你自己是开发者，要么找别的开发者签名\n前者要苹果开发者年费700，后者感觉不是很稳，所以这条子路基本也寄了\n到目前为止，不能开发就不能开发吧，那就做做生产力吧\n出门干活的话用远程桌面续续命好了，反正我基本不出门\n然后就是我最头疼的问题，苹果的文件管理\n这个倒是购买前我没去思考的问题，都什么年代了，总该有个合理的文件管理吧\n但IPadOS就是没有，那个叫文件的应用并不是给你管理文件的，顶多说让你把IPad当硬盘用\n或者说给不同的软件做中转用的\n比方说编辑个文档，我先要在软件里写好，然后到处到文件里，再传文件，有点麻烦\n(也赖我，不用MacOS)\n而且我常用Windows，和IPad交换文件极其困难\n效率最高的方式居然是拿U盘拷文件过去\n(可以用KDE Connect来传文件，当时不知道这软件有IOS版)\n忍了一学期，最后实在是忍不了一点，最后就放弃IPad了\n基本上不是IPad本身的问题，只能说IPadOS不适合我\nIPadOS很喜欢教用户做事，苹果嘛，老毛病了\n但IPad上的软件也喜欢教用户做事，基本上可设置选项不多，让用户自己适应\n这也算我放弃IPad的一个原因\n\u0026lt;0x04\u0026gt; IPad是个好工具，但它不适合我\r说了这么多，其实我仍然觉得这款IPadPro是一款不错的产品\n优秀的工业设计，顶级的屏幕，强劲的性能，丰富的软件，还有优秀的系统体验\n我是真的很喜欢IPadPro的机身，全铝磨砂机身，摸着很舒适\n屏幕是我见过最好的屏幕，看HDR视频简直就是享受，搭配上四扬声器，看电影很棒\nm1，不必说，移动端数一数二的存在\n\u0026quot;Only Apple can do\u0026quot;的软件生态，几乎所有的创意工作都能在这上面完成(除了开发)\nIPadOS虽然没有能用的文件管理，但整个系统体现的就是灵动，按下就有反馈\n而且说实在的，IPadPro的价格也没有很贵(如果能发挥它的实力的话)\n像画画领域，IPadPro+ApplePencil的价格跟Wacom高端数位屏比，苹果这套就有了性价比\n影视领域，现在有了DavinciForIPad，白天拍，路上就能粗剪，这带来的效率提升是巨大的\n修图的话，用那些软件，差不多拍完回去的路上就能完成调色，非常优雅(这个也不一定要Pro的)\n搞音乐更不用说，库乐队已经很强大了，现在还有LogicForIPad，更强大\n而且貌似IPad上还有些碟机软件，接上碟机就能用，比macbook更轻便\n举这些例子也不是说鼓励大家买IPad，我也只是挑IPad的专长讲，具体我也不是很熟\n真搞生产力，IPad的弱势也有，比方说程序开发\n虽然说有在搞XcodeForIPad，但也不用抱太大希望，这个要看你的开发贴不贴近苹果生态\n(总不能指望这玩意能编译C#之类吧)\n搞CodeServer的方案我总是感觉很野鸡，毕竟这样的话啥设备不能开发啊\n还有就是，我原以为，IPad是最脱离苹果生态的产品，哪怕没有一个苹果的产品也能用得好\n但我现在觉得最脱离苹果生态的产品还得是macbook，IPad更像是macbook的附属品\n我有个室友，他的日用电脑就是macbook，在我的IPad出手前借给他用了几天\n他整体体验下来感觉非常妙，随航，隔空投递，接力真的很舒服\n尤其是随航，它可以让IPad成为macbook的副屏，我们不清楚苹果是这么实现的，这玩意延迟巨低\n所以，IPad好吗，它真的很好，但它不适合我\n(所以我现在换成了Samsung的TabS7😋)\n","date":"2023-09-06T15:21:11Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E4%BD%BF%E7%94%A8ipad/","title":"我为什么放弃使用IPad"},{"content":"\u0026lt;0x00\u0026gt; 介绍下ModernWPF\r这个其实是个Nuget包，里面有很多现代化设计的WPF组件\n不是之前说嘛，在WPF里面做现代化的UI设计很复杂\n现在差不多就是别人已经把最复杂的实现写完了，我们只要调用就好了\n这个包的实现风格是UWP风格(也就是WinUI2)\n里面的很多用法是参考UWP的(我具体用下来就是UWP的api级复刻)\n所以有些组件的用法跟WPF的常见实现不一样(就比如这里讲的导航界面)\n安装的话用VS的Nuget包管理器就可以\n(Nuget上有很多包叫ModernWPF，我用的是这个，别的实现我就不清楚了，最好一样吧)\nGithub项目主页\n在Github上也有这个项目的Wiki，所有组件的使用都有列举一点\n因为差不多是完全复刻UWP的，所以有些样例会直接跳转到微软的文档\n照样看就是了，代码实现是差不多的(跳转的文档是英文的，最好就直接看英文，这样最准确)\n\u0026lt;0x01\u0026gt; 如果是一般的WPF项目，我们该怎么实现导航\r还是先稍微讲讲一般的WPF项目里怎么实现导航\n假设我们有MainWindow.xaml，PageViewModel.cs，SomePage.xaml\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;window ...\u0026gt; \u0026lt;window.DataContent\u0026gt; \u0026lt;local:PageViewModel/\u0026gt; \u0026lt;/Window.DataContent\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;!--第一列放导航的按钮--\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;!--若干按钮，具体就不设计了--\u0026gt; \u0026lt;Button Command=\u0026#34;{Binding NavigateToPage}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;!--内容展示的页面--\u0026gt; \u0026lt;UserControl Grid.Column=\u0026#34;1\u0026#34; Content=\u0026#34;{Binding CurrentPage}\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/window\u0026gt; //PageViewModel.cs //常见的引用 namespace TestProject.ViewModel { internal partial class PageViewModel:ObservableObject { [ObservableProperty] public object? currentPage; public ICommand NavigateToPage{get;set;} public PageViewModel() { CurrentPage=new SomePage(); NavigateToPage=new RelayCommand(()=\u0026gt;CurrentPage=new SomePage()); } } } (这里的一些没见过的东西是在Community.MVVM包里面的，上一篇结尾有介绍)\n\u0026lt;!--SomePage.xaml--\u0026gt; \u0026lt;UserControl ...\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Emmm\u0026#34; Foreground=\u0026#34;White\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; FontSize=\u0026#34;32\u0026#34;/\u0026gt; \u0026lt;/UserControl\u0026gt; 这里通过UseControl控件来存放我们自己写的SomePage\n导航栏的每个按钮会绑定一个Command，来控制UserControl的Content\n因为这个Content就存放具体的页面嘛，所以只要改这个Content就相当于切换页面了\n之后有什么多的页面就是先新建一个UserControl控件并完成设计\n然后再在PageViewModel.cs里面实现切换代码(就是写一行改CurrentPage的代码)\n最后在MainWindow.xaml里面为对应按钮绑定Command就好\n其实最好是在PageViewModel里用一个object数组存储不同的page，我这里就偷懒了\n还有就是导航栏我也没咋设计，基本上就是用Triger配合Setter做就可以了，这里也摸了\n\u0026lt;0x02\u0026gt; 用ModernWPF里面的NavigationView实现导航\r(虽然是介绍怎么在ModernWPF里面实现导航，因为用法极像UWP，也算介绍UWP的开发了)\n在ModernWPF中用NavigationView做导航就没有类似按钮绑定Command的用法了\n准确来说，用ModernWPF甚至都不需要写一个对应的VM\n那么怎么切换页面呢\n差不多就是靠.xaml附带的.cs里面实现了\n先上代码\n(ModernWPF有使用前的一些步骤，在它的readme有写，就两步，我就不介绍了)\n\u0026lt;!--ModernUITest.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;TestProject.ModernUITest\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:ui=\u0026#34;http://schemas.modernwpf.com/2019\u0026#34; xmlns:local=\u0026#34;clr-namespace:TestProject\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; ui:WindowHelper.UseModernWindowStyle=\u0026#34;True\u0026#34; Title=\u0026#34;ModernUITest\u0026#34; Height=\u0026#34;800\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;ui:NavigationView IsBackButtonVisible=\u0026#34;Collapsed\u0026#34; IsTitleBarAutoPaddingEnabled=\u0026#34;False\u0026#34; PaneTitle=\u0026#34;Test\u0026#34; PaneDisplayMode=\u0026#34;Auto\u0026#34; ItemInvoked=\u0026#34;NavigationView_ItemInvoked\u0026#34;\u0026gt; \u0026lt;ui:NavigationView.MenuItems\u0026gt; \u0026lt;ui:NavigationViewItem Icon=\u0026#34;Home\u0026#34; Tag=\u0026#34;TestProject.Page.PageTest1\u0026#34; Content=\u0026#34;Sample Item 1\u0026#34; IsSelected=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;ui:NavigationViewItem Icon=\u0026#34;Keyboard\u0026#34; Content=\u0026#34;Sample Item 2\u0026#34; Tag=\u0026#34;TestProject.Page.PageTest2\u0026#34;/\u0026gt; \u0026lt;/ui:NavigationView.MenuItems\u0026gt; \u0026lt;UserControl Name=\u0026#34;UC\u0026#34;/\u0026gt; \u0026lt;/ui:NavigationView\u0026gt; \u0026lt;/Window\u0026gt; //ModernUITest.xaml.cs //常见的引用 namespace TestProject { public partial class ModernUITest : Window { public ModernUITest() { InitializeComponent(); UC.Content = new PageTest1();//给一个默认的页面 } private void NavigationView_ItemInvoked(ModernWpf.Controls.NavigationView sender, ModernWpf.Controls.NavigationViewItemInvokedEventArgs args) { if(args.IsSettingsInvoked==true) { NavigationView_Navigate(typeof(int), args.RecommendedNavigationTransitionInfo); //我这里没写Setting的page，所以就随便写了typeof(int) } else if(args.InvokedItemContainer!=null) { NavigationView_Navigate(Type.GetType(args.InvokedItemContainer.Tag.ToString()), args.RecommendedNavigationTransitionInfo); } } private void NavigationView_Navigate(Type navPageType, NavigationTransitionInfo transitionInfo) { Type preNavPageType = UC.Content.GetType(); if(navPageType is not null \u0026amp;\u0026amp; !Type.Equals(navPageType, preNavPageType)) { if(navPageType==typeof(PageTest1)) { UC.Content = new PageTest1(); } if (navPageType == typeof(PageTest2)) { UC.Content = new PageTest2(); } } } } } (PageTest1和PageTest2的代码就不贴了，就纯纯的一行字)\n先讲下包里的东西\rui:WindowHelper.UseModernWindowStyle=true表示使用ModernWPF的窗口样式\nwindow控件下面只有ui:NavigationView\n先在ui:NavigationView里面设置ui:NavigationView.MenuItems\n再在里面设置ui:NavigationViewItem，要几个就设置几个\nui:NavigationView下面有个UserControl，这个就是我们要切换的页面\nui:NavigationView里面有些属性\nIsBackButtonVisible=\u0026quot;Collapsed\u0026quot;是关闭默认的返回按钮\nIsTitleBarAutoPaddingEnabled=\u0026quot;False\u0026quot;是关闭顶栏的自动排布\nPaneTitle=\u0026quot;Test\u0026quot;就是会显示在最上面的那行字，展开时会显示\nPaneDisplayMode=\u0026quot;Auto\u0026quot;这里显示了自动展开，就是最大化窗口时会自动展开\nItemInvoked=\u0026quot;NavigationView_ItemInvoked\u0026quot;这个是实现导航最关键的部分，后面讲\nui:NavigationViewItem里别的应该都能看懂\n就是Tag这个是最关键的，规范的话里面要填上要导航页面对应的类型全名\n就是对应页面的namespace.类名，因为按规范导航会用到Type来判断\n(估计是因为微软文档写的是用Frame实现页面导航)\n.xaml里要干的事\r在ui:NavigationView里写上ItemInvoked=\u0026quot;NavigationView_ItemInvoked\u0026quot;，名字随意\n在ui:NavigationViewItem里正确写上Tag\n给UserControl起个名，好让我们在.cs拿到对象\n剩下的事就交给.cs了\n.cs里要干的事\r按上面的样式写就可以了\n大致的调用过程\r在NavigationView里面切换页面会触发ItemInvoked绑定的事件\n在ItemInvoked绑定的方法中，先判定是不是要切换到Setting的页面\n(args.IsSettingsInvoked==true) (因为这里的NavigationView没有设置IsSettingsVisible=\u0026quot;False\u0026quot;)\n然后判定args.InvokedItemContainer!=null\n这两条路径都会调用导航方法NavigationView_Navigate\n这个导航方法会要求传入一个Type和一个NavigationTransitionInfo\n(NavigationTransitionInfo在这里确实没啥用)\n这个Type用来判断具体要切换到哪个页面\n其实Tag随便写也没啥问题，主要看写的导航方法是什么\n这里我写的代码极致精简的话完全可以初始化一个Dictionary\u0026lt;string,object\u0026gt;\n然后直接在ItemInvoked绑定的方法中切换就可以了\n像这样\nnamespace TestProject { public partial class ModernUITest : Window { Dictionary\u0026lt;string, object\u0026gt; pages; public ModernUITest() { InitializeComponent(); pages = new Dictionary\u0026lt;string, object\u0026gt; { {\u0026#34;Page1\u0026#34;,new PageTest1()}, {\u0026#34;Page2\u0026#34;,new PageTest2()}, {\u0026#34;Setting\u0026#34;,new SettingPage()}, }; UC.Content = pages[\u0026#34;Page1\u0026#34;]; } private void NavigationView_ItemInvoked(ModernWpf.Controls.NavigationView sender, ModernWpf.Controls.NavigationViewItemInvokedEventArgs args) { if (args.IsSettingsInvoked == true) { UC.Content = pages[\u0026#34;Setting\u0026#34;]; } else if (args.InvokedItemContainer != null) { UC.Content = pages[args.InvokedItemContainer.Tag.ToString()]; } } } } 对应的Tag再改改就好\n\u0026lt;0x03\u0026gt; 两种做法的区别\r我个人来看的话，按第一种实现会更加优雅\n毕竟前端只要有按钮绑定Command就好了\n但这么做的话就是控件要自己开发了(也确实不是大问题，主要是WPF现在只有维护了)\n第二种方式相对来说没那么优雅，但真正做到了前端的事前端干\n按照MVVM的理论，VM是用来连接前后端的\n但第一种方法我们仅仅是为了前端切换页面就写了个PageViewModel实现\n某种程度上确实不大符合MVVM的定义\n(我知道有别的方式可以不单独写VM，但别的方式确实没单独写VM直观)\n而第二种方法把前端的事情聚合在一起，那些新的页面都是在前端new出来的\n有啥好处呢，主要还是方便管理吧，功能更加聚合了\n","date":"2023-08-30T13:28:48Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-%E6%80%8E%E4%B9%88%E7%94%A8modernwpf%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%AF%BC%E8%88%AA%E7%9A%84%E7%95%8C%E9%9D%A2/","title":"WPF学习笔记05-怎么用ModernWPF实现带导航的界面"},{"content":"\u0026lt;0x00\u0026gt; 相对更正规的MVVM的写法\r前一篇文章不是讲MVVM模型嘛，然后这几天看了看别人写的代码\n确实有很多值得学习的地方\n单独拆个BaseViewModel出来\r之前讲到ViewModel要实现接口INotifyPropertyChanged来通知前端属性更改\n基本上所有的VM都要用到的，所以最好就是有个BaseViewModel类，给所有的VM继承\n具体代码如下\nnamespace WPFTest.VM { public class BaseViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; internal void NotifyPropertyChanged(string propertyName) { PropertyChangedEventHandler handler = PropertyChanged; if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName)); } } } 其实就是把那些代码单独拆出来了\n然后所有的VM继承这个类就好了\n之前也讲到RelayCommand类也是经常用到的工具类\n所以一般这两个类的文件会放在同一个文件夹下\n这里的命名空间也进行了规范(我这里为了简单就只写缩写了)\n反正就是M/V/VM分三块地就行了\n具体还是按着规范怎么舒服怎么来\n另一种更舒适的方式添加DataContext\r之前在前端引入VM的上下文是靠对应.cs文件里加this.DataContext=this;实现\n现在有相对舒适的做法\n首先要在.xaml的xmlns中引入命名空间\n然后加入具体控件的DataContext\n具体要添加的代码如下\n\u0026lt;Window ... xmlns:vm=\u0026#34;clr-namespace:WPFTest.VM\u0026#34; ...\u0026gt; ... \u0026lt;Window.DataContext\u0026gt; \u0026lt;vm:ViewModel/\u0026gt; \u0026lt;/Window.DataContext\u0026gt; ... \u0026lt;/Window\u0026gt; 这里的vm可以随便改的，ViewModel是具体的VM\n这样写的话就尽可能避开对应的.cs，尽可能把前端实现交给.xaml\n\u0026lt;0x01\u0026gt; 关于窗口透明化\r之前是在Window标签里设置AllowTransparency=True和Background=\u0026quot;Transparent\u0026quot;来实现\n但这样实现的窗口性能会受很大影响(相关分析可以看大佬lindexi的博客)\n简单来说就是这样写会相对频繁的申请内存，让CPU和内存的负荷加大\n所以怎么办呢，我们也可以通过WindowChrome实现\n更多的信息可以看大佬walterlv的博客\n还有大佬丑萌气质狗的博客\n我这里就接着我的代码改改了\n具体修改的代码如下\n\u0026lt;!--前一个是隐藏window默认控件的，后一个是仅允许最小化的意思--\u0026gt; \u0026lt;!--具体也不清楚为啥，后一个必须是CanMinimize或NoResize才有透明--\u0026gt; \u0026lt;Window ... WindowStyle=\u0026#34;None\u0026#34; ResizeMode=\u0026#34;CanMinimize\u0026#34; ...\u0026gt; \u0026lt;!--修改WindowChrome--\u0026gt; \u0026lt;WindowChrome.WindowChrome\u0026gt; \u0026lt;WindowChrome GlassFrameThickness=\u0026#34;-1\u0026#34;/\u0026gt; \u0026lt;/WindowChrome.WindowChrome\u0026gt; \u0026lt;!--别的代码--\u0026gt; \u0026lt;!--在Template里设置背景透明，一定别忘加ContentPresenter--\u0026gt; \u0026lt;Window.Template\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Window\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;Transparent\u0026#34;\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; Margin=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;ContentPresenter ClipToBounds=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Window.Template\u0026gt; \u0026lt;!--别的控件--\u0026gt; \u0026lt;/Window\u0026gt; 还有我们原来负责最小化和关闭程序的两个按钮要加上WindowChrome.IsHitTestVisibleInChrome=\u0026quot;True\u0026quot;\n这个原理在丑萌气质狗的博客里有讲\n(其实建议不搞异型窗口，容易出很多莫名其妙的问题)\n\u0026lt;0x02\u0026gt; 一些常用的Nuget包\rWPF的强大还体现在有很多Nuget包\n这些包大多是些UI组件，使WPF也可以方便的实现现代化的UI\n我自己在研究的有ModernWPF和FluentWPF\nMordernWPF提供了些现代化的窗口和组件\nFluentWPF实现了Fluent设计的UI，看着好看很多\n这两个用得应该还算广吧(我在很多的WPF项目里看到有用的)\n性能方面还没怎么试(没研究明白)\n还有一个不是专门给WPF用的，而是方便MVVM设计的\n叫CommunityToolkit.Mvvm，很好用的\n平时我们写MVVM模式总是要像最上面一样写一个BaseViewModel还有一个RelayCommand\n这些常用的基础类已经在这个包里写好了\n尤其是这玩意8.0版本加入了源代码生成器的特性，现在写属性和前端通知就很方便\n具体可以看B站up-十月的寒流的视频\n(人家是真大佬，他的视频做的都很不错的)\n(所以我的博客就摸了😋)\n","date":"2023-08-23T00:49:54Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-mvvm%E5%92%8C%E5%88%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%A1%A5%E5%85%85/","title":"WPF学习笔记04-MVVM和别的一些东西的补充"},{"content":"\u0026lt;0x00\u0026gt; 经典在前面写点啥\r很早就想去这种大型的THO活动了\n刚上大学的时候本来是想能赶上浙江的THO\n结果呢，刚好跟我们第一次期中考撞上了\n这期中考呢，还有点重要，跟分班有关系\n所以就没敢去浙T\n(顺带一提，23年浙T在10.28，我必有时间去)\n所以嘛，在B站上刚看到上海THO，一下子就买了票\n好嘛，总算是能开开眼见识下国内东方众的热情了\n本来还想看看今年的幻奏的，但看了看时间，看了看上海的住宿价格，就没去(挺可惜的)\n于是就守着火车最早的发售点买了票\n住宿就在学校寝室了，极致省钱\n最有意思的是我以为我们校车万群友也会去不少，所以我也没在群里说\n结果在开展会前两天问了两圈，没个群友去\n哇，那怕不是我一个人在展会晃悠\n我老社恐了，但还是想，票都买了，还是去吧\n\u0026lt;0x01\u0026gt; 大概讲下看展的一天(流水账警告)\r我先是从学校寝室出发赶到杭州站\n最离谱的是出发前一个晚上我给手机充电，然后不知怎么晚上停电了(晚上热得睡不着)\n总共就睡了3小时不到，然后带着63%电量的手机出门\n好在说坐上列车有插头，但快充头会掉，所以就只能用边上的USB口充，好歹能充吧\n一路上充到85%，算是能熬过一天了\n下了列车，看到有人cos小玲，我就直接跟他们去了😂\n不过有一说一啊，上海15号线的指引确实比较神秘，其实出南站往一号口进去就可以了\n但上面的标志没换，我问了下老同学，他说这条线比较新，可能指引还没跟上\n一路上我社恐嘛，不敢搭话\n到红宝石路后，很明显有一群人往某个方向走，那这也很明显是去上T的嘛\n路上呢，碰见俩人貌似有点找不到路，我就鼓起勇气去搭了下话(所以有时我也在想我到底是不是社恐)\n一聊起来就马上熟悉起来了\n排队入场的时候就一直聊，他们是上海当地的，还在上高中\n甚至他们还有个同学就在场子里设摊买专辑，叫Talkie Dance，真挺厉害的\n人是真的多，当然人多才热闹\n为了倒时候能先吃饭，在他们俩拜访完他们同学后我们就在场馆内的麦那里排队了\n那边是先订餐，然后会给一张凭证，到时候来取\n(来吃麦主要是为了那个挂件)\n麦的边上是红魔馆补给站，卖些蛋糕面包，价格也挺好的\n总之我们十点入场，然后排队到十二点才吃完饭\n吃完饭后，我们仨打算先去预约园神，然后就跑到那个摊\n一扫码，哇，人是真的太多了，根本扫不出来，我们就说之后再来吧\n那干啥呢？之前就光顾着吃饭了，还没完整逛过整个场馆\n场馆说大不大，说小不小，但容纳600越共还是略显拥挤了\n那也得挤着逛啊，我们从游戏区开始，绕S型路线，逛到主舞台\n(顺便说下，一路上也看到很多抽象玩意)\n(比方说距离阿求诞辰30周年还有约354天之类的，很乐)\n好，总体有个概念了\n再按S型路线绕一圈，一路上我们仨各自爆了点米\n我入了套三月精和kk做的扑克，他们也入了点东西\n到了大概一点左右，槐南茶馆的相声节目就快开始了，我们也就赶到主舞台，找块地儿先坐\n槐南茶馆的人气确实旺啊，还没正式开始呢，舞台前就坐了一大圈人\n到了正式开始的时候，那熟悉的仨人上台了\n一开口，氦，就是个地道(手动单臂大回旋)\n具体可以看看B站的视频\n好久没有这么过瘾地听一场相声了，在这感谢槐南茶馆的付出\n(真看几次笑几次，真的就是人们喜欢的艺术啊)\n看完后啊，我的口音也给他们同步了😝\n那看完相声也下午两点了，距离展会结束还有3小时\n那咋整啊，接着逛嘛\n基本上就是绕着摊转了一圈又一圈，我们仨呢也爆了几轮米\n买了各种奇怪的东西，可谓收获颇丰\n最重要的是我们终于预约上了园神，哇，太好了\n(工作人员也跟着我们激动😄)\n最后啊，逛到下午四点，真的逛不动了(那时候已经走了一万六千步了)\n(本来还想去雾雨咖啡店打个卡，但真走不动路了)\n那就回去了，我们仨告别，各回各家\n但问题是我的高铁票是晚上七点的，也行，就在火车站歇下脚了\n上了高铁，发现后面就坐俩上T回来的人，寒暄了两句\n到了杭州，坐地铁，回寝室，睡觉\n\u0026lt;0x02\u0026gt; 一些感想\r看得出来还是有不少人热爱着这个圈子，新人老人都有\n说实在的，我其实对二次元相关的了解不深\n看过的番剧屈指可数，反正就是个臭打游戏而且也没打多好的人\n但我入东方的圈子少说也有四五年了，是什么让我能一直待在这个圈子呢\n我觉得是整个氛围\n整个东方的世界观并不是由某个主题创造的，而是由大家共同创建的\n这就很好啊，感觉就跟开源的魅力一样，大家都可以有所作为\n整个圈子为大家搭建了一个舞台，谁都可以表演自己的一技之长\n这个圈子真挺不错的，也难怪整个圈子活了近20年了\n虽然圈子大了也啥人都有，但这么多年了，也算是啥风雨都经历过了吧\n热爱真的可以激发人的斗志\n像我找的那俩上海本地人的那个设摊的同学，我是真的佩服\n当然更多的也是羡慕，才高中就有些建树\n我从小也一直想干点啥，小学开始就想自己做一款游戏\n于是小学开始接触了一点点的RPG Maker\n(那时候还是用Ruby做脚本语言)\n当然，也没学进去多少\n初中在看Java，高中没时间，也只能折腾折腾计算器了\n当然，我现在也还是想着自己做一款游戏\n但相比那些年纪青青就有这么多成就的人总感觉我这个年纪能干成是应该的\n氦，或许跟教育也有关系吧，我是小县城出来的人，大家都是传统的人\n父辈还是希望我走一条传统的路，向上爬吧\n所以现在我也慢慢地承认各种平庸\n包括我自己的平庸，家庭的平庸，小县城的平庸\n(我也不是说我家庭不够好，小县城不够好之类的，仅仅是一些观念上)\n那些年纪青青有所建树的人不仅仅是他们自己很有想法\n而且他们身边的人也会帮助他们实现理想\n(貌似讲得太偏了)\n总之，这次上海THO的行程真的很不错，也算我难得会记忆的一天\n(我一般记性很差的)\n以后有THO我估计也会常去，人还是喜欢热闹点的地方\n","date":"2023-08-21T11:05:18Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E4%B8%8At%E7%9C%9F%E7%9A%84%E5%A4%AA%E5%A5%BD%E4%BA%86/","title":"上T真的太好了"},{"content":"前言\r突发奇想，想研究下IL语言\n本来以为会挺难的，结果发现貌似还行\n注意：本博客不打算详细讲解IL的原理之类的\n只是大概讲讲我研究的成果\n这里推荐两篇博客，他们那讲的更详细\n一个是来自Zery的IL指令详细\n另一个是布鲁克石的30分钟？不需要，轻松读懂IL\n\u0026lt;0x01\u0026gt; 什么是IL语言\r这就要从.net的运行结构开始讲起\n.net框架下面有好多们语言，但.net的运行时就一个\n所以这个运行时怎么能同时跑这么多的语言，是每个语言一个实现吗？\n肯定不是，这太麻烦了\n所以.net编译器会将它托管的语言先编译成一个中间语言，这个中间语言就是IL\n.net运行时会动态解释这个IL文件(这个跟Java差不多的流程)\n通过IL语言，.net实现了多语言共用一个运行时，也让不同语言能非常方便地整合进一个项目\n(反正编译出来的东西都是一样的)\n这个具体的过程可以看本叫《CLR via C#》(俗称C#圣经😂，最近在看)\n里面讲到过\n\u0026lt;0x02\u0026gt; 怎么查看IL语言\r第一种方法，ILDasm\nVisual Studio自带的反汇编软件(但我没找到)\n参考微软的文档就好\n第二种方法，sharplab.io\n这是个给C#用的实时转换成IL的网页工具\n这个还可以转换成编译器优化后的代码甚至是给CLR执行的汇编代码\n在线执行也是可以的，而且它可以列出所写代码的所有语法点并列出微软的说明文档链接\n不过毕竟是网页工具，并不完全支持所有的FCL库，所以可能有些库用不了\n总之这是个非常方便的工具，有什么小测试都可以在上面测试\n第三种方法，ILSpy\n这个工具也挺好用的，有支持Visual Studio的插件\n装上就可以写代码的时候直接反编译\n(@ 23-08-22)\n只是看核心库源代码的话还有一种办法，官方的源代码网站\n具体我没怎么用过，就先补充在这里吧\n我现在在用第二种和第三种方法\n平时做小测试网页工具用用就好了\n但在研究.net的底层api的时候就需要用ILSpy了\n(虽然.net core开源了，但自己找效率确实低，反编译哪里不会点哪里)\n\u0026lt;0x03\u0026gt; C#的编译过程\rC#编译到IL分两步\n第一步：编译器优化代码\n第二步：编译成IL\n在第一步中，编译器将对原代码进行彻头彻尾的改造\n比方说代码有一句int a = 5;，在优化过程中会改名为int num = 5;\n还有就是将一些编译期就知道结果的值计算出来，比如\u0026quot;a\u0026quot;+\u0026quot;b\u0026quot;就会直接优化成\u0026quot;ab\u0026quot; 在这个过程中，编译器还会加上非常多的，用于跟CLR通信的指令\n这些指令主要是指导CLR正确执行代码，具体我也不是很熟，以后再说\n第二步编译成IL就看靠编译器了\n这两步具体实现可以看Roslyn的源码，在GitHub上\n(我还没开始研究这玩意)\n另外还有就是C#编译有两种模式\nDebug和Release\n前者编译出的代码并不是最优化的，里面会有很多的nop指令\n(就是执行这条指令啥也不干，方便调试打断点用的)\n后者是用来发布的，编译出来的代码是经过编译器完全优化的\n\u0026lt;0x04\u0026gt; 开始研究IL\r首先先是一段简单的代码\nusing System; public class C { public void M() { int a=3; string str=\u0026#34;abc\u0026#34;; Console.WriteLine(a+str); } } 看看它编译后的IL语言(Debug下编译)\n.assembly _ { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) .custom instance void [System.Runtime]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4e 6f 6e 45 78 63 65 70 74 69 6f 6e 54 68 72 6f 77 73 01 ) .custom instance void [System.Runtime]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [System.Runtime]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) .permissionset reqmin = ( 2e 01 80 8a 53 79 73 74 65 6d 2e 53 65 63 75 72 69 74 79 2e 50 65 72 6d 69 73 73 69 6f 6e 73 2e 53 65 63 75 72 69 74 79 50 65 72 6d 69 73 73 69 6f 6e 41 74 74 72 69 62 75 74 65 2c 20 53 79 73 74 65 6d 2e 52 75 6e 74 69 6d 65 2c 20 56 65 72 73 69 6f 6e 3d 37 2e 30 2e 30 2e 30 2c 20 43 75 6c 74 75 72 65 3d 6e 65 75 74 72 61 6c 2c 20 50 75 62 6c 69 63 4b 65 79 54 6f 6b 65 6e 3d 62 30 33 66 35 66 37 66 31 31 64 35 30 61 33 61 15 01 54 02 10 53 6b 69 70 56 65 72 69 66 69 63 61 74 69 6f 6e 01 ) .hash algorithm 0x00008004 // SHA1 .ver 0:0:0:0 } .class private auto ansi \u0026#39;\u0026lt;Module\u0026gt;\u0026#39; { } // end of class \u0026lt;Module\u0026gt; .class public auto ansi beforefieldinit C extends [System.Runtime]System.Object { // Methods .method public hidebysig instance void M () cil managed { // Method begins at RVA 0x206c // Code size 29 (0x1d) .maxstack 2 .locals init ( [0] int32 a, [1] string str ) IL_0000: nop IL_0001: ldc.i4.3 IL_0002: stloc.0 IL_0003: ldstr \u0026#34;abc\u0026#34; IL_0008: stloc.1 IL_0009: ldloca.s 0 IL_000b: call instance string [System.Runtime]System.Int32::ToString() IL_0010: ldloc.1 IL_0011: call string [System.Runtime]System.String::Concat(string, string) IL_0016: call void [System.Console]System.Console::WriteLine(string) IL_001b: nop IL_001c: ret } // end of method C::M .method public hidebysig specialname rtspecialname instance void .ctor () cil managed { // Method begins at RVA 0x2095 // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Object::.ctor() IL_0006: nop IL_0007: ret } // end of method C::.ctor } // end of class C .class private auto ansi sealed beforefieldinit Microsoft.CodeAnalysis.EmbeddedAttribute extends [System.Runtime]System.Attribute { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void Microsoft.CodeAnalysis.EmbeddedAttribute::.ctor() = ( 01 00 00 00 ) // Methods .method public hidebysig specialname rtspecialname instance void .ctor () cil managed { // Method begins at RVA 0x2050 // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Attribute::.ctor() IL_0006: nop IL_0007: ret } // end of method EmbeddedAttribute::.ctor } // end of class Microsoft.CodeAnalysis.EmbeddedAttribute .class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.RefSafetyRulesAttribute extends [System.Runtime]System.Attribute { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void Microsoft.CodeAnalysis.EmbeddedAttribute::.ctor() = ( 01 00 00 00 ) .custom instance void [System.Runtime]System.AttributeUsageAttribute::.ctor(valuetype [System.Runtime]System.AttributeTargets) = ( 01 00 02 00 00 00 02 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00 54 02 09 49 6e 68 65 72 69 74 65 64 00 ) // Fields .field public initonly int32 Version // Methods .method public hidebysig specialname rtspecialname instance void .ctor ( int32 \u0026#39;\u0026#39; ) cil managed { // Method begins at RVA 0x2059 // Code size 15 (0xf) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [System.Runtime]System.Attribute::.ctor() IL_0006: nop IL_0007: ldarg.0 IL_0008: ldarg.1 IL_0009: stfld int32 System.Runtime.CompilerServices.RefSafetyRulesAttribute::Version IL_000e: ret } // end of method RefSafetyRulesAttribute::.ctor } // end of class System.Runtime.CompilerServices.RefSafetyRulesAttribute (注释是Sharpio自动生成的)\n额，看着是有点多，但其实很多只是自动生成的代码\n如果只关注我们自己方法实现的话，实际只要看这么点就好\n.method public hidebysig instance void M () cil managed //方法签名 { .maxstack 2 //定义计算栈大小 .locals init ( [0] int32 a, [1] string str ) //初始化变量链表 IL_0000: nop //啥也不干(Debug下编译) IL_0001: ldc.i4.3 //初始化int32的数值3，并加载到计算栈上 IL_0002: stloc.0 //弹出一个栈顶元素，并存储到变量列表的0号位上(就是变量a) IL_0003: ldstr \u0026#34;abc\u0026#34; //初始化字符串\u0026#34;abc\u0026#34;，并加载到计算栈上 IL_0008: stloc.1 //弹出栈顶元素，存储到变量链表1号上(变量str) IL_0009: ldloca.s 0 //加载变量列表0号位(变量a)到计算栈上 IL_000b: call instance string [System.Runtime]System.Int32::ToString() //调用方法 IL_0010: ldloc.1 //加载变量列表1号位(变量str)到计算栈上 IL_0011: call string [System.Runtime]System.String::Concat(string, string) //调用方法，有几个参就弹出几个栈顶元素，返回值再压入栈 IL_0016: call void [System.Console]System.Console::WriteLine(string) //调用方法 IL_001b: nop //啥也不干 IL_001c: ret //方法结束，返回 } (已经打上了我自己的注释了)\n所以其实也不是挺难的，就是IL的指令差不多都是简写，乍一看确实不明觉厉\n(所以会看IL就可以出去装逼了😅) IL还有很多指令，具体可以看我最上面推荐的两篇博客\n这里的计算栈其实就是个可以放任何类型的栈，计算用的\n具体的CLR执行细节可以看看《CLR via C#》讲的很详细\n","date":"2023-08-03T02:44:36Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E6%B5%85%E8%B0%88csharp%E8%BD%ACil%E8%AF%AD%E8%A8%80/","title":"浅谈C#转IL语言"},{"content":"\u0026lt;0x00\u0026gt; MVVM模型介绍\rMVVM模型并不是一个编程的语法，而是一种设计思路\n整体分三块(M/V/VM)\nM(Model)指数据模型，差不多就是程序的后端部分\nV(View)指界面，就是程序前端\nVM(View Model)，这个不大好翻译，其实就是负责前后端连接\n这样做有什么好处\n简单说就是低耦合高内聚(网上都这么说的)\n换句话说就是修改时更加的灵活，架构更加明白\nMVVM模型是从MVC模型发展过来的，主要解决的就是开发过程中代码结构混乱的问题\n比方说开发一个项目，分前端后端，如果不采用这些设计思路，很可能两人各搞各的\n要连接前后端，既可以是前端控制后端数据，也可以是后端修改前端显示\n这样势必会造成整个项目的混乱，不好管理\n所以MVVM模型引入了VM作为前后端的中间层\n前端的V可以通过VM修改M，后端的M也可以通过VM通知前端的V要界面更新\n这样的话，前后端本身就差不多分离了，前后端开发互不干扰\n反正最后都是靠写一个VM连接在一起的，当然相应的代码量就多了\n总之，MVVM模型不是开发必须的，如果就一个人随便写写，那么肯定是怎么舒服怎么来的\n如果是稍微大一点的项目，不采用合适的开发模式，到时候管理代码有的受的\n\u0026lt;0x01\u0026gt; 如何在WPF中实现MVVM\rWPF里面不是有些.xaml的文件嘛，这些就是我们的V\n然后在整个工程中，我们还可以新建很多的.cs文件(这个看你用什么.net的语言)\n这些.cs文件就是我们的M和VM\n当然，为了区分方便，通常会在文件后面跟上后缀\n比如*M.cs代表这个文件描述的是一个数据模型\n*VM.cs代表这个文件描述的是一个VM\n反正怎么习惯怎么来就是\n在这篇博客里，我的文件命名没有这么这么规范\n因为就像之前说的，MVVM只是一种设计思路\n\u0026lt;0x02\u0026gt; 正式开始实现\r首先先分析我们的需求，就拿我们之前的计算器吧\n前端的实现我们已经有了，就是那个.xaml文件\n后端我们就要先分析下了，怎么搞一个计算器的后端\n首先我们先思考下一个计算器需要维护什么数据\n因为我们打算实现的就是个日常的计算器而不是图形计算器之类的东西\n所以肯定要维护一条当前的结果\n然后还要一个标志符来保存当前选定的运算\n同时还要有个flag来表明正在计算\n最后还要维护一个显示的值\n所以总共是要维护4条数据\n所以对我们的计算器后端文件如下\n//Calculator.cs //常见的引用 namespace WPFTest { public class Calculator { //这里按道理应该用private，通过对象方法调用这些变量，这里偷下懒 internal bool flag = false; //表示正在计算 internal int? calculate = null; //标识当前的运算符 internal double? ans = null; //存储当前的结果 internal string Display = \u0026#34;0\u0026#34;; //当前显示的值 public void Calculate() //计算方法 { switch (calculate) { case 1: ans += Double.Parse(Display); break; case 2: ans -= Double.Parse(Display); break; case 3: ans *= Double.Parse(Display); break; case 4: ans /= Double.Parse(Display); break; } } } } 接下来就是来写我们的VM部分\n我这个写得比较繁琐，但就是那个意思\n//ViewModel.cs //常见的引用 namespace WPFTest { //要实现接口INotifyPropertyChanged public class ViewModel : INotifyPropertyChanged { //实现接口的要求，看不懂没关系，这么写就好 public event PropertyChangedEventHandler PropertyChanged; private void NotifyPropertyChanged(string propertyName) { PropertyChangedEventHandler handler = PropertyChanged; if(handler != null) handler(this, new PropertyChangedEventArgs(propertyName)); } //声明一个Calculator对象 private readonly Calculator _calculator = new Calculator(); //声明一个Display属性，关键啊 public string Display { get { return _calculator.Display; //定义get，挺正常的写法 } set { _calculator.Display = value; NotifyPropertyChanged(\u0026#34;Display\u0026#34;); //定义set，最后调用的方法通知属性已更改，让前端更新显示 } } public void MinusSign_Click() //减法的实现 { if (_calculator.flag) { if (Display[0] == \u0026#39;-\u0026#39;) { Display = Display.Substring(1, Display.Length - 1); } else { Display = \u0026#34;-\u0026#34; + Display; } } } //后面方法的实现略 public ICommand ButtonMinusSign //将减法方法声明成属性 { get { return new RelayCommand(MinusSign_Click); //RelayCommand后面讲 } } //后面的方法属性声明略 } } Display要声明成属性的样式，因为xaml里面能绑定的量要是属性\n所以后面的按钮方法都要声明成属性，这样才能在xaml里面绑定\n当然这里还出现了两个新东西\n一个是接口INotifyPropertyChanged，还有RelayCommand\nINotifyPropertyChanged字面意思就是通知属性更改\n就是说这个类里面有属性在更改时需要通知前端，让前端显示的东西也跟着改\n这个接口要求实现一个通知方法，反正就按上面的抄就好了\n(大体的原理就是发起一个事件，传回去，让前端知道有东西变了，再回来看)\nRelayCommand是自己实现的类，代码如下\n//RelayCommand.cs //常见的声明 namespace WPFTest { //实现ICommand接口 internal class RelayCommand : ICommand { //一个只读的Action属性，存储指令 public Action ExecuteAction { get; } public event EventHandler CanExecuteChanged; //构造函数 public RelayCommand(Action executeAction) { ExecuteAction = executeAction; } //表示能不能执行(我们这就默认能执行) public bool CanExecute(object parameter) { return true; } //调用方法 public void Execute(object parameter) { ExecuteAction(); } } } 就是这样，本质就是用泛型委托打包了个方法\n这个类也方便我们把方法打包成一个属性，好绑定到xaml中\n最后终于是我们的前端界面了\n其实多的不用改\n\u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; d:DataContext=\u0026#34;{d:DesignInstance Type=local:ViewModel}\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;!--这里指定了DataContext，让xaml能找到对应的属性--\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;6\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Border Name=\u0026#34;border\u0026#34; Background=\u0026#34;#241238\u0026#34; CornerRadius=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{TemplateBinding Content}\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;ControlTemplate.Triggers\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsMouseOver\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;#190D24\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsPressed\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;Black\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;/ControlTemplate.Triggers\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; MouseMove=\u0026#34;Border_MouseMove\u0026#34; Margin=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026#34;0\u0026#34; Orientation=\u0026#34;Horizontal\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34;\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Minimize\u0026#34; Click=\u0026#34;Button_Minimize_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0DC4E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Close\u0026#34; Click=\u0026#34;Button_Close_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0443E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;TextBlock Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;{Binding Display}\u0026#34; FontSize=\u0026#34;28\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34; Foreground=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;!--Text这里绑定的是显示的内容--\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Command=\u0026#34;{Binding ButtonMinusSign}\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;!--Command这里绑定的就是按钮的指令--\u0026gt; \u0026lt;!--后面的Button就不写了--\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; 其实就打注释的那三处要变，别的都不用改\n\u0026lt;0x03\u0026gt; MVVM模型到底有什么用\r说实在的，我刚学完这模型我也是说这玩意有啥用\n甚至觉得我是不是少看了些什么\n因为从逻辑上，这么写代码，代码量多了，但功能都没变过\n就感觉这么写很多余\n但实际上，我思考了好一阵(也是这篇博客拖这么久写完的原因)\n这个项目太小了，体现不出来\n想象一个稍微大点的项目，前后端分别开发的\n假设最终就两个主要的文件，一个前端，一个后端\n如果说后端突然抽风要改方法名，那前端也得跟着改(这就是耦合的情况)\n但如果用MVVM模型，在前后端之间再加层\u0026quot;胶水\u0026quot;层\n这样当后端改名的时候，\u0026ldquo;胶水\u0026quot;层的名字没改，前端就不用改，提高了效率\n(这样也叫解耦)\n别的好处我也很难讲了，毕竟目前我的开发经验不多\n正如我最前面写的，这个只是个思想，并不是什么语法之类的\n(总算写完了)\n","date":"2023-07-22T17:39:25Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-mvvm%E6%A8%A1%E5%9E%8B/","title":"WPF学习笔记03-MVVM模型"},{"content":"\u0026lt;0x00\u0026gt; WPF的界面美化挺方便的\r就研究了一小时不到，成功让计算器的UI上升了一个档次\n先看成果(因为相较于之前的界面确实帅多了)\n现代多了\n(为了显示效果改了下比例)\n咱们一块块慢慢讲\n\u0026lt;0x01\u0026gt; 如何实现自定义窗口控件与圆角窗口\r首先看这个界面，比较特殊的就是这个窗口有圆角\n而且右上角的按钮不是Windows的默认样式\n(红色的按钮是关闭，黄色的是最小化窗口)\n要做到这一点，我们要让窗口运行在无边框的模式下\n但运行在无边框模式下后，原先的窗口控件也没有了\n所以要自己写按钮实现窗口关闭和窗口最小化的功能\n(窗口最大化也差不多的逻辑，但这里不需要实现)\n无边框窗口\r首先要设置个无边框的窗口\n我们需要在\u0026lt;Window\u0026gt;标签里面加上WindowStyle=\u0026quot;None\u0026quot;就可以实现无边框的窗口了\n(@ 23-07-19)\n其实更正规的做法应该是用WindowChrome，当时不大会，这个只能说是个下策\n这个方法本质上是抛弃了非工作区的控件而在工作区重写这些窗口控件，效率有点低\n\u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;Window/\u0026gt; (差不多就这样，没讲的属性后面讲)\n这样，我们确实获得了一个无边框的窗口\n但这样有几个问题\n第一，窗口的圆角无法调整\n第二，窗口不能拖动\n解决第一个问题\r这意味着我们要自己写一个窗口实现\n(其实不难)\n系统的窗口相当于最下面的图层\n现在这个窗口不能满足我们的需求，所以我们要先隐藏自带的窗口\n在\u0026lt;Window\u0026gt;标签里面加上AllowsTransparency=\u0026quot;True\u0026quot;和Background=\u0026quot;Transparent\u0026quot;\n这两条属性表示允许窗口透明并设置窗口背景为透明\n下面我们要自己写一个背景来代替原来的窗口背景\n我们之前不是拿一个\u0026lt;Grid\u0026gt;包裹所有的控件吗\n既然是背景，那层级肯定是比这个Grid更高的\n所以只需要在\u0026lt;Grid\u0026gt;外面再套个\u0026lt;Border\u0026gt;就好\n(\u0026lt;Border\u0026gt;可以简单理解为绘制一个矩形)\n\u0026lt;!--差不多像这样--\u0026gt; \u0026lt;Window ...\u0026gt; \u0026lt;Border ...\u0026gt; \u0026lt;Grid ...\u0026gt; \u0026lt;!--...--\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; \u0026lt;Border\u0026gt;也可以设置不少的属性\n为了实现窗口圆角，设置下CornerRadius就好\n解决第二个问题\r在原生的窗口中，窗口的移动是靠上面的那一条的\n相当于窗口移动事件是绑定在那一条控件上的\n现在我们隐藏了，所以要自己去绑定这个窗口移动事件\n现在刚好写了个\u0026lt;Border\u0026gt;，这个可以绑定窗口移动事件\n在\u0026lt;Border\u0026gt;绑定MouseMove事件(就是添加个属性)\n这个相当于之前给Button绑定Click事件，要在对应.cs里面实现功能\nprivate void Border_MouseMove(object sender, MouseEventArgs e) { if (e.LeftButton == MouseButtonState.Pressed) { this.DragMove(); } } 加上这段代码就好\n现在这个窗口就能拖动了\n自定义窗口控件按钮\r本质上就是自己写个按钮，一个用来关闭程序，一个用来最小化\n(当然为了能放下这俩按钮还需要对页面布局做个小改动，这里就不写了)\n直接贴代码\n//关闭窗口 private void Button_Close_Click(object sender, RoutedEventArgs e) { this.Close(); } //最小化窗口 private void Button_Minimize_Click(object sender, RoutedEventArgs e) { this.WindowState = WindowState.Minimized; } 这两个方法绑定到对应的按钮就好\n\u0026lt;0x02\u0026gt; 如何实现圆角的按钮\r要实现圆角的按钮，我们需要重写按钮的绘制方法\n在xaml中，这个重写其实也挺简单的，我们仅需更改按钮的模板\n更改模板的方法有两种，先讲怎么更改单个按钮的模板\n(关闭窗口和最小化窗口的按钮样式就是这么实现的)\n\u0026lt;Button ...\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;!--具体的实现--\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; 在具体的实现里面写上绘制的样式就行了\n如果有很多的按钮需要更改为一个统一的样式，我们需要在\u0026lt;Style\u0026gt;中更改模板\n\u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;!--其他Setter--\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;!--具体的实现--\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; 注意，如果模板要绑定属性，TargetType=\u0026quot;Button\u0026quot;不能省\n({TemplateBinding Content}就是个绑定的语法，相当于拷贝Button.Content的内容)\n(具体看原代码吧，绑定确实不大好解释)\n更改过模板后，原来的触发器也给替换掉了，要我们自己再写一套\n(就是比方说鼠标放按钮上，按钮的颜色变深一点之类的)\n这个就要在\u0026lt;ControlTemplate\u0026gt;块中加上\u0026lt;ControlTemplate.Triggers\u0026gt;块\n再在里面写上若干\u0026lt;Trigger\u0026gt;即可\n\u0026lt;Trigger\u0026gt;就用来控制前端的显示，不管后端的\n\u0026lt;Trigger\u0026gt;中有Property(设置触发器类型)和Value(设置触发值)\n常用的Property有IsMouseOn(鼠标在不在上面)和IsPressed(鼠标有没有按下)\n\u0026lt;Trigger\u0026gt;块中通过\u0026lt;Setter\u0026gt;来设置样式\n这里的\u0026lt;Setter\u0026gt;需要加上TargetName(因为可能有好几个需要绘制的东西)\n\u0026lt;0x03\u0026gt; 如何实现背景的色彩渐变\r添加色彩渐变很简单\n\u0026lt;Border\u0026gt;块中加上这些代码即可\n\u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; 其中\u0026lt;LinearGradientBrush\u0026gt;指定了线性渐变\nStartPoint与EndPoint指定了起止点，\u0026quot;0,0\u0026quot;表示左上角，\u0026quot;0,1\u0026quot;表示左下角\n\u0026lt;GradientStop\u0026gt;中可以指定渐变的颜色，Offset相当于颜色在渐变条上的位置\n(如果用过些图像处理工具应该是能理解Offset的功能的)\n\u0026lt;0x04\u0026gt; 绘制窗口阴影\r因为我们已经把原生的窗口干掉了嘛，所以窗口阴影也没了\n没窗口阴影的话总是看着有些违和\n添加窗口阴影也很简单\n\u0026lt;Border\u0026gt;块中加上这些代码即可\n\u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; 在\u0026lt;Border\u0026gt;中也要调整下Margin属性，不然阴影可能显示不出\n附录\rMainWindow.xaml.cs的代码就不贴了，基本没什么改动\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Height=\u0026#34;400\u0026#34; Width=\u0026#34;300\u0026#34; WindowStartupLocation=\u0026#34;CenterScreen\u0026#34; AllowsTransparency=\u0026#34;True\u0026#34; Background=\u0026#34;Transparent\u0026#34; WindowStyle=\u0026#34;None\u0026#34;\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;6\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Foreground\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Border Name=\u0026#34;border\u0026#34; Background=\u0026#34;#241238\u0026#34; CornerRadius=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{TemplateBinding Content}\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; HorizontalAlignment=\u0026#34;Center\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;ControlTemplate.Triggers\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsMouseOver\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;#190D24\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsPressed\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter TargetName=\u0026#34;border\u0026#34; Property=\u0026#34;Background\u0026#34; Value=\u0026#34;Black\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;/ControlTemplate.Triggers\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Border CornerRadius=\u0026#34;10\u0026#34; MouseMove=\u0026#34;Border_MouseMove\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;Border.Background\u0026gt; \u0026lt;LinearGradientBrush StartPoint=\u0026#34;0,0\u0026#34; EndPoint=\u0026#34;0,1\u0026#34;\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#392669\u0026#34; Offset=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;GradientStop Color=\u0026#34;#46204F\u0026#34; Offset=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;/Border.Background\u0026gt; \u0026lt;Border.Effect\u0026gt; \u0026lt;DropShadowEffect Color=\u0026#34;Gray\u0026#34; ShadowDepth=\u0026#34;0\u0026#34; BlurRadius=\u0026#34;10\u0026#34; Opacity=\u0026#34;.5\u0026#34; Direction=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;/Border.Effect\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026#34;0\u0026#34; Orientation=\u0026#34;Horizontal\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34;\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Minimize\u0026#34; Click=\u0026#34;Button_Minimize_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0DC4E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Close\u0026#34; Click=\u0026#34;Button_Close_Click\u0026#34;\u0026gt; \u0026lt;Button.Template\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Ellipse Width=\u0026#34;16\u0026#34; Height=\u0026#34;16\u0026#34; Fill=\u0026#34;#F0443E\u0026#34;/\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Button.Template\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;TextBlock Grid.Row=\u0026#34;1\u0026#34; Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;0\u0026#34; FontSize=\u0026#34;28\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34; Foreground=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Click=\u0026#34;Button_MinusSign_Click\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Clear\u0026#34; Click=\u0026#34;Button_Clear_Click\u0026#34; Content=\u0026#34;CE\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Backspace\u0026#34; Click=\u0026#34;Button_Backspace_Click\u0026#34; Content=\u0026#34;←\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num9\u0026#34; Click=\u0026#34;Button_Num9_Click\u0026#34; Content=\u0026#34;9\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num8\u0026#34; Click=\u0026#34;Button_Num8_Click\u0026#34; Content=\u0026#34;8\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num7\u0026#34; Click=\u0026#34;Button_Num7_Click\u0026#34; Content=\u0026#34;7\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num6\u0026#34; Click=\u0026#34;Button_Num6_Click\u0026#34; Content=\u0026#34;6\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num5\u0026#34; Click=\u0026#34;Button_Num5_Click\u0026#34; Content=\u0026#34;5\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num4\u0026#34; Click=\u0026#34;Button_Num4_Click\u0026#34; Content=\u0026#34;4\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num3\u0026#34; Click=\u0026#34;Button_Num3_Click\u0026#34; Content=\u0026#34;3\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num2\u0026#34; Click=\u0026#34;Button_Num2_Click\u0026#34; Content=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num1\u0026#34; Click=\u0026#34;Button_Num1_Click\u0026#34; Content=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num0\u0026#34; Click=\u0026#34;Button_Num0_Click\u0026#34; Content=\u0026#34;0\u0026#34; Grid.ColumnSpan=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Dot\u0026#34; Click=\u0026#34;Button_Dot_Click\u0026#34; Content=\u0026#34;.\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Div\u0026#34; Click=\u0026#34;Button_Div_Click\u0026#34; Content=\u0026#34;/\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Mul\u0026#34; Click=\u0026#34;Button_Mul_Click\u0026#34; Content=\u0026#34;*\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Sub\u0026#34; Click=\u0026#34;Button_Sub_Click\u0026#34; Content=\u0026#34;-\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Add\u0026#34; Click=\u0026#34;Button_Add_Click\u0026#34; Content=\u0026#34;+\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Equal\u0026#34; Click=\u0026#34;Button_Equal_Click\u0026#34; Content=\u0026#34;=\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/Window\u0026gt; (经典写博客耗时比写代码多😂)\n","date":"2023-07-17T01:04:58Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96%E8%AE%A1%E7%AE%97%E5%99%A8/","title":"WPF学习笔记02-简单美化计算器"},{"content":"\u0026lt;0x00\u0026gt; 我为何选择WPF\r(@ 23-08-25)\n慢慢学了一个月，总算知道为啥现在用WPF的个人项目不多了\n写简单的UI确实非常方便，但如果要用些现代些的设计就很烦了\n非常容易出现些神秘问题\n这个我也说不明白，大概就是因为之前看到有些项目的窗口就是WPF写的吧\n一定要找个理由就是WPF的支持丰富\n作为一个老UI框架，教程满天飞，更重要的是，用WPF仍可以设计出现代的UI\n(而且相比那些electron框架来说性能更好，只要不搞跨平台)\n目前在Windows下，微软这常见的有四套UI框架\n分别是：WinFrom、WPF、WinUI3、XAUI\nWinFrom实在是老，做一些效果动画会比较费力\nWPF虽然也挺老的，但支持的特性足够做些不错的UI了\nWinUI3新是新，但教程不多，文档支持也比较神秘\nXAUI能跨平台，但微软特色，永不推广，而且也比较新，文档比较神秘\n从WPF开始，微软的UI框架都是要写.xaml的\n所以学会WPF之后，迁移到微软更新的UI框架的学习成本是相对低的\n目前我体验下来WPF算是很好入门的了，只需要会一门.net框架下的语言就可以入门\nxaml语法也不难，可以说看多了也会了\n而且微软的看家本领，UI的可视化开发(Visual Studio)，这对效率提升真的很有帮助\n这篇文章的代码来自我自己随便搞的简易计算器\n(整个程序就花了一个小时写完，足见WPF是多方便)\n\u0026lt;0x01\u0026gt; WPF的典型结构\r我这里创建的是基于C#的WPF项目\n创建完我们可以看到如图的项目结构\n差不多就是一个.xaml文件下套.cs文件\n其中在App.xaml文件中，定义了这个应用的基本信息(主要就是启动窗口是哪一个)\nMainWindows.xaml定义了窗口的样式(这个的编辑界面就是一半实时预览窗口，一半是代码编辑器)\n下面的.cs文件可以说描述程序的行为\n简单来说就是.xaml文件管前端(界面)，.cs文件管后端(行为)\n具体的东西后面再讲\n\u0026lt;0x02\u0026gt; XAML的简单语法\rxaml这玩意就是参考xml语法的\n如果能看懂xml甚至是html也能看懂xaml\n\u0026lt;!--MainWindow.xaml--\u0026gt; \u0026lt;Window x:Class=\u0026#34;WPFTest.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:WPFTest\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;800\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Margin\u0026#34; Value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;Setter Property=\u0026#34;FontSize\u0026#34; Value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;TextBlock Name=\u0026#34;Answer\u0026#34; Text=\u0026#34;0\u0026#34; FontSize=\u0026#34;30\u0026#34; HorizontalAlignment=\u0026#34;Right\u0026#34; Margin=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;Grid Grid.Row=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;ColumnDefinition/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;RowDefinition/\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Button Name=\u0026#34;Button_MinusSign\u0026#34; Click=\u0026#34;Button_MinusSign_Click\u0026#34; Content=\u0026#34;±\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Clear\u0026#34; Click=\u0026#34;Button_Clear_Click\u0026#34; Content=\u0026#34;CE\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Backspace\u0026#34; Click=\u0026#34;Button_Backspace_Click\u0026#34; Content=\u0026#34;←\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num9\u0026#34; Click=\u0026#34;Button_Num9_Click\u0026#34; Content=\u0026#34;9\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num8\u0026#34; Click=\u0026#34;Button_Num8_Click\u0026#34; Content=\u0026#34;8\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num7\u0026#34; Click=\u0026#34;Button_Num7_Click\u0026#34; Content=\u0026#34;7\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num6\u0026#34; Click=\u0026#34;Button_Num6_Click\u0026#34; Content=\u0026#34;6\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num5\u0026#34; Click=\u0026#34;Button_Num5_Click\u0026#34; Content=\u0026#34;5\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num4\u0026#34; Click=\u0026#34;Button_Num4_Click\u0026#34; Content=\u0026#34;4\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num3\u0026#34; Click=\u0026#34;Button_Num3_Click\u0026#34; Content=\u0026#34;3\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num2\u0026#34; Click=\u0026#34;Button_Num2_Click\u0026#34; Content=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num1\u0026#34; Click=\u0026#34;Button_Num1_Click\u0026#34; Content=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Num0\u0026#34; Click=\u0026#34;Button_Num0_Click\u0026#34; Content=\u0026#34;0\u0026#34; Grid.ColumnSpan=\u0026#34;2\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Dot\u0026#34; Click=\u0026#34;Button_Dot_Click\u0026#34; Content=\u0026#34;.\u0026#34; Grid.Column=\u0026#34;2\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Div\u0026#34; Click=\u0026#34;Button_Div_Click\u0026#34; Content=\u0026#34;/\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Mul\u0026#34; Click=\u0026#34;Button_Mul_Click\u0026#34; Content=\u0026#34;*\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Sub\u0026#34; Click=\u0026#34;Button_Sub_Click\u0026#34; Content=\u0026#34;-\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Add\u0026#34; Click=\u0026#34;Button_Add_Click\u0026#34; Content=\u0026#34;+\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;Button Name=\u0026#34;Button_Equal\u0026#34; Click=\u0026#34;Button_Equal_Click\u0026#34; Content=\u0026#34;=\u0026#34; Grid.Column=\u0026#34;3\u0026#34; Grid.Row=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; (为了代码高亮正常工作，这里的代码设置为xml的高亮格式)\n一块块掰碎讲\n声明部分\r就是最上面一坨不知道什么东西的部分，随便写写的话根本不需要知道这些是啥，别动就好\n(因为我目前也不是很懂这些)\n\u0026lt;Window.Resources\u0026gt;\r这里面我就定义了个Button类型的Style\n其实就是规定了Button的一些默认参数\n在下面写Button的时候就不用一个个都写这些东西了\nStyle里面定义了按钮到界面边界的距离(Margin)有5单位\n字体大小(FontSize)为30个单位\n(在WPF里，并不是以像素为单位，而是按DPI来确定实际像素单位大小)\n\u0026lt;Style\u0026gt;里面要指定设置的类型(TargetType)\n在\u0026lt;Style\u0026gt;块中，用\u0026lt;Setter\u0026gt;标签来设置类型下面的属性\n\u0026lt;Setter\u0026gt;标签里面Property选择属性，Value选择值\n\u0026lt;Grid\u0026gt;\r在WPF中，有两种常用的界面布局\n分别是：网格布局(\u0026lt;Grid\u0026gt;)和栈布局(\u0026lt;StackPanel\u0026gt;)\n\u0026lt;Grid\u0026gt;可以把一块区域分割成一个网格，网格里面可以塞控件\n\u0026lt;StackPanel\u0026gt;就是个栈，所有控件从上到下(从左到右)排列\n基本上用这两种布局的互相嵌套能解决绝大多数的布局\n我这里的布局选择了\u0026lt;Grid\u0026gt;里面再套一个\u0026lt;Grid\u0026gt;\n具体实现\r在\u0026lt;Grid.RowDefinitions\u0026gt;块里面塞两个\u0026lt;RowDefinition/\u0026gt;把Grid分成两行\n(塞几个\u0026lt;RowDefinition/\u0026gt;就是有几行，列同理)\n在一个\u0026lt;RowDefinition/\u0026gt;里加入Height=\u0026quot;auto\u0026quot;表示第一行的高度随内容改变\n(就是跟着第一行的控件高度走)\n然后正式往Grid网格里面塞控件，先第一行\n首先是再塞了个\u0026lt;Grid\u0026gt;，然后在里面塞了个\u0026lt;TextBlock\u0026gt;\n其中，Grid.Row可以指定控件所在的网格行号，列同理\n并定义了一系列的属性参数\n(Name属性就是给.cs调用的对象名，HorizontalAlignment是水平对正方式，设置为右对齐)\n(不是很懂我当时写的逻辑，其实不用多写个\u0026lt;Grid\u0026gt;，直接塞\u0026lt;TextBlock\u0026gt;就好)\n第二行，塞了个\u0026lt;Grid\u0026gt;，并定义出5*4的网格\n下面就是一大堆的按键定义，相对比较无趣\n值得说道的是Click属性，这个会指向对应.cs的一个具体的方法名，实现前后端的融合\n(具体看后端实现就可以了)\n还有按钮0多了个Grid.ColumnSpan=\u0026quot;2\u0026quot;，这个就是让这个按钮可以跨两列显示\n由于有之前的\u0026lt;Style\u0026gt;的定义，所有的按钮都自带字体大小30单位，间距5单位的属性\n这样，我们成功整出了一个简单的计算器界面\n长这样的\n\u0026lt;0x03\u0026gt; 与C#后端的结合\r(@ 23-08-14)\n实际上这样并不是搞后端，这些都是再定义前端的行为\n具体搞后端可以看我之后写的讲MVVM设计模型的博客\n但如果项目很小的话这样搞也没问题的\n与C#后端的结合可以说非常简单，就是调用和更改控件对象的成员值就可以\n还记得我们已经在.xaml中为一些控件添加了Name属性吗\n这些Name属性是实现前后端融合的关键\n//等于号按键点击事件的实现逻辑 private void Button_Equal_Click(object sender, RoutedEventArgs e) { if (flag \u0026amp;\u0026amp; ans != null) { Calculate(); flag = false; Answer.Text = ans.ToString(); calculate = null; } } 别的都不重要，还记得我们有一个\u0026lt;TextBlock\u0026gt;的Name属性设置为Answer吗\n通过Answer.Text可以直接访问并修改\u0026lt;TextBlock\u0026gt;的内容，非常方便\n(Answer.Text就是String类型)\n其他的控件也同理\n接下来要处理下按钮的点击事件了\n这个也非常简单，我们之前已经设置了每个按钮的Click属性\n接下来就是在对应的.cs中实现逻辑就好\n//大概的结构 namespace WPFTest { public partial class MainWindow : Window { //... private void Button_MinusSign_Click(object sender, RoutedEventArgs e); //加负号按钮的点击事件 private void Button_Clear_Click(object sender, RoutedEventArgs e); //清屏键的点击事件 private void Button_Backspace_Click(object sender, RoutedEventArgs e); //退格键的点击事件 private void Button_Num9_Click(object sender, RoutedEventArgs e); private void Button_Num8_Click(object sender, RoutedEventArgs e); private void Button_Num7_Click(object sender, RoutedEventArgs e); private void Button_Num6_Click(object sender, RoutedEventArgs e); private void Button_Num5_Click(object sender, RoutedEventArgs e); private void Button_Num4_Click(object sender, RoutedEventArgs e); private void Button_Num3_Click(object sender, RoutedEventArgs e); private void Button_Num2_Click(object sender, RoutedEventArgs e); private void Button_Num1_Click(object sender, RoutedEventArgs e); private void Button_Num0_Click(object sender, RoutedEventArgs e); //各个数字键的点击事件 private void Button_Dot_Click(object sender, RoutedEventArgs e); //小数点按键的点击事件 private void Button_Div_Click(object sender, RoutedEventArgs e); private void Button_Mul_Click(object sender, RoutedEventArgs e); private void Button_Sub_Click(object sender, RoutedEventArgs e); private void Button_Add_Click(object sender, RoutedEventArgs e); //+-*/键的点击事件 private void Button_Equal_Click(object sender, RoutedEventArgs e); //等于号的点击事件 } } 每个按钮的点击事件都相当于在C#中的一个方法\n点击一次就触发一次\n附录\r完整的MainWindow.xaml已经贴在上文了，这里就不再放了\n//MainWindow.xaml.cs using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes; namespace WPFTest { public partial class MainWindow : Window { bool flag = false; int? calculate = null; double? ans = null; public MainWindow() { InitializeComponent(); } private void Calculate() { switch (calculate) { case 1: ans += Double.Parse(Answer.Text); break; case 2: ans -= Double.Parse(Answer.Text); break; case 3: ans *= Double.Parse(Answer.Text); break; case 4: ans /= Double.Parse(Answer.Text); break; } } private void Button_MinusSign_Click(object sender, RoutedEventArgs e) { if (flag) { if (Answer.Text[0]==\u0026#39;-\u0026#39;) { Answer.Text = Answer.Text.Substring(1, Answer.Text.Length - 1); } else { Answer.Text = \u0026#34;-\u0026#34; + Answer.Text; } } } private void Button_Clear_Click(object sender, RoutedEventArgs e) { flag = false; calculate = null; ans = null; Answer.Text = \u0026#34;0\u0026#34;; } private void Button_Backspace_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text = Answer.Text.Substring(0, Answer.Text.Length - 1); if (Answer.Text.Length == 0) { flag = false; Answer.Text = \u0026#34;0\u0026#34;; } } } private void Button_Num9_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;9\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;9\u0026#34;; } } private void Button_Num8_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;8\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;8\u0026#34;; } } private void Button_Num7_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;7\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;7\u0026#34;; } } private void Button_Num6_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;6\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;6\u0026#34;; } } private void Button_Num5_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;5\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;5\u0026#34;; } } private void Button_Num4_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;4\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;4\u0026#34;; } } private void Button_Num3_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;3\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;3\u0026#34;; } } private void Button_Num2_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;2\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;2\u0026#34;; } } private void Button_Num1_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;1\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;1\u0026#34;; } } private void Button_Num0_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;0\u0026#34;; } else { flag = true; Answer.Text = \u0026#34;0\u0026#34;; } } private void Button_Dot_Click(object sender, RoutedEventArgs e) { if (flag) { Answer.Text += \u0026#34;.\u0026#34;; } } private void Button_Div_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 4; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 4; } } private void Button_Mul_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 3; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 3; } } private void Button_Sub_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 2; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 2; } } private void Button_Add_Click(object sender, RoutedEventArgs e) { if (flag) { if (ans == null) { ans = Double.Parse(Answer.Text); calculate = 1; flag = false; } else { Calculate(); flag = false; Answer.Text = ans.ToString(); } } else { calculate = 1; } } private void Button_Equal_Click(object sender, RoutedEventArgs e) { if (flag \u0026amp;\u0026amp; ans != null) { Calculate(); flag = false; Answer.Text = ans.ToString(); calculate = null; } } } } 逻辑就是随性写的，不保证完全没Bug，应该是没严重Bug的\n(所以也没写高精度的运算处理)\n(写这篇博客比我写代码的时间都长😂)\n","date":"2023-07-15T20:51:01Z","permalink":"https://mlacookie.github.io/article/categories/wpf/wpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/","title":"WPF学习笔记01-一个简单的计算器"},{"content":"前言\r一般来说离散的课设都是给一大堆题目然后自己选的\n我选的是合式公式的真值表和成真成假赋值\n算是里面相对难的\n(别的是真挺简单的)\n课设我是拿C#写的(人生苦短，还是用好用的语言吧)\n应该常用的.net版本都能跑起来吧，代码里没怎么用新特性\n(我用的是.net 6.0)\nC#的语法还是挺好懂得，用过C系语言看懂应该问题不大\n同样，可以在本文最后复制所有的原码\n(就一个文件，就不发本站的gitea了)\n(报告自己写写挺快的)\n\u0026lt;0x00\u0026gt; 如何解析合式公式\r在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的\n(所谓解析就是判断计算的优先级)\n比方说我们有公式1+2*3/(4-5)\n按运算优先级加上括号就是(1+((2*3)/(4-5)))\n所以说我们该如何让计算机按这样的优先级计算呢\n双栈法\n准备两个栈，一个是运算数栈，一个是运算符栈\n运算式在运算前先在首位各加括号(确保最后会栈空)\n然后从左向右遍历运算式\n遇到(时直接压入运算符栈，遇到数字压入运算数栈\n当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入\n如果不是，那么就先进行弹出操作\n每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中\n重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止\n如果遍历过程中遇到)，则反复进行弹出操作，直到弹出一个(为止\n(动画是用manim做的，头一次做)\n同样的思路也可以运用在合式公式上\n具体流程如下：\n1 给公式的左右套上括号 2 从左向右读取 3 如果遇到(，将(压入运算符栈后继续 4 如果遇到运算数，压入操作数栈后继续 5 如果遇到运算符，按照以下规则： a 如果运算符栈为空或栈顶元素优先级小于当前运算符，直接压入运算符栈 b 若遇到栈顶元素为┐(非)，需要弹出所有的连续┐(非)，弹出此运算符再弹出一个运算数，并将运算结果压回操作数栈 c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照5.a压入运算符栈 6 遇到)时，反复按照规则弹出，直到运算符栈顶为(，最后移除栈顶的( 7 读取完毕后，操作数栈留下的东西就是公式答案 这个就不再用动画演示了，本质上就是一般+-*/运算双栈法的变种\n唯一不一样的就是对于┐(非)要注意连续弹出问题\n因为┐(非)是一个右结合单目运算符，而且优先级最高\n如果不先处理调连续的┐(非)容易解析出问题\n所以要把连续的┐(非)全弹出，当作一个整体，这样才能出正确答案\n\u0026lt;0x01\u0026gt; 由双栈法构建运算树\r目前我们已经有方法解析合式公式了，但有一个问题\n我们的题目要求给出一个真值表\n如果每次计算我们都要先解析一遍合式公式的话，效率不会很高\n所以我们要用一种数据结构来保存计算的结构\n每个单一操作数数可以改变对应的真假指派(就是T/F)\n对于一个计算的过程，我们可以抽象成一个树\n所有的操作数都是树的叶子(最末端的节点)\n操作数由运算符连接，合成一个新节点\n如此嵌套，最后连接在一个根节点上\n每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果\n就是这么个结构\n怎么构建这棵树呢，其实之前的双栈法里就有这个答案\n我们仅需略微更改下代码，操作数栈不存储运算结果而是存储运算节点\n这样走一遍公式就相当于构建了一颗计算树\n最后只要存储根节点就好了\n\u0026lt;0x02\u0026gt; 逻辑实现\r按从低到高的优先级列出运算符的枚举类型\rpublic enum Operator//枚举运算符 { LeftBracket,//左括号 XNOR,//双条件运算符 Odds,//条件运算符 Or,//析取运算符 And,//合取运算符 Not,//取反运算符 } 定义计算树的计算节点类(仅列出定义)\rinternal class CalculateNode//定义计算节点 { CalculateNode? left;//运算符左边 CalculateNode? right;//运算符右边 Operator oper;//节点的运算符 bool ans;//该节点答案 internal CalculateNode(bool ans);//末节点构造方法 internal CalculateNode(CalculateNode? left, CalculateNode right, Operatoroper);//计算节点构造方法 static bool Odds(bool a, bool b);//单独定义条件运算符 bool Calculate(CalculateNode node);//从某节点递归计算 internal bool Calculate();//提供一个入口 internal void ChangeAns(bool ans);//改变末节点的值 } 可以看到，每个计算节点包含运算符，左边节点，右边节点，节点答案\n操作数节点仅有节点答案(所以左右节点的类型是可空类型)\n因为条件运算符没有现成的运算符，所以自己写一个\nCalculate(CalculateNode node)通过递归来遍历每个节点并给出每个节点的答案\nCalculate()专门给外部调用的，里面就一句return Calculate(this);\nChangeAns(bool ans)用来改变操作数的真假指派\n定义WellFormedFormula类(仅列出定义)\rpublic class WellFormedFormula { string formula;//原公式 Dictionary\u0026lt;string, CalculateNode\u0026gt; map;//以string方式索引所有节点 Dictionary\u0026lt;int, string\u0026gt; dic;//以int方式索引所有根节点的名字 CalculateNode root;//最终答案节点 bool[] truthTable;//真值表 private static bool IsOperator(char c);//判断是否为二元运算符 private static char OperatorToChar(Operator op);//运算符换成char private static Operator CharToOperator(char c);//char换成运算符 private bool Verify();//验证公式是否有效 private void Init();//初始化计算树 public WellFormedFormula(string formula);//构造方法 public bool Calculate(int n); public bool Calculate(Dictionary\u0026lt;string, bool\u0026gt; keyValuePairs);//单独计算用 private void CalculateAll();//全计算 public void ChangeFormula(string formula);//更改公式 public void ShowrTruthTable();//展示真值表 public void ShowFormula();//展示公式 public void ShowAllNode();//展示所有节点信息，用于调试 public void ShowTrueAssignment();//展示所有成真赋值 public void ShowFalseAssignment();//展示所有成假赋值 public void ShowDNF();//主析取范式 public void ShowCNF();//主合取范式 } 最关键的是Init()方法，别的实现不难\nprivate void Init()//初始化计算树(略去实现细节) { Verify();//验证 //获取所有的变量 //... //构建计算树 //... CalculateAll();//顺便把真值表给算了 } 在Init()中，先验证公式合法性(防输入错误)\n然后会先遍历遍公式，获取所有的变量名并创建操作数节点(末节点)\n然后再遍历一遍，构建计算树\n构建完成后，root指向根节点，map可以按节点名索引到对应的操作数节点\ndic可以按index索引到节点名字(方便遍历)\n构建完再计算所有的赋值情况，直接得出真值表\n其他的方法都是调用真值表答案，不会再计算公式\n构建过程就是双栈法构建\n附录，所有的代码\r//核心逻辑实现 namespace CStest { public enum Operator//枚举运算符 { LeftBracket,//左括号 XNOR,//双条件运算符 Odds,//条件运算符 Or,//析取运算符 And,//合取运算符 Not,//取反运算符 } internal class CalculateNode//定义计算节点 { CalculateNode? left;//运算符左边 CalculateNode? right;//运算符右边 Operator oper;//节点的运算符 bool ans;//该节点答案 internal CalculateNode(bool ans)//末节点构造方法 { left = null; right = null; this.ans = ans; } internal CalculateNode(CalculateNode? left, CalculateNode right, Operator oper)//计算节点构造方法 { this.left = left; this.right = right; this.oper = oper; } static bool Odds(bool a, bool b)//单独定义条件运算符 { if (!a) { return true; } else { if (b) { return true; } else { return false; } } } bool Calculate(CalculateNode node)//从某节点递归计算 { if (node.right == null)//递归边界条件 { return node.ans; } switch (node.oper) { case Operator.Not: node.ans = !Calculate(node.right); break; case Operator.And: node.ans = Calculate(node.left) \u0026amp;\u0026amp; Calculate(node.right); break; case Operator.Or: node.ans = Calculate(node.left) || Calculate(node.right); break; case Operator.Odds: node.ans = Odds(Calculate(node.left), Calculate(node.right)); break; case Operator.XNOR: node.ans = !(Calculate(node.left) ^ Calculate(node.right)); break; } return node.ans; } internal bool Calculate()//提供一个入口 { return Calculate(this); } internal void ChangeAns(bool ans)//改变末节点的值 { this.ans = ans; } } public class WellFormedFormula { string formula;//原公式 Dictionary\u0026lt;string, CalculateNode\u0026gt; map;//以string方式索引所有节点 Dictionary\u0026lt;int, string\u0026gt; dic;//以int方式索引所有根节点的名字 CalculateNode root;//最终答案节点 bool[] truthTable;//真值表 private static bool IsOperator(char c)//判断是否为二元运算符 { return c == \u0026#39;∧\u0026#39; || c == \u0026#39;∨\u0026#39; || c == \u0026#39;→\u0026#39; || c == \u0026#39;⊙\u0026#39;; } private static char OperatorToChar(Operator op)//运算符换成char { switch (op) { case Operator.And: return \u0026#39;∧\u0026#39;; case Operator.Or: return \u0026#39;∨\u0026#39;; case Operator.Odds: return \u0026#39;→\u0026#39;; case Operator.XNOR: return \u0026#39;⊙\u0026#39;; } return \u0026#39; \u0026#39;; } private static Operator CharToOperator(char c)//char换成运算符 { switch (c) { case \u0026#39;∧\u0026#39;: return Operator.And; case \u0026#39;∨\u0026#39;: return Operator.Or; case \u0026#39;→\u0026#39;: return Operator.Odds; case \u0026#39;⊙\u0026#39;: return Operator.XNOR; } return Operator.LeftBracket; } private bool Verify()//验证公式是否有效 { if (IsOperator(formula[0]) || formula[^1] == \u0026#39;┐\u0026#39; || IsOperator(formula[^1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//在首尾出现了不该出现的运算符 } int l = 0;//统计左括号 int r = 0;//统计右括号 for (int i = 0; i \u0026lt; formula.Length; i++) { if (formula[i] == \u0026#39;(\u0026#39;) { l++; } else if (formula[i] == \u0026#39;)\u0026#39;) { r++; } if (formula[i] == \u0026#39;┐\u0026#39;) { if (IsOperator(formula[i + 1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//取反运算符后接别的运算符 } } if (IsOperator(formula[i])) { if (IsOperator(formula[i - 1])) { throw new Exception(\u0026#34;Error in formula\u0026#34;); } if (IsOperator(formula[i + 1]) || formula[i + 1] == \u0026#39;┐\u0026#39;) { throw new Exception(\u0026#34;Error in formula\u0026#34;); } }//都是判断多个运算符不应该相连的情况 } if (l != r) { throw new Exception(\u0026#34;Error in formula\u0026#34;);//左右括号数不匹配 } return true; } private void Init()//初始化计算树 { Verify();//验证 string formula = \u0026#34;(\u0026#34; + this.formula + \u0026#34;)\u0026#34;; //获取所有的变量 int index = 0; bool flag = true; for (int i = 0; i \u0026lt; formula.Length; i++) { if (flag \u0026amp;\u0026amp; formula[i] != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; formula[i] != \u0026#39;┐\u0026#39; \u0026amp;\u0026amp; !IsOperator(formula[i])) { index = i; flag = false; } else if (formula[i] == \u0026#39;)\u0026#39; || formula[i] == \u0026#39;┐\u0026#39; || IsOperator(formula[i])) { if (index != i \u0026amp;\u0026amp; !flag \u0026amp;\u0026amp; !map.ContainsKey(formula[index..i])) { map.Add(formula[index..i], new CalculateNode(false)); dic.Add(dic.Count, formula[index..i]); } flag = true; } } flag = true; //构建计算树 Stack\u0026lt;string\u0026gt; v = new Stack\u0026lt;string\u0026gt;();//操作数栈 Stack\u0026lt;Operator\u0026gt; op = new Stack\u0026lt;Operator\u0026gt;();//运算符栈 string sa; string sb;//两个临时string变量 for (int i = 0; i \u0026lt; formula.Length; i++) { if (formula[i] == \u0026#39;(\u0026#39;)//左括号直接压入栈 { op.Push(Operator.LeftBracket); continue; } if (flag \u0026amp;\u0026amp; formula[i] != \u0026#39;)\u0026#39; \u0026amp;\u0026amp; formula[i] != \u0026#39;┐\u0026#39; \u0026amp;\u0026amp; !IsOperator(formula[i])) { index = i; flag = false; } else if (formula[i] == \u0026#39;)\u0026#39; || formula[i] == \u0026#39;┐\u0026#39; || IsOperator(formula[i])) { if (index != i \u0026amp;\u0026amp; !flag)//压入操作数 { v.Push(formula[index..i]); flag = true; } if (formula[i] == \u0026#39;┐\u0026#39;) { op.Push(Operator.Not);//取反直接压入 } else if (formula[i] == \u0026#39;)\u0026#39;)//遇到右括号不断弹出，直到遇到左括号 { while (op.Peek() != Operator.LeftBracket) { if (op.Peek() == Operator.Not) { sa = v.Pop(); map.Add(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;, new CalculateNode(null, map[sa], Operator.Not)); v.Push(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;); break; } else { sa = v.Pop(); sb = v.Pop(); map.Add(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;, new CalculateNode(map[sb], map[sa], op.Peek())); v.Push(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;); } op.Pop(); } op.Pop();//弹出左括号 } else { if (op.Count != 0 \u0026amp;\u0026amp; CharToOperator(formula[i]) \u0026lt; op.Peek()) { if (op.Peek() == Operator.Not) { do//由于取反运算可多个连接，所以要一次性弹出所有连续的取反运算 { op.Pop(); sa = v.Pop(); map.Add(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;, new CalculateNode(null, map[sa], Operator.Not)); v.Push(\u0026#34;(┐\u0026#34; + sa + \u0026#34;)\u0026#34;); } while (op.Peek() == Operator.Not); } else { sa = v.Pop(); sb = v.Pop(); map.Add(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;, new CalculateNode(map[sb], map[sa], op.Peek())); v.Push(\u0026#34;(\u0026#34; + sb + OperatorToChar(op.Peek()) + sa + \u0026#34;)\u0026#34;); op.Pop(); } } op.Push(CharToOperator(formula[i]));//最后把当前运算符压入 } } } root = map[v.Pop()];//最后的操作数就是root节点 truthTable = new bool[(int)Math.Pow(2, dic.Count)]; CalculateAll();//顺便把真值表给算了 } public WellFormedFormula(string formula)//构造方法 { map = new Dictionary\u0026lt;string, CalculateNode\u0026gt;(); dic = new Dictionary\u0026lt;int, string\u0026gt;(); this.formula = formula; Init(); } public bool Calculate(int n) { return truthTable[n]; } public bool Calculate(Dictionary\u0026lt;string, bool\u0026gt; keyValuePairs)//单独计算用 { if (keyValuePairs.Count != dic.Count) { throw new Exception(); } foreach (var kv in keyValuePairs) { map[kv.Key].ChangeAns(kv.Value); } return root.Calculate(); } private void CalculateAll()//全计算 { Stack\u0026lt;bool\u0026gt; b = new Stack\u0026lt;bool\u0026gt;(); int index; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { b.Clear(); index = i; while (index \u0026gt; 0) { if (index % 2 == 1) { b.Push(true); } else { b.Push(false); } index /= 2; } while (b.Count \u0026lt; dic.Count) { b.Push(false); } for (int j = 0; j \u0026lt; dic.Count; j++) { map[dic[j]].ChangeAns(b.Pop()); } truthTable[i] = root.Calculate(); } } public void ChangeFormula(string formula)//更改公式 { this.formula = formula; map.Clear(); dic.Clear(); Init(); } public void ShowrTruthTable()//展示真值表 { for (int i = 0; i \u0026lt; dic.Count; i++) { Console.Write(dic[i] + \u0026#39;\\t\u0026#39;); } Console.WriteLine(formula); Stack\u0026lt;bool\u0026gt; b = new Stack\u0026lt;bool\u0026gt;(); int index; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { index = i; while (index \u0026gt; 0) { if (index % 2 == 1) { b.Push(true); } else { b.Push(false); } index /= 2; } while (b.Count \u0026lt; dic.Count) { b.Push(false); } while (b.Count \u0026gt; 0) { if (b.Pop()) { Console.Write(\u0026#34;T\\t\u0026#34;); } else { Console.Write(\u0026#34;F\\t\u0026#34;); } } if (truthTable[i]) { Console.WriteLine(\u0026#34;T\u0026#34;); } else { Console.WriteLine(\u0026#34;F\u0026#34;); } } } public void ShowFormula()//展示公式 { Console.WriteLine(formula); } public void ShowAllNode()//展示所有节点信息，用于调试 { Console.Write(\u0026#34;| \u0026#34;); foreach (var m in map) { Console.Write(m.Key + \u0026#34; | \u0026#34;); } Console.WriteLine(); } public void ShowTrueAssignment()//展示所有成真赋值 { Console.Write(\u0026#34;All true assignment: \u0026#34;); for (int i = 0; i \u0026lt; dic.Count; i++) { if (i == 0) { Console.Write(dic[i]); } else { Console.Write(\u0026#34; | \u0026#34; + dic[i]); } } Console.WriteLine(); int index; Stack\u0026lt;byte\u0026gt; temp = new Stack\u0026lt;byte\u0026gt;(); for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { temp.Clear(); if (truthTable[i]) { index = i; while (index \u0026gt; 0) { temp.Push((byte)(index % 2)); index /= 2; } while (temp.Count \u0026lt; dic.Count) { temp.Push(0); } while (temp.Count \u0026gt; 0) { Console.Write(temp.Pop()); } Console.WriteLine(\u0026#34;(\u0026#34; + i + \u0026#34;)\u0026#34;); } } } public void ShowFalseAssignment()//展示所有成假赋值 { Console.Write(\u0026#34;All false assignment: \u0026#34;); for (int i = 0; i \u0026lt; dic.Count; i++) { if (i == 0) { Console.Write(dic[i]); } else { Console.Write(\u0026#34; | \u0026#34; + dic[i]); } } Console.WriteLine(); int index; Stack\u0026lt;byte\u0026gt; temp = new Stack\u0026lt;byte\u0026gt;(); for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { temp.Clear(); if (!truthTable[i]) { index = i; while (index \u0026gt; 0) { temp.Push((byte)(index % 2)); index /= 2; } while (temp.Count \u0026lt; dic.Count) { temp.Push(0); } while (temp.Count \u0026gt; 0) { Console.Write(temp.Pop()); } Console.WriteLine(\u0026#34;(\u0026#34; + i + \u0026#34;)\u0026#34;); } } } public void ShowDNF()//主析取范式 { int count = 0; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { if (truthTable[i]) { if (count == 0) { Console.Write(\u0026#34;m(\u0026#34; + i + \u0026#34;)\u0026#34;); } else { Console.Write(\u0026#34;∨m(\u0026#34; + i + \u0026#34;)\u0026#34;); } count++; } } Console.WriteLine(); } public void ShowCNF()//主合取范式 { int count = 0; for (int i = 0; i \u0026lt; (int)Math.Pow(2, dic.Count); i++) { if (!truthTable[i]) { if (count == 0) { Console.Write(\u0026#34;M(\u0026#34; + i + \u0026#34;)\u0026#34;); } else { Console.Write(\u0026#34;∧M(\u0026#34; + i + \u0026#34;)\u0026#34;); } count++; } } Console.WriteLine(); } } } //main.cs namespace CTest{ public class test { public static void Main(String[] args) { WellFormedFormula w = new WellFormedFormula(\u0026#34;(P∨Q)∧(P→R)\u0026#34;); w.ShowAllNode(); w.ShowrTruthTable(); w.ShowTrueAssignment(); w.ShowFalseAssignment(); w.ShowCNF(); w.ShowDNF(); } } } ","date":"2023-07-04T13:14:00Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/","title":"浙工大离散课设讲解"},{"content":"\u0026lt;0x00\u0026gt; 前言\r我的题目是幼儿园的信息管理系统(第29号)\n运行在Cmake 3.25.3+mingw 12.2.0上\n基本要求： 能从文件读出一个班级小朋友的信息，并能将管理信息保存到文件 小朋友的信息包括：姓名、出生年月（年龄）、性别、住址、身高、体重、父母联系人姓名、联系电话，备注信息等 功能要求： 1、系统以菜单方式工作； 2、增加修改和删除小朋友信息； 3、查询某个小朋友的父母联系人姓名及联系电话；查询小朋友住址； 4、显示所有小朋友信息：能根据小朋友的身高、体重分别排序，或者按身高体重比排序； 5、能按性别统计班级男女生人数比例； 6、可以进行小朋友信息的文件读写。 实现上面功能是挺简单，所以我加入了一些新功能\n于是就实现了些杂七杂八的东西(之后也会重点介绍的):\n双向模板链表 方向键界面控制 csv的文件读取和导出 多文件管理 从临时文件恢复 本来想实现更多的，实际上摸了就没写😋\n(主要是真没啥好写的)\n你可以在本站gitea下载源代码\n(课设报告就不发了，自己写写挺快的)\n\u0026lt;0x01\u0026gt; 双向链表实现\r//Mylist.cpp 仅列出声明，完整代码见源文件 #pragma once #include \u0026lt;cstddef\u0026gt; //NULL的定义在这个头文件里(我用的是mingw) using namespace std; template \u0026lt;class T\u0026gt; class MyList; //提前声明类型 template \u0026lt;class T\u0026gt; class MyNode { T content; // 存放内容 MyNode\u0026lt;T\u0026gt; *next; // 指向下一个Node MyNode\u0026lt;T\u0026gt; *back; // 指向前一个Node friend class MyList\u0026lt;T\u0026gt;; // 为List类提供访问权限(方便) friend class Tool; // 为Tool类提供访问权限(方便) MyNode(); public: MyNode(const T \u0026amp;content, MyNode *next = NULL, MyNode *back = NULL); MyNode(const MyNode \u0026amp;n); //一些节点的构造函数 MyNode\u0026lt;T\u0026gt; \u0026amp;operator=(const MyNode \u0026amp;n); //保险起见，重载下赋值运算 }; template \u0026lt;class T\u0026gt; class MyList { int length; // List的长度 MyNode\u0026lt;T\u0026gt; *head; // 指向头节点 MyNode\u0026lt;T\u0026gt; *end; // 指向尾节点 MyNode\u0026lt;T\u0026gt; *Find(int index) const; // 内部按index搜索用 friend class Tool; // 为Tool类提供访问权限(懒得写访问的函数了) public: MyList(); bool Insert(const T \u0026amp;c, int n = 0); // 插入List，可指定插入位置 bool Delete(int index); // 按index删除List元素 void Clear(); // 清空List内容 int GetLength() const; // 返回List的长度 MyList\u0026lt;T\u0026gt; \u0026amp;operator=(const MyList\u0026lt;T\u0026gt; \u0026amp;n); //保险起见，重载下赋值运算 T *operator[](int index) const; // 外部按index搜索用 ~MyList(); // 析构是门学问 }; 泛型类 MyNode\u0026lt;T\u0026gt;\r主要就是存放内容物的节点，为了数据结构的可拓展性，就写了个泛型\n基本就没啥好说的，关键就是用指针关系吧各个节点连接起来\n我这里采用的是双向链表的数据结构，即每个节点可以找到它的前一个后一个\n所以我这里的MyNode类需要两个指针，一个指前一个节点，一个指后一个节点\n泛型类 MyList\u0026lt;T\u0026gt;\r说白了，这部分的内容就是把各个节点拼起来\n为了首尾插入效率与保险起见，这个双向列表带有空的首尾节点\n(但最终代码没有完成对末尾插入的优化，忘了\n总之，数据结构图如下\n每个节点都可以找到它的前后节点\n虽然对插入操作没什么优势，但可以加速删除操作\n对于删除操作，仅需传入节点位置即可删除\n相当于把要删除的东西抽出来，再两边节点建立连接\n(单向链表的删除比较抽象)\n对于Clear()操作，相当于走一遍链表，边走边删对象\n走完了再回归到初始状态\n析构就是Clear()后再把首尾节点也删了\n剩下的都挺直观的，也不说了\n\u0026lt;0x02\u0026gt; 方向键控制\r方向键控制的代码写在UI.hpp里\nUI.hpp里面都是一堆静态函数，提供一些标准化输出实现\n(压缩代码量)\n//能实现方向控制的示例代码 #include \u0026lt;conio.h\u0026gt; //必要的头文件 using namespace std; int main() { char c; c = _getch(); swich(c) { case 72: //上方向键的代码 case 80: //下方向键的代码 case 75: //左方向键的代码 case 77: //右方向建的代码 case 13: //回车键的代码 } return 0; } 关键就是_getch()这个函数，他会捕获命令行界面的按键，然后返回对应按键的编码\n其他的按键编码网上应该都能找到的\n顺带讲下UI.hpp里的东西\n结构体 UIInfo\r就是用来传递菜单信息的结构体\n好让主函数知道进行了什么操作，选了哪一个\nUI类\r里面都是静态函数\nConfirm(...)函数用来显示确认菜单\nyesText写确认的文字\nnoText写取消的文字\ncontent写显示的内容\nSelect(...)函数显示选择菜单\n有三个重载\n总之可以显示标题，功能选择项，一般选择项，描述词，默认指针位置\ntitle标题\nfunction功能选择项\ncontent一般选择项\nhead描述词\nindex默认指针位置\n一般选择项十个每页，功能选择项始终显示\nShow(...)函数就是个简单的输出函数\n没啥好说的，让输出好看点而已\n\u0026lt;0x03\u0026gt; CSV文件的读写\rCSV文件的读写代码写在ManageTool.hpp里\n//导出为CSV文件 //原代码的逻辑已经嵌在相关函数里了，这里单独拿出来 #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;MyClass.hpp\u0026#34; #include \u0026#34;MyDate.hpp\u0026#34; #include \u0026#34;UI.hpp\u0026#34; using namespace std; string temp; //当前文件路径 MyClass *selectClass; //MyClass是我写的班级类 ofstream writeFile; //写入文件流 void ExportCSVFile() { writeFile.open(temp.substr(0, temp.length() - 4) + \u0026#34;-\u0026#34; + selectClass-\u0026gt;className + \u0026#34;.csv\u0026#34;, ios::out); writeFile \u0026lt;\u0026lt; \u0026#34;Class name: \u0026#34; \u0026lt;\u0026lt; selectClass-\u0026gt;className \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; selectClass-\u0026gt;children.GetLength() \u0026lt;\u0026lt; \u0026#34;,\\n\u0026#34;; writeFile \u0026lt;\u0026lt; \u0026#34;Name,Birthday,Age,Gender,Address,Height,Weight,Parent\u0026#39;s name,Parent\u0026#39;s phone,note,\\n\u0026#34;; for (int i = 0; i \u0026lt; selectClass-\u0026gt;children.GetLength(); i++) { writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;name \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;birthday.GetDate() \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; if (selectClass-\u0026gt;children[i]-\u0026gt;isBoy) { writeFile \u0026lt;\u0026lt; \u0026#34;Boy,\u0026#34;; } else { writeFile \u0026lt;\u0026lt; \u0026#34;Girl,\u0026#34;; } writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;address \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;height \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;weight \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;parentName \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;parentPhone \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; selectClass-\u0026gt;children[i]-\u0026gt;note \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; writeFile \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } writeFile.close(); UI::Show(\u0026#34;CSV file has been generate\u0026#34;); break; } //由CSV文件导入 //原代码的逻辑已经嵌在相关函数里了，这里单独拿出来 #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;MyClass.hpp\u0026#34; #include \u0026#34;MyDate.hpp\u0026#34; #include \u0026#34;UI.hpp\u0026#34; using namespace std; string path; //路径 MyClass *selectClass; //MyClass是我写的班级类 ifstream readFile; // 读取文件流 Student Create(vector\u0026lt;string\u0026gt; \u0026amp;list) { //由传入的list来创建Student对象并返回 //代码略，见原代码 } void ImportCSV() { readFile.open(path + \u0026#34;\\\\\u0026#34; + files[u.index], ios::in); selectClass-\u0026gt;children.Clear(); string temp; getline(readFile, temp, \u0026#39;,\u0026#39;); getline(readFile, temp, \u0026#39;,\u0026#39;); readFile.get(); vector\u0026lt;string\u0026gt; list; int num = atoi(temp.c_str()); for (int i = 0; i \u0026lt; 10; i++) { getline(readFile, temp, \u0026#39;,\u0026#39;); } //用来忽略表头的 for (int i = 0; i \u0026lt; num; i++) { list.clear(); readFile.get(); //吞上一行回车 for (int j = 0; j \u0026lt; 10; j++) { getline(readFile, temp, \u0026#39;,\u0026#39;); list.push_back(p.assign(temp)); } selectClass-\u0026gt;children.Insert(Create(list), selectClass-\u0026gt;children.GetLength()); } readFile.close(); } CSV文件其实就是数值1,数值2,...这样组成的文件，这种文件格式可以被Excel读取\n输出的时候先输出基本班级信息，然后按行输出每个人的信息\n导入CSV时先读取基本班级信息，然后按行导入学生信息\n输出一般不大会遇到问题，就是读取时文件指针的控制是个问题\n这里在读取时用getline(ifstream,string,char)来读取，碰到,就截断\n前面还有readFile.get()来吞上一行的空格\n\u0026lt;0x04\u0026gt; 多文件管理\r为了方便备份和多幼儿园管理(?)，实现了多工程文件的选择\n选择和访问都应该不成问题，但获取对应文件夹下指定类型的所有文件是个问题\n//关键代码 #include \u0026lt;io.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void GetFiles(string path, vector\u0026lt;string\u0026gt; \u0026amp;files, string fileType) // 获取指定路径下指类型的所有文件名 { intptr_t hFile = 0; // 句柄编号 struct _finddata_t fileInfo; // 文件信息结构体 if ((hFile = _findfirst((path + \u0026#34;\\\\*\u0026#34; + fileType).c_str(), \u0026amp;fileInfo)) != -1) { do { files.push_back(fileInfo.name); // 给files加入文件名 } while (_findnext(hFile, \u0026amp;fileInfo) == 0); _findclose(hFile); // 关闭句柄 } } 这段代码实现了获取指定路径下指定文件类型的所有文件名\n通过句柄实现(也就是用系统api)\n最后的结果会保存在传入的files中\n注意，网上的多数代码会将句柄编号的类型写为long\n但在win10环境下，使用long类型的句柄会导致精度丢失进而导致错\n使用intptr_t就没这个问题\n\u0026lt;0x05\u0026gt; 从临时文件恢复\r为了防止用户系统崩溃(也可能程序崩溃)导致的数据丢失\n管理系统在选择文件后会新建一个一样的同名的.tmp临时文件\n后续的所有文件写入操作都会对这个.tmp文件操作\n只有在用户正常退出系统时才会将.tmp文件保存为.dat文件\n具体来说就是选择文件时并没有真正打开选择的文件，而是读取到文件名\n在选择班级之后，正常读取文件\n如果在班级管理界面里修改了相关数据，并不是修改原文件，而是创建同名临时文件，将修改后的结果写入\n最后用户正常退出后，在主对象析构中把原文件删了，然后把临时文件的后缀改成.dat\n代码就不单独拆出来了，原代码里有具体标明的\n\u0026lt;0x06\u0026gt; 把所有东西拼起来\r总体采用了UI与处理分离的设计\nUI.hpp负责所有的界面输出，ManageTool.hpp负责所有的数据处理和页面逻辑\nmain()函数里就建立了Tool对象然后调用MainDisplay()启动\n之后不同的功能就是不同的函数，不同的页面也是不同的函数\n页面函数调用下一个页面的函数来实现功能的切换\n页面函数相当于不同功能的调度器，页面输出还是靠UI.hpp的函数\nUI的选择结果由UIInfo传递\n其他的文件只是定义所需要的不同的类型\n这样就吧所有的东西都拼起来了\n后记\r课设的基本要求都不难，但是都要完成\n如果要拿优秀，肯定是要扩充功能的\n如果想不到能扩充啥功能，可以优化UI\n课设一般也不大需要多少时间，熟练的话写完课设大概3天\n","date":"2023-06-15T23:42:16Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E6%B5%99%E5%B7%A5%E5%A4%A7c++%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/","title":"浙工大c++课设讲解"},{"content":"\u0026lt;0x00\u0026gt; 这就是个很神秘的问题\r突然想写一段 python 代码，然后打开 vscode\n就很神秘，明明啥配置都没改，代码提示又寄了\n网上搜索了一番，大概总结了3种可能的问题\n\u0026lt;0x01\u0026gt; Python: Default Interpreter Path的问题\r如图写上自己的 python 安装目录即可\n\u0026lt;0x02\u0026gt; python.autoComplete.extraPaths的问题\r如图搜索，然后点击 Edit in setting.json\n按自己的安装路径填上图片里的那些就可以\n\u0026lt;0x03\u0026gt; python.languageServer的问题\r如图,换成 Jedi 就好\n碎碎念\r还是Pychram好用😅，一站式解决所有的问题\n(@ 24-07-19) 现在vscode写python体验很不错了，这种问题之后也没遇到过了\n","date":"2023-06-05T00:16:03Z","permalink":"https://mlacookie.github.io/article/posts/2023/python%E5%9C%A8vscode%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/","title":"Python在VSCode中代码提示异常问题"},{"content":"\u0026lt;0x00\u0026gt; 为啥不用Cmake\r怎么说呢，Cmake 确实不是很好用，虽然说我还是稍微懂点 shell 命令的，但用着就是感觉很怪\n虽然 Cmake 很强大，而且经过这么多年的发展，Cmake 的社区支持也非常丰富\n但对于初学者，Cmake 的各种函数还是显得略微晦涩难懂\n而且 Cmake 在 VS Code 的环境下报错代码会很日怪 (也可能是我没装好对应的插件，反正看报错挺费脑子的)\n\u0026lt;0x01\u0026gt; 为什么使用Xmake\rXmake 使用 lua 作为脚本语言，整体看着能更好理解，并且更加语句更少\n我常用的 Cmake 配置文件\n# CMakeLists.txt cmake_minimum_required(VERSION 3.0.0) project(Course VERSION 0.1.0) include(CTest) enable_testing() # 指定文件转编码为GBK set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -Wall -fexec-charset=GBK\u0026#34;) # 指定编译器和标准 set(CMAKE_CXX_COMPILER \u0026#34;g++\u0026#34;) set(CMAKE_CXX_STANDARD 17) # 添加include路径 include_directories(include) aux_source_directory(src SRC) set(CPACK_PROJECT_NAME ${PROJECT_NAME}) set(CPACK_PROJECT_VERSION ${PROJECT_VERSION}) add_executable(${PROJECT_NAME} ${SRC}) 换成 xmake.lua 的等价配置文件\n--xmake.lua add_rules(\u0026#34;mode.debug\u0026#34;, \u0026#34;mode.release\u0026#34;) target(\u0026#34;xtest\u0026#34;) set_symbols(\u0026#34;debug\u0026#34;) --指定文件转编码为GBK add_cxxflags(\u0026#34;-fexec-charset=GBK\u0026#34;) set_kind(\u0026#34;binary\u0026#34;) --指定C++标准 set_languages(\u0026#34;c++17\u0026#34;) --添加inlude路径 add_includedirs(\u0026#34;include\u0026#34;) add_files(\u0026#34;src/*.cpp\u0026#34;) 是不是确实干净很多？而且更加易懂？\n所以说嘛，人不能折磨自己，如果刚刚打算跑C++的多文件编译，我强烈推荐用Xmake\n在文档中提到Xmake的构建效率可以达到ninja的水平，这个在我的使用中似乎并未体现\n(可能是我的项目相对比较小) 总之Xmake更现代，对很多东西都有很好的原生支持，具体可以看项目文档\n\u0026lt;0x02\u0026gt; 安装Xmake\r如果有配置 winget 可以直接敲下面的命令\nwinget install xmake 也可以去 Github-xmake项目 下载安装包\n直接安装就可以了，全默认就可以\n\u0026lt;0x03\u0026gt; VS Code的配置\rVS Code 的配置也很简单，仅需安装一个叫 Xmake 的插件\n安装上就行了\n\u0026lt;0x04\u0026gt; 由Xmake创建项目\r先新建个文件夹，作为存放项目代码的文件夹\n在 VS Code 中打开这个文件夹\n快捷键 Ctrl+Shift+P 打开命令窗口，输入 Xmake\n选择 XMake: CreateProject 这个选项\n选择后一般右下角会有个窗口，提示没有 xmake.lua 文件，询问是否创建，创建就是了\n然后按你需要的选择配置，我通常选择 C++ 的命令行应用\n之后，项目的文件夹结构就创建好了\n里面的 xmake.lua 就是配置文件，里面已经写好了基本的配置\n如果有 include 的文件，创建个文件夹放然后在配置文件指明就好\n可以直接参考[\u0026lt;0x01\u0026gt;](#\u0026lt;0x01\u0026gt; 为什么使用Xmake)部分的配置文件\n之后创建新项目就按这个方法就可以了，轻松加愉快\n编译时按下面的 Build 或者 ▶ 就可以\n调试就是打完断点，然后按下面的 🐞 图标\n","date":"2023-06-02T19:45:28Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E4%BB%8Ecmake%E6%8D%A2%E5%88%B0xmake/","title":"从Cmake换到Xmake"},{"content":"搭个博客嘛，肯定要加点个人的一些账号。然后呢，我想加个B站的链接，但是在 Anatolo 的模板里没有，这下只能自己动手了。\n一些约定的符号\r./ 表示 hexo 博客的根目录\n\u0026lt;0x00\u0026gt; 分析\r我先是在 ./themes/Anatolo/source/images 里找，发现里面只有网站的 icon 和主要图标，没有那些社交媒体的图标 (比如这样的图标，B站的图标原来是没有的)\n然后就又去找 ./themes/Anatolo/layout/partial 下面的各种文件，发现有个叫 sidebar.pug 和 social_links.pug 这两个文件。问题来了，.pub 是啥文件啊(之前真没接触过)。百度了以下，这是个排版引擎的语言。行吧，直接在线学习。\n然后打开了 sidebar.pug 简单分析下，感觉关系不大。打开 social_links.pug\n// social_links.pug ul.social-links if theme.github li a(href= theme.github) i.fa.fa-github if theme.mail li //- a(href= \u0026#34;javascript:alert(\\\u0026#34;\u0026#34; + theme.mail +\u0026#34;\\\u0026#34;)\u0026#34; ) a(href= \u0026#34;mailto:\u0026#34; + theme.mail ) i.fa.fa-envelope if theme.QQ li a(href= \u0026#34;http://sighttp.qq.com/authd?IDKEY=\u0026#34; + theme.QQ) i.fa.fa-qq if theme.zhihu li a(href= theme.zhihu) i.fa.fa-mortar-board if theme.twitter li a(href= theme.twitter) i.fa.fa-twitter if theme.instagram li a(href= theme.instagram) i.fa.fa-instagram if theme.rss li a(href= url_for(theme.rss)) i.fa.fa-rss if theme.weibo li a(href= theme.weibo) i.fa.fa-weibo if theme.facebook li a(href= theme.facebook) i.fa.fa-facebook 感觉很有关系\n\u0026lt;0x01\u0026gt; 简单的尝试\r于是我就直接很粗暴的在 social_links.pug 里加上这个\nif theme.bilibili li a(href= theme.bilibili) i.fa.fa-bilibili 还有在 ./themes/Anatolo/_config.yml 里加上这个\nbilibili: https://space.bilibili.com/13629146 一编译，一部署，一看，果不其然，直接是空白。 然后看看开发者工具，发现在对应地方的 html 代码里多了这些\n\u0026lt;li\u0026gt; \u0026lt;a target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; href=\u0026#34;https://space.bilibili.com/13629146\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-bilibili\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; 也就是说，其实添加是添加进去了，但就是没有对应的图标而已\n问题来了，\u0026lt;i class=\u0026quot;fa fa-bilibili\u0026quot;\u0026gt; 里面的 fa 指的是什么呢?\n\u0026lt;0x02\u0026gt; 二度分析\r搜索了一下，fa 指的是 Font awesome，是有各种常见图标的字体。找的官网，看了看图标列表，果然没有B站\n这下不得不自己做字体了(如果直接插入图片会更简单倒是)\n翻了翻 ./themes/Anatolo/source/fonts 果然有 FontAwesome 的字体文件\n(有 .otf .eot .svg .ttf .woff .woff2)\n\u0026lt;0x03\u0026gt; 制作图标\r首先需要一个工具网站，用来做字体。然后还需要一个矢量图编辑器。\n网站是 icomoon.io 直接点击右上角的 IcoMoon App 即可\n矢量图编辑器随意，我这里用的是 inkscape\n进入 IcoMoon App 后，点击左上角 Import Icons，选择 .svg 文件\n左上角选择铅笔，然后随便选一个图标，点击 Download(SVG) 下载这个图标的 .svg 文件。\n然后在本地用矢量图编辑器打开，把原来的图清掉，然后再在上面画矢量图就可以了。\n画的时候注意不要用描边，要用填充来构成图形。如果不小心用描边构成了图形，那么也可以选中路径，然后找到这个\n点一下就会自动转换成填充了\n画的时候要尽可能把画布填满，如果上下留白很多的话可以适当减小。\n画布大小可以在文件→文档属性里修改\n如果贝塞尔曲线画不好的话可以先用有理B样条来画，后者好画一点，但画出来就是比较圆润。 用贝塞尔曲线画的画，尽可能让每个节点的手柄要么水平，要么垂直，这样画会相对简单一点\n如果图标有一定的对称性，那么节点要对称，而且手柄的长度也要对称\n我的成果供大家参考。\n然后，保存文件，回到之前的网页。导入我们制作的 .svg 文件。\n然后选择右上角移动工具\n把我们的图标移到列表的最后一个。\n最后选择 Generate Font 生成字体文件。下载前找到我们新制作的图标，可以先检查下有没有什么问题。\n\u0026lt;0x04\u0026gt; 替换原有字体\r下载后解压缩，里面有个 demo.html 可以用来查看字体和字体编号(字体编号很重要)，还有 fonts 文件夹，里面就是我们生成的字体了。\n打开 demo.html，找到我们的图标，记下图标的编号(这个编号在字体生成里也能改)，比如我的字体编号是 f2e1。\n把 fonts 文件下的文件复制到 ./themes/Anatolo/source/fonts\n在 ./themes/Anatolo/source/css 里找到 font-awesome.css 和 font-awesome.min.css (建议每个复制一个作备份)，打开。\n在 font-awesome.css 修改\n/*原来的*/ @font-face { font-family: \u0026#39;FontAwesome\u0026#39;; src: url(\u0026#39;../fonts/fontawesome-webfont.eot?v=4.7.0\u0026#39;); src: url(\u0026#39;../fonts/fontawesome-webfont.eot?#iefix\u0026amp;v=4.7.0\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff2?v=4.7.0\u0026#39;) format(\u0026#39;woff2\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff?v=4.7.0\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.ttf?v=4.7.0\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular\u0026#39;) format(\u0026#39;svg\u0026#39;); font-weight: normal; font-style: normal; } /*修改为*/ @font-face { font-family: \u0026#39;FontAwesome\u0026#39;; src: url(\u0026#39;../fonts/fontawesome-webfont.eot\u0026#39;); src: url(\u0026#39;../fonts/fontawesome-webfont.eot\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;../fonts/fontawesome-webfont.svg\u0026#39;) format(\u0026#39;svg\u0026#39;); font-weight: normal; font-style: normal; } 我这里的字体名还是 fontawesome-webfont 这里名字按自己的来\n然后加上这些\n.fa-bilibili-alt:before { content: \u0026#34;\\f2e1\u0026#34;; } 反正有很多长差不多的，加在那里面就可以。\n\\f2e1 这里要看你的编号填，.fa-bilibili-alt 这个算是给图标起个名字，随意就好。\nfont-awesome.min.css 就是 font-awesome.css 去掉所有缩进的版本，也要加上并修改些东西，在这里就不讲了。\n\u0026lt;0x05\u0026gt; 部署试试\r(记得加上\u0026lt;0x02\u0026gt;的多出来的代码)\n编译，部署。访问下网页看看有没有新图标出现。如果没有，清除或禁用网页缓存后再试试。理论上自己加入的图标就会出现。\n就像这样。\n搞定，下班\r","date":"2023-04-26T21:59:57Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E7%BB%99%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%8A%A0%E4%B8%AAb%E7%AB%99%E5%9B%BE%E6%A0%87/","title":"给侧边栏加个B站图标"},{"content":"用于HP Prime的绘图软件\r(@ 24-02-09)\n原本的服务器已经不续费了，现在只有Github的了\ngithub链接\n使用教程(B站)\n之后应该不更新了，手头没机子测试了\n","date":"2023-04-26T21:53:36Z","permalink":"https://mlacookie.github.io/article/posts/2023/hp-primepaint-v1.0/","title":"HP-PrimePaint-V1.0"},{"content":"\u0026lt;0x01\u0026gt; 如何实现\r思路是本地多写几份 config 文件\n在部署时切换就可以\n\u0026lt;0x02\u0026gt; 开搞\r首先先新建几个 config 文件\n建议直接复制原来的_config.yml\n复制的文件名字随意 我们只需要修改最下面的deploy部分就好\n比如我在 hexo 目录建了两个文件\n分别是_GitPageConfig.yml与_ServerConfig.yml\n# _GitPageConfig.yml的部分 deploy: type: git repo: git@github.com:{github用户名}/{github用户名}.github.io.git branch: gh-pages # _ServerConfig.yml的部分 deploy: type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master 然后新建一个脚本文件\n这里用 windows 配置，所以新建了个 powershell 脚本\n# deploy.ps1 copy _ServerConfig.yml _config.yml hexo g -d del _config.yml copy _GitPageConfig.yml _config.yml hexo g -d del _config.yml 如果要部署到更多的git仓库，以此类推 之后部署只需要执行deploy.ps1即可\n\u0026lt;0x03\u0026gt; 为什么不单文件解决\r(@ 23-07-07)\n经过我的实际测试，确实也可以直接单文件搞定\n# _config.yml deploy: - type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master - type: git repo: git@github.com:{github用户名}/{github用户名}.github.io.git branch: gh-pages 这样写也可以，hexo会按从上到下的顺序依次部署\n但这样写会导致一个问题，就是网址的根域名会对不上\n# _config.yml # 部署到我自己的网站 url: http://mlacookie.top/ # 部署到GitHubPage url: https://MLAcookie.github.io/ 如果仅靠单一文件的话，两个部署的根域名会是一样的\n这样可能会造成一些小问题\n靠powershell还可以顺便做部署前的一些操作，挺方便的\n","date":"2023-04-23T16:35:19Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E5%A6%82%E4%BD%95%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%A4%9Agit/","title":"如何一个hexo博客同时部署多git"},{"content":"\u0026lt;0x00\u0026gt; 为什么要用gitea + hexo\r很简单，gitea 太好用了(才不是因为 git 配置太麻烦)\n而且 hexo 的博客就是静态网页，基本不怎么耗费服务器资源\n如此再搭个 gitea 正好还能当个代码仓库，岂不美哉\n\u0026lt;0x01\u0026gt; 整体运行架构\r就是 gitea 跑 git 仓库\n然后利用 git hook 功能将仓库内容同步到服务器的另一个文件夹\nhexo 的界面靠 nginx 反代 本地写完靠 hexo 的配置脚本通过 git 同步到服务器\n(其实用 gitea 的话也可以通过插件实现 GitHub Page 的功能的)\n\u0026lt;0x02\u0026gt; 先安装些组件\r#安装nginx sudo apt update \u0026amp;\u0026amp; sudo apt upgrade sudo apt install nginx gitea 的安装在这就不赘述了\n(我之前有从零搭建的教程)\n\u0026lt;0x03\u0026gt; 配置git hook\rgit hook 其实就是一个自动化脚本\n简单理解就是 git 到服务器上后服务器要干的事\n首先，在 gitea 里创建一个仓库，名字随意\n#进入对应仓库的hook配置目录 cd /var/lib/gitea/data/gitea-repositories/${gitea用户名}/${仓库名}.git/hooks/ (${gitea用户名}和${仓库名}都是按照自己的设置填的) 这里是 git 的各种 hook，别的现在用不大到\n#进入需要编辑的hook目录 cd post-receive.d/ #创建我们自己的hook，名字随意 vim hexo 在 hexo 文件中，输入以下内容\n#!/bin/bash sss=/var/lib/gitea/data/gitea-repositories/${gitea用户名}/${仓库名}.git ttt=/var/www/blog rm -rf ${ttt} git clone ${sss} ${ttt} 其中/var/www/blog是你希望存储网页的地址，可以改成别的\n#给这个hook添加可执行权限 chmod a+x hexo 现在，理论上当你用 hexo 一键配置脚本的时候，那些网页文件会出现在那个位置\n\u0026lt;0x04\u0026gt; 配置存储地址和nginx\r#进入你希望存网页的位置 cd /var/www/ mkdir blog #为第一次git用户删除提供权限 chmod -R 777 ./ #进入nginx的目录 cd /etc/nginx/ cd sites-enabled/ vim default 需要注意的是，这里的nginx版本可能比较新，所以需要修改/etc/nginx/sites-enabled/default\n如果你在/etc/nginx/nginx.conf中能看到在http{}中有server{}\n那么直接在/etc/nginx/nginx.conf就行\n在server{}中，把root的值改为存储网页的位置\n在这里是改为root /var/www/blog 再在index后加入index.html (有了就不用加)\n#重启nginx服务 nginx -s reload 现在，理论上访问服务器 ip 后就是博客首页了\n\u0026lt;0x05\u0026gt; 本地的一些修改\r打开_config.yml\ndeploy: type: git repo: git@{服务器ip}:{gitea用户名}/{gitea仓库名}.git branch: master 现在，当你运行hexo deploy，网页内容将同步到git仓库并且也会同步到网页存储位置\n","date":"2023-04-23T15:50:19Z","permalink":"https://mlacookie.github.io/article/categories/blog/%E6%90%AD%E5%BB%BAhexo+gitea%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%AB%99/","title":"搭建hexo+gitea的博客站"},{"content":"找到gitea的配置文件\n一般在/etc/gitea中(如果按官方文档配置的话)\n#打开gitea配置文件 cd /etc/gitea vim app.ini 然后往下翻 找到 DISABLE_REGISTRATION\n把 false 改成 true 就可以了\n然后记得重启gitea服务\n#如果已经配置了linux服务 systemctl restart gitea ","date":"2023-04-23T15:40:43Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E5%85%B3%E9%97%ADgitea%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/","title":"关闭gitea注册功能"},{"content":"\u0026lt;0x00\u0026gt; 安装组件\r首先肯定要有台服务器嘛，系统倒问题不大，我用的是debian 11\n#安装各种包前先更新是好文明 sudo apt update sudo apt upgrade #安装git sudo apt install git #安装mysql wget https://dev.mysql.com/get/mysql-apt-config_0.8.22-1_all.deb sudo dpkg -i mysql-apt-config_0.8.22-1_all.deb #这里可能会跳出个界面，直接选最后的ok就可以 rm mysql-apt-config_0.8.22-1_all.deb sudo apt update sudo apt-get install mysql-server 安装mysql的时候会要求你设置数据库 root 账户密码的\n\u0026lt;0x01\u0026gt; 配置mysql\r在/etc/mysql/mysql.conf.d/mysqld.cnf中加入bind-address = 127.0.0.1 这个配置文件的位置看版本，我这里的 mysql 版本是8.0.33 这个bind-address是控制 mysql 数据库允许远程访问的\n#先进入mysql控制台 mysql -u root -p` #输入你设置的root账户密码 #配置gitea的数据库 CREATE USER \u0026#39;gitea\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; #这里写的‘密码’是你想设置的密码 CREATE DATABASE giteadb CHARACTER SET \u0026#39;utf8mb4\u0026#39; COLLATE \u0026#39;utf8mb4_unicode_ci\u0026#39;; GRANT ALL PRIVILEGES ON giteadb.* TO \u0026#39;gitea\u0026#39;; FLUSH PRIVILEGES; exit \u0026lt;0x02\u0026gt; 配置 gitea 和 git 账户\r#下载git安装包 wget -O gitea https://dl.gitea.com/gitea/1.19.0/gitea-1.19.0-linux-amd64 chmod +x gitea #添加git用户并修改权限 adduser git mkdir -p /var/lib/gitea/{custom,data,log} chown -R git:git /var/lib/gitea/ chmod -R 750 /var/lib/gitea/ mkdir /etc/gitea chown root:git /etc/gitea chmod 770 /etc/gitea 手动将下列语句加入/etc/profile文件 export GITEA_WORK_DIR=/var/lib/gitea/ (导出个全局变量)\n#一些剩下的操作 cp gitea /usr/local/bin/gitea sudo vim /etc/systemd/system/gitea.service #将gitea.service的内容复制进去，并取消一些服务的注释，如mysql的 sudo systemctl enable gitea sudo systemctl start gitea 现在访问(你的ip):3000应该是能看到gitea的网页了\n\u0026lt;0x03\u0026gt; 网页配置\r在网页的安装界面，你需要设置你的数据库用户和用户密码\n然后指定数据库名字\n#本次配置的值 数据库用户：gitea 用户密码：(之前给gitea设置的密码) 数据库名称：giteadb 记得在网页最后那里设置管理员账户\n(不在这配置也行，理论上第一个创建的账户就是管理员)\n创建新用户后记得绑定 sshkey，这样就可以用 ssh 的 clone 地址了\n\u0026lt;0x04\u0026gt; 收尾配置\r#最后记得把一些权限修改回来 chmod 750 /etc/gitea chmod 640 /etc/gitea/app.ini 附录：git.service\r用什么数据库就取消注释哪一行\n# git.service [Unit] Description=Gitea (Git with a cup of tea) After=syslog.target After=network.target ### # Don\u0026#39;t forget to add the database service dependencies ### # #Wants=mysql.service #After=mysql.service # #Wants=mariadb.service #After=mariadb.service # #Wants=postgresql.service #After=postgresql.service # #Wants=memcached.service #After=memcached.service # #Wants=redis.service #After=redis.service # ### # If using socket activation for main http/s ### # #After=gitea.main.socket #Requires=gitea.main.socket # ### # (You can also provide gitea an http fallback and/or ssh socket too) # # An example of /etc/systemd/system/gitea.main.socket ### ## ## [Unit] ## Description=Gitea Web Socket ## PartOf=gitea.service ## ## [Socket] ## Service=gitea.service ## ListenStream=\u0026lt;some_port\u0026gt; ## NoDelay=true ## ## [Install] ## WantedBy=sockets.target ## ### [Service] # Uncomment the next line if you have repos with lots of files and get a HTTP 500 error because of that # LimitNOFILE=524288:524288 RestartSec=2s Type=simple User=git Group=git WorkingDirectory=/var/lib/gitea/ # If using Unix socket: tells systemd to create the /run/gitea folder, which will contain the gitea.sock file # (manually creating /run/gitea doesn\u0026#39;t work, because it would not persist across reboots) #RuntimeDirectory=gitea ExecStart=/usr/local/bin/gitea web --config /etc/gitea/app.ini Restart=always Environment=USER=git HOME=/home/git GITEA_WORK_DIR=/var/lib/gitea # If you install Git to directory prefix other than default PATH (which happens # for example if you install other versions of Git side-to-side with # distribution version), uncomment below line and add that prefix to PATH # Don\u0026#39;t forget to place git-lfs binary on the PATH below if you want to enable # Git LFS support #Environment=PATH=/path/to/git/bin:/bin:/sbin:/usr/bin:/usr/sbin # If you want to bind Gitea to a port below 1024, uncomment # the two values below, or use socket activation to pass Gitea its ports as above ### #CapabilityBoundingSet=CAP_NET_BIND_SERVICE #AmbientCapabilities=CAP_NET_BIND_SERVICE ### # In some cases, when using CapabilityBoundingSet and AmbientCapabilities option, you may want to # set the following value to false to allow capabilities to be applied on gitea process. The following # value if set to true sandboxes gitea service and prevent any processes from running with privileges # in the host user namespace. ### #PrivateUsers=false ### [Install] WantedBy=multi-user.target 从gitea文档扒的\n","date":"2023-04-20T23:05:44Z","permalink":"https://mlacookie.github.io/article/posts/2023/%E4%BB%8E0%E6%90%AD%E5%BB%BAgitea/","title":"从零搭建一个gitea"}]