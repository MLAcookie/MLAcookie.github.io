<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="前言\r一般来说离散的课设都是给一大堆题目然后自己选的 我选的是合式公式的真值表和成真成假赋值 算是里面相对难的 (别的是真挺简单的) 课设我是拿C#写的(人生苦短，还是用好用的语言吧) 应该常用的.net版本都能跑起来吧，代码里没怎么用新特性 (我用的是.net 6.0) C#的语法还是挺好懂得，用过C系语言看懂应该问题不大 同样，可以在本文最后复制所有的原码 (就一个文件，就不发本站的gitea了) (报告自己写写挺快的) <0x00> 如何解析合式公式\r在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的 (所谓解析就是判断计算的优先级) 比方说我们有公式1+2*3/(4-5) 按运算优先级加上括号就是(1+((2*3)/(4-5))) 所以说我们该如何让计算机按这样的优先级计算呢 双栈法 准备两个栈，一个是运算数栈，一个是运算符栈 运算式在运算前先在首位各加括号(确保最后会栈空) 然后从左向右遍历运算式 遇到(时直接压入运算符栈，遇到数字压入运算数栈 当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入 如果不是，那么就先进行弹出操作 每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中 重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止 如果遍历过程中遇到)，则反复进行弹出操作，直到弹出一个(为止 (动画是用manim做的，头一次做) 同样的思路也可以运用在合式公式上 具体流程如下： 1 给公式的左右套上括号 2 从左向右读取 3 如果遇到(，将(压入运算符栈后继续 4 如果遇到运算数，压入操作数栈后继续 5 如果遇到运算符，按照以下规则： a 如果运算符栈为空或栈顶元素优先级小于当前运算符，直接压入运算符栈 b 若遇到栈顶元素为┐(非)，需要弹出所有的连续┐(非)，弹出此运算符再弹出一个运算数，并将运算结果压回操作数栈 c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照5.a压入运算符栈 6 遇到)时，反复按照规则弹出，直到运算符栈顶为(，最后移除栈顶的( 7 读取完毕后，操作数栈留下的东西就是公式答案 这个就不再用动画演示了，本质上就是一般+-*/运算双栈法的变种 唯一不一样的就是对于┐(非)要注意连续弹出问题 因为┐(非)是一个右结合单目运算符，而且优先级最高 如果不先处理调连续的┐(非)容易解析出问题 所以要把连续的┐(非)全弹出，当作一个整体，这样才能出正确答案 <0x01> 由双栈法构建运算树\r目前我们已经有方法解析合式公式了，但有一个问题 我们的题目要求给出一个真值表 如果每次计算我们都要先解析一遍合式公式的话，效率不会很高 所以我们要用一种数据结构来保存计算的结构 每个单一操作数数可以改变对应的真假指派(就是T/F) 对于一个计算的过程，我们可以抽象成一个树 所有的操作数都是树的叶子(最末端的节点) 操作数由运算符连接，合成一个新节点 如此嵌套，最后连接在一个根节点上 每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果"><title>浙工大离散课设讲解</title>
<link rel=canonical href=https://mlacookie.github.io/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=/scss/style.min.e8c7fca7d1c9294aa7a4f3426c225ee26540f7d94e39be0b5a4a5c8a49ca5a25.css><meta property='og:title' content="浙工大离散课设讲解"><meta property='og:description' content="前言\r一般来说离散的课设都是给一大堆题目然后自己选的 我选的是合式公式的真值表和成真成假赋值 算是里面相对难的 (别的是真挺简单的) 课设我是拿C#写的(人生苦短，还是用好用的语言吧) 应该常用的.net版本都能跑起来吧，代码里没怎么用新特性 (我用的是.net 6.0) C#的语法还是挺好懂得，用过C系语言看懂应该问题不大 同样，可以在本文最后复制所有的原码 (就一个文件，就不发本站的gitea了) (报告自己写写挺快的) <0x00> 如何解析合式公式\r在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的 (所谓解析就是判断计算的优先级) 比方说我们有公式1+2*3/(4-5) 按运算优先级加上括号就是(1+((2*3)/(4-5))) 所以说我们该如何让计算机按这样的优先级计算呢 双栈法 准备两个栈，一个是运算数栈，一个是运算符栈 运算式在运算前先在首位各加括号(确保最后会栈空) 然后从左向右遍历运算式 遇到(时直接压入运算符栈，遇到数字压入运算数栈 当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入 如果不是，那么就先进行弹出操作 每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中 重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止 如果遍历过程中遇到)，则反复进行弹出操作，直到弹出一个(为止 (动画是用manim做的，头一次做) 同样的思路也可以运用在合式公式上 具体流程如下： 1 给公式的左右套上括号 2 从左向右读取 3 如果遇到(，将(压入运算符栈后继续 4 如果遇到运算数，压入操作数栈后继续 5 如果遇到运算符，按照以下规则： a 如果运算符栈为空或栈顶元素优先级小于当前运算符，直接压入运算符栈 b 若遇到栈顶元素为┐(非)，需要弹出所有的连续┐(非)，弹出此运算符再弹出一个运算数，并将运算结果压回操作数栈 c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照5.a压入运算符栈 6 遇到)时，反复按照规则弹出，直到运算符栈顶为(，最后移除栈顶的( 7 读取完毕后，操作数栈留下的东西就是公式答案 这个就不再用动画演示了，本质上就是一般+-*/运算双栈法的变种 唯一不一样的就是对于┐(非)要注意连续弹出问题 因为┐(非)是一个右结合单目运算符，而且优先级最高 如果不先处理调连续的┐(非)容易解析出问题 所以要把连续的┐(非)全弹出，当作一个整体，这样才能出正确答案 <0x01> 由双栈法构建运算树\r目前我们已经有方法解析合式公式了，但有一个问题 我们的题目要求给出一个真值表 如果每次计算我们都要先解析一遍合式公式的话，效率不会很高 所以我们要用一种数据结构来保存计算的结构 每个单一操作数数可以改变对应的真假指派(就是T/F) 对于一个计算的过程，我们可以抽象成一个树 所有的操作数都是树的叶子(最末端的节点) 操作数由运算符连接，合成一个新节点 如此嵌套，最后连接在一个根节点上 每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果"><meta property='og:url' content='https://mlacookie.github.io/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/'><meta property='og:site_name' content='MLAcookie'><meta property='og:type' content='article'><meta property='article:section' content='Article'><meta property='article:tag' content='CourseProject'><meta property='article:tag' content='CSharp'><meta property='article:published_time' content='2023-07-04T13:14:00+00:00'><meta property='article:modified_time' content='2023-07-04T13:14:00+00:00'><meta name=twitter:title content="浙工大离散课设讲解"><meta name=twitter:description content="前言\r一般来说离散的课设都是给一大堆题目然后自己选的 我选的是合式公式的真值表和成真成假赋值 算是里面相对难的 (别的是真挺简单的) 课设我是拿C#写的(人生苦短，还是用好用的语言吧) 应该常用的.net版本都能跑起来吧，代码里没怎么用新特性 (我用的是.net 6.0) C#的语法还是挺好懂得，用过C系语言看懂应该问题不大 同样，可以在本文最后复制所有的原码 (就一个文件，就不发本站的gitea了) (报告自己写写挺快的) <0x00> 如何解析合式公式\r在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的 (所谓解析就是判断计算的优先级) 比方说我们有公式1+2*3/(4-5) 按运算优先级加上括号就是(1+((2*3)/(4-5))) 所以说我们该如何让计算机按这样的优先级计算呢 双栈法 准备两个栈，一个是运算数栈，一个是运算符栈 运算式在运算前先在首位各加括号(确保最后会栈空) 然后从左向右遍历运算式 遇到(时直接压入运算符栈，遇到数字压入运算数栈 当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入 如果不是，那么就先进行弹出操作 每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中 重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止 如果遍历过程中遇到)，则反复进行弹出操作，直到弹出一个(为止 (动画是用manim做的，头一次做) 同样的思路也可以运用在合式公式上 具体流程如下： 1 给公式的左右套上括号 2 从左向右读取 3 如果遇到(，将(压入运算符栈后继续 4 如果遇到运算数，压入操作数栈后继续 5 如果遇到运算符，按照以下规则： a 如果运算符栈为空或栈顶元素优先级小于当前运算符，直接压入运算符栈 b 若遇到栈顶元素为┐(非)，需要弹出所有的连续┐(非)，弹出此运算符再弹出一个运算数，并将运算结果压回操作数栈 c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照5.a压入运算符栈 6 遇到)时，反复按照规则弹出，直到运算符栈顶为(，最后移除栈顶的( 7 读取完毕后，操作数栈留下的东西就是公式答案 这个就不再用动画演示了，本质上就是一般+-*/运算双栈法的变种 唯一不一样的就是对于┐(非)要注意连续弹出问题 因为┐(非)是一个右结合单目运算符，而且优先级最高 如果不先处理调连续的┐(非)容易解析出问题 所以要把连续的┐(非)全弹出，当作一个整体，这样才能出正确答案 <0x01> 由双栈法构建运算树\r目前我们已经有方法解析合式公式了，但有一个问题 我们的题目要求给出一个真值表 如果每次计算我们都要先解析一遍合式公式的话，效率不会很高 所以我们要用一种数据结构来保存计算的结构 每个单一操作数数可以改变对应的真假指派(就是T/F) 对于一个计算的过程，我们可以抽象成一个树 所有的操作数都是树的叶子(最末端的节点) 操作数由运算符连接，合成一个新节点 如此嵌套，最后连接在一个根节点上 每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果"><link rel="shortcut icon" href=/favicon.webp></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu01ec501d434397934aa5721ebabee736_552660_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😜</span></figure><div class=site-meta><h1 class=site-name><a href=/>MLAcookie</a></h1><h2 class=site-description>随便记点东西的记事本</h2></div></header><ol class=menu-social><li><a href=https://space.bilibili.com/13629146 target=_blank title=MLA_cookie@bilibili rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=https://github.com/MLAcookie target=_blank title=MLAcookie@Github rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/page/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#0x00-如何解析合式公式>&lt;0x00> 如何解析合式公式</a></li><li><a href=#0x01-由双栈法构建运算树>&lt;0x01> 由双栈法构建运算树</a></li><li><a href=#0x02-逻辑实现>&lt;0x02> 逻辑实现</a><ul><li><a href=#按从低到高的优先级列出运算符的枚举类型>按从低到高的优先级列出运算符的枚举类型</a></li><li><a href=#定义计算树的计算节点类仅列出定义>定义计算树的计算节点类(仅列出定义)</a></li><li><a href=#定义wellformedformula类仅列出定义>定义WellFormedFormula类(仅列出定义)</a></li></ul></li><li><a href=#附录所有的代码>附录，所有的代码</a></li></ul></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/>浙工大离散课设讲解</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jul 04, 2023</time></div></footer></div></header><section class=article-content><h2 id=前言>前言</h2><p>一般来说离散的课设都是给一大堆题目然后自己选的<br>我选的是合式公式的真值表和成真成假赋值<br>算是里面相对难的<br>(别的是真挺简单的)</p><p>课设我是拿<code>C#</code>写的(人生苦短，还是用好用的语言吧)<br>应该常用的<code>.net</code>版本都能跑起来吧，代码里没怎么用新特性<br>(我用的是<code>.net 6.0</code>)<br><code>C#</code>的语法还是挺好懂得，用过C系语言看懂应该问题不大</p><p>同样，可以在本文最后复制所有的原码<br>(就一个文件，就不发本站的<code>gitea</code>了)<br>(报告自己写写挺快的)</p><h2 id=0x00-如何解析合式公式>&lt;0x00> 如何解析合式公式</h2><p>在尝试解析合式公式前，我们可以先想想我们该如何解析一般加减乘除的<br>(所谓解析就是判断计算的优先级)</p><p>比方说我们有公式<code>1+2*3/(4-5)</code><br>按运算优先级加上括号就是<code>(1+((2*3)/(4-5)))</code><br>所以说我们该如何让计算机按这样的优先级计算呢</p><p>双栈法<br>准备两个栈，一个是运算数栈，一个是运算符栈<br>运算式在运算前先在首位各加括号(确保最后会栈空)<br>然后从左向右遍历运算式<br>遇到<code>(</code>时直接压入运算符栈，遇到数字压入运算数栈<br>当遇到运算符时，先检查当前运算符优先级是否大于栈顶运算符，如是，直接压入<br>如果不是，那么就先进行弹出操作<br>每次弹出都是弹出一个运算符与两个运算数，并将运算结果再压入运算符栈中<br>重复弹出，直到当前运算符优先级大于运算符栈顶的运算符优先级为止<br>如果遍历过程中遇到<code>)</code>，则反复进行弹出操作，直到弹出一个<code>(</code>为止</p><p><img src=/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/1.gif width=400 height=400 srcset="/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/1_hu258ec33d35618ac3195ff0565a7c9b2d_11767406_480x0_resize_box_1.gif 480w, /article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/1_hu258ec33d35618ac3195ff0565a7c9b2d_11767406_1024x0_resize_box_1.gif 1024w" loading=lazy alt=演示动画 class=gallery-image data-flex-grow=100 data-flex-basis=240px><br>(动画是用<code>manim</code>做的，头一次做)</p><p>同样的思路也可以运用在合式公式上<br>具体流程如下：</p><ul><li>1 给公式的左右套上括号</li><li>2 从左向右读取</li><li>3 如果遇到<code>(</code>，将<code>(</code>压入<code>运算符栈</code>后继续</li><li>4 如果遇到运算数，压入<code>操作数栈</code>后继续</li><li>5 如果遇到运算符，按照以下规则：<ul><li>a 如果<code>运算符栈</code>为空或栈顶元素优先级小于当前运算符，直接压入<code>运算符栈</code></li><li>b 若遇到栈顶元素为<code>┐(非)</code>，需要弹出所有的连续<code>┐(非)</code>，弹出此运算符再弹出一个运算数，并将运算结果压回<code>操作数栈</code></li><li>c 其余情况按照弹出一个运算符并弹出两个操作数的规则，反复弹出，并将结合结果压回操作数栈，直到能按照<code>5.a</code>压入<code>运算符栈</code></li></ul></li><li>6 遇到<code>)</code>时，反复按照规则弹出，直到<code>运算符栈</code>顶为<code>(</code>，最后移除栈顶的<code>(</code></li><li>7 读取完毕后，<code>操作数栈</code>留下的东西就是公式答案</li></ul><p>这个就不再用动画演示了，本质上就是一般<code>+-*/</code>运算双栈法的变种<br>唯一不一样的就是对于<code>┐(非)</code>要注意连续弹出问题<br>因为<code>┐(非)</code>是一个右结合单目运算符，而且优先级最高<br>如果不先处理调连续的<code>┐(非)</code>容易解析出问题<br>所以要把连续的<code>┐(非)</code>全弹出，当作一个整体，这样才能出正确答案</p><h2 id=0x01-由双栈法构建运算树>&lt;0x01> 由双栈法构建运算树</h2><p>目前我们已经有方法解析合式公式了，但有一个问题<br>我们的题目要求给出一个真值表<br>如果每次计算我们都要先解析一遍合式公式的话，效率不会很高</p><p>所以我们要用一种数据结构来保存计算的结构<br>每个单一操作数数可以改变对应的真假指派(就是<code>T/F</code>)</p><p>对于一个计算的过程，我们可以抽象成一个树<br>所有的操作数都是树的叶子(最末端的节点)<br>操作数由运算符连接，合成一个新节点<br>如此嵌套，最后连接在一个根节点上<br>每次计算时，先给操作数真假指派，然后走遍计算树，根节点的值就是公式的计算结果</p><p><img src=/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/2.png width=381 height=279 srcset="/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/2_hu215fccaeef457934695ea3694b27b0df_34017_480x0_resize_box_3.png 480w, /article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7%E7%A6%BB%E6%95%A3%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/picture/2_hu215fccaeef457934695ea3694b27b0df_34017_1024x0_resize_box_3.png 1024w" loading=lazy alt=计算树结构 class=gallery-image data-flex-grow=136 data-flex-basis=327px><br>就是这么个结构</p><p>怎么构建这棵树呢，其实之前的双栈法里就有这个答案<br>我们仅需略微更改下代码，操作数栈不存储运算结果而是存储运算节点<br>这样走一遍公式就相当于构建了一颗计算树<br>最后只要存储根节点就好了</p><h2 id=0x02-逻辑实现>&lt;0x02> 逻辑实现</h2><h3 id=按从低到高的优先级列出运算符的枚举类型>按从低到高的优先级列出运算符的枚举类型</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Operator<span style=color:#75715e>//枚举运算符</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    LeftBracket,<span style=color:#75715e>//左括号</span>
</span></span><span style=display:flex><span>    XNOR,<span style=color:#75715e>//双条件运算符</span>
</span></span><span style=display:flex><span>    Odds,<span style=color:#75715e>//条件运算符</span>
</span></span><span style=display:flex><span>    Or,<span style=color:#75715e>//析取运算符</span>
</span></span><span style=display:flex><span>    And,<span style=color:#75715e>//合取运算符</span>
</span></span><span style=display:flex><span>    Not,<span style=color:#75715e>//取反运算符</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定义计算树的计算节点类仅列出定义>定义计算树的计算节点类(仅列出定义)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CalculateNode</span><span style=color:#75715e>//定义计算节点</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    CalculateNode? left;<span style=color:#75715e>//运算符左边</span>
</span></span><span style=display:flex><span>    CalculateNode? right;<span style=color:#75715e>//运算符右边</span>
</span></span><span style=display:flex><span>    Operator oper;<span style=color:#75715e>//节点的运算符</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> ans;<span style=color:#75715e>//该节点答案</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> CalculateNode(<span style=color:#66d9ef>bool</span> ans);<span style=color:#75715e>//末节点构造方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> CalculateNode(CalculateNode? left, CalculateNode right, Operatoroper);<span style=color:#75715e>//计算节点构造方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> Odds(<span style=color:#66d9ef>bool</span> a, <span style=color:#66d9ef>bool</span> b);<span style=color:#75715e>//单独定义条件运算符</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> Calculate(CalculateNode node);<span style=color:#75715e>//从某节点递归计算</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>bool</span> Calculate();<span style=color:#75715e>//提供一个入口</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>void</span> ChangeAns(<span style=color:#66d9ef>bool</span> ans);<span style=color:#75715e>//改变末节点的值</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，每个计算节点包含运算符，左边节点，右边节点，节点答案<br>操作数节点仅有节点答案(所以左右节点的类型是可空类型)<br>因为条件运算符没有现成的运算符，所以自己写一个<br><code>Calculate(CalculateNode node)</code>通过递归来遍历每个节点并给出每个节点的答案<br><code>Calculate()</code>专门给外部调用的，里面就一句<code>return Calculate(this);</code><br><code>ChangeAns(bool ans)</code>用来改变操作数的真假指派</p><h3 id=定义wellformedformula类仅列出定义>定义WellFormedFormula类(仅列出定义)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WellFormedFormula</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> formula;<span style=color:#75715e>//原公式</span>
</span></span><span style=display:flex><span>    Dictionary&lt;<span style=color:#66d9ef>string</span>, CalculateNode&gt; map;<span style=color:#75715e>//以string方式索引所有节点</span>
</span></span><span style=display:flex><span>    Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt; dic;<span style=color:#75715e>//以int方式索引所有根节点的名字</span>
</span></span><span style=display:flex><span>    CalculateNode root;<span style=color:#75715e>//最终答案节点</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span>[] truthTable;<span style=color:#75715e>//真值表</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsOperator(<span style=color:#66d9ef>char</span> c);<span style=color:#75715e>//判断是否为二元运算符</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> OperatorToChar(Operator op);<span style=color:#75715e>//运算符换成char</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Operator CharToOperator(<span style=color:#66d9ef>char</span> c);<span style=color:#75715e>//char换成运算符</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> Verify();<span style=color:#75715e>//验证公式是否有效</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Init();<span style=color:#75715e>//初始化计算树</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> WellFormedFormula(<span style=color:#66d9ef>string</span> formula);<span style=color:#75715e>//构造方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Calculate(<span style=color:#66d9ef>int</span> n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Calculate(Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>bool</span>&gt; keyValuePairs);<span style=color:#75715e>//单独计算用</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CalculateAll();<span style=color:#75715e>//全计算</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ChangeFormula(<span style=color:#66d9ef>string</span> formula);<span style=color:#75715e>//更改公式</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowrTruthTable();<span style=color:#75715e>//展示真值表</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowFormula();<span style=color:#75715e>//展示公式</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowAllNode();<span style=color:#75715e>//展示所有节点信息，用于调试</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowTrueAssignment();<span style=color:#75715e>//展示所有成真赋值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowFalseAssignment();<span style=color:#75715e>//展示所有成假赋值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowDNF();<span style=color:#75715e>//主析取范式</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowCNF();<span style=color:#75715e>//主合取范式</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最关键的是<code>Init()</code>方法，别的实现不难</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Init()<span style=color:#75715e>//初始化计算树(略去实现细节)</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Verify();<span style=color:#75715e>//验证</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取所有的变量</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//构建计算树</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>    CalculateAll();<span style=color:#75715e>//顺便把真值表给算了</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>Init()</code>中，先验证公式合法性(防输入错误)<br>然后会先遍历遍公式，获取所有的变量名并创建操作数节点(末节点)<br>然后再遍历一遍，构建计算树<br>构建完成后，<code>root</code>指向根节点，<code>map</code>可以按节点名索引到对应的操作数节点<br><code>dic</code>可以按<code>index</code>索引到节点名字(方便遍历)<br>构建完再计算所有的赋值情况，直接得出真值表<br>其他的方法都是调用真值表答案，不会再计算公式</p><p>构建过程就是双栈法构建</p><h2 id=附录所有的代码>附录，所有的代码</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>//核心逻辑实现</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> CStest
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Operator<span style=color:#75715e>//枚举运算符</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LeftBracket,<span style=color:#75715e>//左括号</span>
</span></span><span style=display:flex><span>        XNOR,<span style=color:#75715e>//双条件运算符</span>
</span></span><span style=display:flex><span>        Odds,<span style=color:#75715e>//条件运算符</span>
</span></span><span style=display:flex><span>        Or,<span style=color:#75715e>//析取运算符</span>
</span></span><span style=display:flex><span>        And,<span style=color:#75715e>//合取运算符</span>
</span></span><span style=display:flex><span>        Not,<span style=color:#75715e>//取反运算符</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CalculateNode</span><span style=color:#75715e>//定义计算节点</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CalculateNode? left;<span style=color:#75715e>//运算符左边</span>
</span></span><span style=display:flex><span>        CalculateNode? right;<span style=color:#75715e>//运算符右边</span>
</span></span><span style=display:flex><span>        Operator oper;<span style=color:#75715e>//节点的运算符</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> ans;<span style=color:#75715e>//该节点答案</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>internal</span> CalculateNode(<span style=color:#66d9ef>bool</span> ans)<span style=color:#75715e>//末节点构造方法</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            left = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            right = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.ans = ans;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>internal</span> CalculateNode(CalculateNode? left, CalculateNode right, Operator oper)<span style=color:#75715e>//计算节点构造方法</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.left = left;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.right = right;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.oper = oper;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> Odds(<span style=color:#66d9ef>bool</span> a, <span style=color:#66d9ef>bool</span> b)<span style=color:#75715e>//单独定义条件运算符</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!a)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (b)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> Calculate(CalculateNode node)<span style=color:#75715e>//从某节点递归计算</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node.right == <span style=color:#66d9ef>null</span>)<span style=color:#75715e>//递归边界条件</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> node.ans;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> (node.oper)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.Not:
</span></span><span style=display:flex><span>                    node.ans = !Calculate(node.right);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.And:
</span></span><span style=display:flex><span>                    node.ans = Calculate(node.left) &amp;&amp; Calculate(node.right);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.Or:
</span></span><span style=display:flex><span>                    node.ans = Calculate(node.left) || Calculate(node.right);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.Odds:
</span></span><span style=display:flex><span>                    node.ans = Odds(Calculate(node.left), Calculate(node.right));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.XNOR:
</span></span><span style=display:flex><span>                    node.ans = !(Calculate(node.left) ^ Calculate(node.right));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node.ans;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>bool</span> Calculate()<span style=color:#75715e>//提供一个入口</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Calculate(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>void</span> ChangeAns(<span style=color:#66d9ef>bool</span> ans)<span style=color:#75715e>//改变末节点的值</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.ans = ans;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WellFormedFormula</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> formula;<span style=color:#75715e>//原公式</span>
</span></span><span style=display:flex><span>        Dictionary&lt;<span style=color:#66d9ef>string</span>, CalculateNode&gt; map;<span style=color:#75715e>//以string方式索引所有节点</span>
</span></span><span style=display:flex><span>        Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt; dic;<span style=color:#75715e>//以int方式索引所有根节点的名字</span>
</span></span><span style=display:flex><span>        CalculateNode root;<span style=color:#75715e>//最终答案节点</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span>[] truthTable;<span style=color:#75715e>//真值表</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsOperator(<span style=color:#66d9ef>char</span> c)<span style=color:#75715e>//判断是否为二元运算符</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> c == <span style=color:#e6db74>&#39;∧&#39;</span> || c == <span style=color:#e6db74>&#39;∨&#39;</span> || c == <span style=color:#e6db74>&#39;→&#39;</span> || c == <span style=color:#e6db74>&#39;⊙&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> OperatorToChar(Operator op)<span style=color:#75715e>//运算符换成char</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> (op)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.And: <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;∧&#39;</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.Or: <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;∨&#39;</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.Odds: <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;→&#39;</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> Operator.XNOR: <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;⊙&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39; &#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Operator CharToOperator(<span style=color:#66d9ef>char</span> c)<span style=color:#75715e>//char换成运算符</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> (c)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;∧&#39;</span>: <span style=color:#66d9ef>return</span> Operator.And;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;∨&#39;</span>: <span style=color:#66d9ef>return</span> Operator.Or;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;→&#39;</span>: <span style=color:#66d9ef>return</span> Operator.Odds;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;⊙&#39;</span>: <span style=color:#66d9ef>return</span> Operator.XNOR;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Operator.LeftBracket;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> Verify()<span style=color:#75715e>//验证公式是否有效</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (IsOperator(formula[<span style=color:#ae81ff>0</span>]) || formula[^<span style=color:#ae81ff>1</span>] == <span style=color:#e6db74>&#39;┐&#39;</span> || IsOperator(formula[^<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Error in formula&#34;</span>);<span style=color:#75715e>//在首尾出现了不该出现的运算符</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> l = <span style=color:#ae81ff>0</span>;<span style=color:#75715e>//统计左括号</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> r = <span style=color:#ae81ff>0</span>;<span style=color:#75715e>//统计右括号</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; formula.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;(&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    l++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;)&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    r++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;┐&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (IsOperator(formula[i + <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Error in formula&#34;</span>);<span style=color:#75715e>//取反运算符后接别的运算符</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (IsOperator(formula[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (IsOperator(formula[i - <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Error in formula&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (IsOperator(formula[i + <span style=color:#ae81ff>1</span>]) || formula[i + <span style=color:#ae81ff>1</span>] == <span style=color:#e6db74>&#39;┐&#39;</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Error in formula&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }<span style=color:#75715e>//都是判断多个运算符不应该相连的情况</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (l != r)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Error in formula&#34;</span>);<span style=color:#75715e>//左右括号数不匹配</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Init()<span style=color:#75715e>//初始化计算树</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Verify();<span style=color:#75715e>//验证</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> formula = <span style=color:#e6db74>&#34;(&#34;</span> + <span style=color:#66d9ef>this</span>.formula + <span style=color:#e6db74>&#34;)&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//获取所有的变量</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bool</span> flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; formula.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (flag &amp;&amp; formula[i] != <span style=color:#e6db74>&#39;(&#39;</span> &amp;&amp; formula[i] != <span style=color:#e6db74>&#39;┐&#39;</span> &amp;&amp; !IsOperator(formula[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    index = i;
</span></span><span style=display:flex><span>                    flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;)&#39;</span> || formula[i] == <span style=color:#e6db74>&#39;┐&#39;</span> || IsOperator(formula[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index != i &amp;&amp; !flag &amp;&amp; !map.ContainsKey(formula[index..i]))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        map.Add(formula[index..i], <span style=color:#66d9ef>new</span> CalculateNode(<span style=color:#66d9ef>false</span>));
</span></span><span style=display:flex><span>                        dic.Add(dic.Count, formula[index..i]);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//构建计算树</span>
</span></span><span style=display:flex><span>            Stack&lt;<span style=color:#66d9ef>string</span>&gt; v = <span style=color:#66d9ef>new</span> Stack&lt;<span style=color:#66d9ef>string</span>&gt;();<span style=color:#75715e>//操作数栈</span>
</span></span><span style=display:flex><span>            Stack&lt;Operator&gt; op = <span style=color:#66d9ef>new</span> Stack&lt;Operator&gt;();<span style=color:#75715e>//运算符栈</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> sa;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> sb;<span style=color:#75715e>//两个临时string变量</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; formula.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;(&#39;</span>)<span style=color:#75715e>//左括号直接压入栈</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    op.Push(Operator.LeftBracket);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (flag &amp;&amp; formula[i] != <span style=color:#e6db74>&#39;)&#39;</span> &amp;&amp; formula[i] != <span style=color:#e6db74>&#39;┐&#39;</span> &amp;&amp; !IsOperator(formula[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    index = i;
</span></span><span style=display:flex><span>                    flag = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;)&#39;</span> || formula[i] == <span style=color:#e6db74>&#39;┐&#39;</span> || IsOperator(formula[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index != i &amp;&amp; !flag)<span style=color:#75715e>//压入操作数</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        v.Push(formula[index..i]);
</span></span><span style=display:flex><span>                        flag = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;┐&#39;</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        op.Push(Operator.Not);<span style=color:#75715e>//取反直接压入</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (formula[i] == <span style=color:#e6db74>&#39;)&#39;</span>)<span style=color:#75715e>//遇到右括号不断弹出，直到遇到左括号</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>while</span> (op.Peek() != Operator.LeftBracket)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (op.Peek() == Operator.Not)
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                sa = v.Pop();
</span></span><span style=display:flex><span>                                map.Add(<span style=color:#e6db74>&#34;(┐&#34;</span> + sa + <span style=color:#e6db74>&#34;)&#34;</span>, <span style=color:#66d9ef>new</span> CalculateNode(<span style=color:#66d9ef>null</span>, map[sa], Operator.Not));
</span></span><span style=display:flex><span>                                v.Push(<span style=color:#e6db74>&#34;(┐&#34;</span> + sa + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                sa = v.Pop();
</span></span><span style=display:flex><span>                                sb = v.Pop();
</span></span><span style=display:flex><span>                                map.Add(<span style=color:#e6db74>&#34;(&#34;</span> + sb + OperatorToChar(op.Peek()) + sa + <span style=color:#e6db74>&#34;)&#34;</span>, <span style=color:#66d9ef>new</span> CalculateNode(map[sb], map[sa], op.Peek()));
</span></span><span style=display:flex><span>                                v.Push(<span style=color:#e6db74>&#34;(&#34;</span> + sb + OperatorToChar(op.Peek()) + sa + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            op.Pop();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        op.Pop();<span style=color:#75715e>//弹出左括号</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (op.Count != <span style=color:#ae81ff>0</span> &amp;&amp; CharToOperator(formula[i]) &lt; op.Peek())
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (op.Peek() == Operator.Not)
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>do</span><span style=color:#75715e>//由于取反运算可多个连接，所以要一次性弹出所有连续的取反运算</span>
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                    op.Pop();
</span></span><span style=display:flex><span>                                    sa = v.Pop();
</span></span><span style=display:flex><span>                                    map.Add(<span style=color:#e6db74>&#34;(┐&#34;</span> + sa + <span style=color:#e6db74>&#34;)&#34;</span>, <span style=color:#66d9ef>new</span> CalculateNode(<span style=color:#66d9ef>null</span>, map[sa], Operator.Not));
</span></span><span style=display:flex><span>                                    v.Push(<span style=color:#e6db74>&#34;(┐&#34;</span> + sa + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                                } <span style=color:#66d9ef>while</span> (op.Peek() == Operator.Not);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                sa = v.Pop();
</span></span><span style=display:flex><span>                                sb = v.Pop();
</span></span><span style=display:flex><span>                                map.Add(<span style=color:#e6db74>&#34;(&#34;</span> + sb + OperatorToChar(op.Peek()) + sa + <span style=color:#e6db74>&#34;)&#34;</span>, <span style=color:#66d9ef>new</span> CalculateNode(map[sb], map[sa], op.Peek()));
</span></span><span style=display:flex><span>                                v.Push(<span style=color:#e6db74>&#34;(&#34;</span> + sb + OperatorToChar(op.Peek()) + sa + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                                op.Pop();
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        op.Push(CharToOperator(formula[i]));<span style=color:#75715e>//最后把当前运算符压入</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            root = map[v.Pop()];<span style=color:#75715e>//最后的操作数就是root节点</span>
</span></span><span style=display:flex><span>            truthTable = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bool</span>[(<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count)];
</span></span><span style=display:flex><span>            CalculateAll();<span style=color:#75715e>//顺便把真值表给算了</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> WellFormedFormula(<span style=color:#66d9ef>string</span> formula)<span style=color:#75715e>//构造方法</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            map = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, CalculateNode&gt;();
</span></span><span style=display:flex><span>            dic = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.formula = formula;
</span></span><span style=display:flex><span>            Init();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Calculate(<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> truthTable[n];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Calculate(Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>bool</span>&gt; keyValuePairs)<span style=color:#75715e>//单独计算用</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (keyValuePairs.Count != dic.Count)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> kv <span style=color:#66d9ef>in</span> keyValuePairs)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                map[kv.Key].ChangeAns(kv.Value);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> root.Calculate();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CalculateAll()<span style=color:#75715e>//全计算</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Stack&lt;<span style=color:#66d9ef>bool</span>&gt; b = <span style=color:#66d9ef>new</span> Stack&lt;<span style=color:#66d9ef>bool</span>&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                b.Clear();
</span></span><span style=display:flex><span>                index = i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (index &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        b.Push(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        b.Push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    index /= <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (b.Count &lt; dic.Count)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    b.Push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; dic.Count; j++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    map[dic[j]].ChangeAns(b.Pop());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                truthTable[i] = root.Calculate();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ChangeFormula(<span style=color:#66d9ef>string</span> formula)<span style=color:#75715e>//更改公式</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.formula = formula;
</span></span><span style=display:flex><span>            map.Clear();
</span></span><span style=display:flex><span>            dic.Clear();
</span></span><span style=display:flex><span>            Init();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowrTruthTable()<span style=color:#75715e>//展示真值表</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dic.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.Write(dic[i] + <span style=color:#e6db74>&#39;\t&#39;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine(formula);
</span></span><span style=display:flex><span>            Stack&lt;<span style=color:#66d9ef>bool</span>&gt; b = <span style=color:#66d9ef>new</span> Stack&lt;<span style=color:#66d9ef>bool</span>&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                index = i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (index &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        b.Push(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        b.Push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    index /= <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (b.Count &lt; dic.Count)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    b.Push(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (b.Count &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (b.Pop())
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;T\t&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;F\t&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (truthTable[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.WriteLine(<span style=color:#e6db74>&#34;T&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.WriteLine(<span style=color:#e6db74>&#34;F&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowFormula()<span style=color:#75715e>//展示公式</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(formula);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowAllNode()<span style=color:#75715e>//展示所有节点信息，用于调试</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.Write(<span style=color:#e6db74>&#34;| &#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> m <span style=color:#66d9ef>in</span> map)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.Write(m.Key + <span style=color:#e6db74>&#34; | &#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowTrueAssignment()<span style=color:#75715e>//展示所有成真赋值</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.Write(<span style=color:#e6db74>&#34;All true assignment: &#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dic.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.Write(dic[i]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.Write(<span style=color:#e6db74>&#34; | &#34;</span> + dic[i]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index;
</span></span><span style=display:flex><span>            Stack&lt;<span style=color:#66d9ef>byte</span>&gt; temp = <span style=color:#66d9ef>new</span> Stack&lt;<span style=color:#66d9ef>byte</span>&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                temp.Clear();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (truthTable[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    index = i;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (index &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        temp.Push((<span style=color:#66d9ef>byte</span>)(index % <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>                        index /= <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (temp.Count &lt; dic.Count)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        temp.Push(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (temp.Count &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(temp.Pop());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Console.WriteLine(<span style=color:#e6db74>&#34;(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowFalseAssignment()<span style=color:#75715e>//展示所有成假赋值</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.Write(<span style=color:#e6db74>&#34;All false assignment: &#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dic.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.Write(dic[i]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Console.Write(<span style=color:#e6db74>&#34; | &#34;</span> + dic[i]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index;
</span></span><span style=display:flex><span>            Stack&lt;<span style=color:#66d9ef>byte</span>&gt; temp = <span style=color:#66d9ef>new</span> Stack&lt;<span style=color:#66d9ef>byte</span>&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                temp.Clear();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!truthTable[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    index = i;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (index &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        temp.Push((<span style=color:#66d9ef>byte</span>)(index % <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>                        index /= <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (temp.Count &lt; dic.Count)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        temp.Push(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (temp.Count &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(temp.Pop());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Console.WriteLine(<span style=color:#e6db74>&#34;(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowDNF()<span style=color:#75715e>//主析取范式</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (truthTable[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (count == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;m(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;∨m(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    count++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ShowCNF()<span style=color:#75715e>//主合取范式</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (<span style=color:#66d9ef>int</span>)Math.Pow(<span style=color:#ae81ff>2</span>, dic.Count); i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!truthTable[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (count == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;M(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        Console.Write(<span style=color:#e6db74>&#34;∧M(&#34;</span> + i + <span style=color:#e6db74>&#34;)&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    count++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#75715e>//main.cs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> CTest{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>test</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(String[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            WellFormedFormula w = <span style=color:#66d9ef>new</span> WellFormedFormula(<span style=color:#e6db74>&#34;(P∨Q)∧(P→R)&#34;</span>);
</span></span><span style=display:flex><span>            w.ShowAllNode();
</span></span><span style=display:flex><span>            w.ShowrTruthTable();
</span></span><span style=display:flex><span>            w.ShowTrueAssignment();
</span></span><span style=display:flex><span>            w.ShowFalseAssignment();
</span></span><span style=display:flex><span>            w.ShowCNF();
</span></span><span style=display:flex><span>            w.ShowDNF();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><footer class=article-footer><section class=article-tags><a href=/tags/courseproject/>CourseProject</a>
<a href=/tags/csharp/>CSharp</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/article/posts/%E6%B5%99%E5%B7%A5%E5%A4%A7c++%E8%AF%BE%E8%AE%BE%E8%AE%B0%E5%BD%95/><div class=article-details><h2 class=article-title>浙工大c++课设讲解</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 MLAcookie</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>